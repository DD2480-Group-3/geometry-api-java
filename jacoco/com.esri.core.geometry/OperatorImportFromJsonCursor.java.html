<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OperatorImportFromJsonCursor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">OperatorImportFromJsonCursor.java</span></div><h1>OperatorImportFromJsonCursor.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2017 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */

package com.esri.core.geometry;

import com.esri.core.geometry.MultiVertexGeometryImpl.DirtyFlags;
import com.esri.core.geometry.VertexDescription.Semantics;

<span class="fc" id="L30">class OperatorImportFromJsonCursor extends MapGeometryCursor {</span>
	JsonReaderCursor m_inputJsonParsers;

	int m_type;

	int m_index;

<span class="nc" id="L37">	public OperatorImportFromJsonCursor(int type, JsonReaderCursor jsonParsers) {</span>
<span class="nc" id="L38">		m_index = -1;</span>
<span class="nc bnc" id="L39" title="All 2 branches missed.">		if (jsonParsers == null)</span>
<span class="nc" id="L40">			throw new IllegalArgumentException();</span>

<span class="nc" id="L42">		m_type = type;</span>
<span class="nc" id="L43">		m_inputJsonParsers = jsonParsers;</span>
<span class="nc" id="L44">	}</span>

	@Override
	public int getGeometryID() {
<span class="nc" id="L48">		return m_index;</span>
	}

	@Override
	public MapGeometry next() {
		JsonReader jsonParser;
<span class="nc bnc" id="L54" title="All 2 branches missed.">		if ((jsonParser = m_inputJsonParsers.next()) != null) {</span>
<span class="nc" id="L55">			m_index = m_inputJsonParsers.getID();</span>
<span class="nc" id="L56">			return importFromJsonParser(m_type, jsonParser);</span>
		}
<span class="nc" id="L58">		return null;</span>
	}

	static MapGeometry importFromJsonParser(int gt, JsonReader parser) {
		MapGeometry mp;

		try {
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">			if (!JSONUtils.isObjectStart(parser))</span>
<span class="nc" id="L66">				return null;</span>

<span class="fc" id="L68">			boolean bFoundSpatial_reference = false;</span>
<span class="fc" id="L69">			boolean bFoundHasZ = false;</span>
<span class="fc" id="L70">			boolean bFoundHasM = false;</span>
<span class="fc" id="L71">			boolean bFoundPolygon = false;</span>
<span class="fc" id="L72">			boolean bFoundPolyline = false;</span>
<span class="fc" id="L73">			boolean bFoundMultiPoint = false;</span>
<span class="fc" id="L74">			boolean bFoundX = false;</span>
<span class="fc" id="L75">			boolean bFoundY = false;</span>
<span class="fc" id="L76">			boolean bFoundZ = false;</span>
<span class="fc" id="L77">			boolean bFoundM = false;</span>
<span class="fc" id="L78">			boolean bFoundXMin = false;</span>
<span class="fc" id="L79">			boolean bFoundYMin = false;</span>
<span class="fc" id="L80">			boolean bFoundXMax = false;</span>
<span class="fc" id="L81">			boolean bFoundYMax = false;</span>
<span class="fc" id="L82">			boolean bFoundZMin = false;</span>
<span class="fc" id="L83">			boolean bFoundZMax = false;</span>
<span class="fc" id="L84">			boolean bFoundMMin = false;</span>
<span class="fc" id="L85">			boolean bFoundMMax = false;</span>
<span class="fc" id="L86">			double x = NumberUtils.NaN();</span>
<span class="fc" id="L87">			double y = NumberUtils.NaN();</span>
<span class="fc" id="L88">			double z = NumberUtils.NaN();</span>
<span class="fc" id="L89">			double m = NumberUtils.NaN();</span>
<span class="fc" id="L90">			double xmin = NumberUtils.NaN();</span>
<span class="fc" id="L91">			double ymin = NumberUtils.NaN();</span>
<span class="fc" id="L92">			double xmax = NumberUtils.NaN();</span>
<span class="fc" id="L93">			double ymax = NumberUtils.NaN();</span>
<span class="fc" id="L94">			double zmin = NumberUtils.NaN();</span>
<span class="fc" id="L95">			double zmax = NumberUtils.NaN();</span>
<span class="fc" id="L96">			double mmin = NumberUtils.NaN();</span>
<span class="fc" id="L97">			double mmax = NumberUtils.NaN();</span>
<span class="fc" id="L98">			boolean bHasZ = false;</span>
<span class="fc" id="L99">			boolean bHasM = false;</span>
<span class="fc" id="L100">			AttributeStreamOfDbl as = (AttributeStreamOfDbl) AttributeStreamBase</span>
<span class="fc" id="L101">					.createDoubleStream(0);</span>
<span class="fc" id="L102">			AttributeStreamOfDbl bs = (AttributeStreamOfDbl) AttributeStreamBase</span>
<span class="fc" id="L103">					.createDoubleStream(0);</span>

<span class="fc" id="L105">			Geometry geometry = null;</span>
<span class="fc" id="L106">			SpatialReference spatial_reference = null;</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">			while (parser.nextToken() != JsonReader.Token.END_OBJECT) {</span>
<span class="fc" id="L109">				String name = parser.currentString();</span>
<span class="fc" id="L110">				parser.nextToken();</span>

<span class="fc bfc" id="L112" title="All 4 branches covered.">				if (!bFoundSpatial_reference &amp;&amp; name.equals(&quot;spatialReference&quot;)) {</span>
<span class="fc" id="L113">					bFoundSpatial_reference = true;</span>

<span class="pc bpc" id="L115" title="1 of 2 branches missed.">					if (parser.currentToken() == JsonReader.Token.START_OBJECT) {</span>
<span class="fc" id="L116">						spatial_reference = SpatialReference.fromJson(parser);</span>
					} else {
<span class="nc bnc" id="L118" title="All 2 branches missed.">						if (parser.currentToken() != JsonReader.Token.VALUE_NULL)</span>
<span class="nc" id="L119">							throw new GeometryException(</span>
									&quot;failed to parse spatial reference: object or null is expected&quot;);
					}
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">				} else if (!bFoundHasZ &amp;&amp; name.equals(&quot;hasZ&quot;)) {</span>
<span class="nc" id="L123">					bFoundHasZ = true;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">					bHasZ = (parser.currentToken() == JsonReader.Token.VALUE_TRUE);</span>
<span class="pc bpc" id="L125" title="2 of 4 branches missed.">				} else if (!bFoundHasM &amp;&amp; name.equals(&quot;hasM&quot;)) {</span>
<span class="nc" id="L126">					bFoundHasM = true;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">					bHasM = (parser.currentToken() == JsonReader.Token.VALUE_TRUE);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">				} else if (!bFoundPolygon</span>
<span class="pc bpc" id="L129" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;rings&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Polygon)) {
<span class="fc" id="L131">					bFoundPolygon = true;</span>
<span class="fc" id="L132">					geometry = importFromJsonMultiPath(true, parser, as, bs);</span>
<span class="fc" id="L133">					continue;</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">				} else if (!bFoundPolyline</span>
<span class="pc bpc" id="L135" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;paths&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Polyline)) {
<span class="fc" id="L137">					bFoundPolyline = true;</span>
<span class="fc" id="L138">					geometry = importFromJsonMultiPath(false, parser, as, bs);</span>
<span class="fc" id="L139">					continue;</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">				} else if (!bFoundMultiPoint</span>
<span class="pc bpc" id="L141" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;points&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.MultiPoint)) {
<span class="fc" id="L143">					bFoundMultiPoint = true;</span>
<span class="fc" id="L144">					geometry = importFromJsonMultiPoint(parser, as, bs);</span>
<span class="fc" id="L145">					continue;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">				} else if (!bFoundX</span>
<span class="pc bpc" id="L147" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;x&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Point)) {
<span class="fc" id="L149">					bFoundX = true;</span>
<span class="fc" id="L150">					x = readDouble(parser);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">				} else if (!bFoundY</span>
<span class="pc bpc" id="L152" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;y&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Point)) {
<span class="fc" id="L154">					bFoundY = true;</span>
<span class="fc" id="L155">					y = readDouble(parser);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">				} else if (!bFoundZ</span>
<span class="pc bpc" id="L157" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;z&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Point)) {
<span class="fc" id="L159">					bFoundZ = true;</span>
<span class="fc" id="L160">					z = readDouble(parser);</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">				} else if (!bFoundM</span>
<span class="pc bpc" id="L162" title="5 of 6 branches missed.">						&amp;&amp; name.equals(&quot;m&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Point)) {
<span class="nc" id="L164">					bFoundM = true;</span>
<span class="nc" id="L165">					m = readDouble(parser);</span>
				}
<span class="fc bfc" id="L167" title="All 2 branches covered.">				if (!bFoundXMin</span>
<span class="pc bpc" id="L168" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;xmin&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<span class="fc" id="L170">					bFoundXMin = true;</span>
<span class="fc" id="L171">					xmin = readDouble(parser);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">				} else if (!bFoundYMin</span>
<span class="pc bpc" id="L173" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;ymin&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<span class="fc" id="L175">					bFoundYMin = true;</span>
<span class="fc" id="L176">					ymin = readDouble(parser);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">				} else if (!bFoundMMin</span>
<span class="pc bpc" id="L178" title="5 of 6 branches missed.">						&amp;&amp; name.equals(&quot;mmin&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<span class="nc" id="L180">					bFoundMMin = true;</span>
<span class="nc" id="L181">					mmin = readDouble(parser);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">				} else if (!bFoundZMin</span>
<span class="pc bpc" id="L183" title="5 of 6 branches missed.">						&amp;&amp; name.equals(&quot;zmin&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<span class="nc" id="L185">					bFoundZMin = true;</span>
<span class="nc" id="L186">					zmin = readDouble(parser);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">				} else if (!bFoundXMax</span>
<span class="pc bpc" id="L188" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;xmax&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<span class="fc" id="L190">					bFoundXMax = true;</span>
<span class="fc" id="L191">					xmax = readDouble(parser);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">				} else if (!bFoundYMax</span>
<span class="pc bpc" id="L193" title="3 of 6 branches missed.">						&amp;&amp; name.equals(&quot;ymax&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<span class="fc" id="L195">					bFoundYMax = true;</span>
<span class="fc" id="L196">					ymax = readDouble(parser);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">				} else if (!bFoundMMax</span>
<span class="pc bpc" id="L198" title="5 of 6 branches missed.">						&amp;&amp; name.equals(&quot;mmax&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<span class="nc" id="L200">					bFoundMMax = true;</span>
<span class="nc" id="L201">					mmax = readDouble(parser);</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">				} else if (!bFoundZMax</span>
<span class="pc bpc" id="L203" title="5 of 6 branches missed.">						&amp;&amp; name.equals(&quot;zmax&quot;)</span>
						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<span class="nc" id="L205">					bFoundZMax = true;</span>
<span class="nc" id="L206">					zmax = readDouble(parser);</span>
				} else {
<span class="fc" id="L208">					windup(parser);</span>
				}
<span class="fc" id="L210">			}</span>

<span class="fc bfc" id="L212" title="All 6 branches covered.">			if (bFoundPolygon || bFoundPolyline || bFoundMultiPoint) {</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">				assert (geometry != null);</span>
<span class="fc" id="L214">				MultiVertexGeometryImpl mvImpl = (MultiVertexGeometryImpl) geometry</span>
<span class="fc" id="L215">						._getImpl();</span>

<span class="fc" id="L217">				AttributeStreamBase zs = null;</span>
<span class="fc" id="L218">				AttributeStreamBase ms = null;</span>

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">				if (bHasZ) {</span>
<span class="nc" id="L221">					geometry.addAttribute(Semantics.Z);</span>
<span class="nc" id="L222">					zs = as;</span>
				}
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">				if (bHasM) {</span>
<span class="nc" id="L225">					geometry.addAttribute(Semantics.M);</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">					ms = !bHasZ ? as : bs;</span>
				}

<span class="pc bpc" id="L229" title="3 of 4 branches missed.">				if (bHasZ &amp;&amp; zs != null) {</span>
<span class="nc" id="L230">					mvImpl.setAttributeStreamRef(Semantics.Z, zs);</span>
				}

<span class="pc bpc" id="L233" title="3 of 4 branches missed.">				if (bHasM &amp;&amp; ms != null) {</span>
<span class="nc" id="L234">					mvImpl.setAttributeStreamRef(Semantics.M, ms);</span>
				}

<span class="fc" id="L237">				mvImpl.notifyModified(DirtyFlags.DirtyAll);</span>
<span class="pc bpc" id="L238" title="3 of 8 branches missed.">			} else if (bFoundX || bFoundY || bFoundY || bFoundZ) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">				if (NumberUtils.isNaN(y))</span>
<span class="fc" id="L240">					x = NumberUtils.NaN();</span>

<span class="fc" id="L242">				Point p = new Point(x, y);</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">				if (bFoundZ)</span>
<span class="fc" id="L245">					p.setZ(z);</span>

<span class="pc bpc" id="L247" title="1 of 2 branches missed.">				if (bFoundM)</span>
<span class="nc" id="L248">					p.setM(m);</span>

<span class="fc" id="L250">				geometry = p;</span>
<span class="pc bpc" id="L251" title="7 of 16 branches missed.">			} else if (bFoundXMin || bFoundYMin || bFoundXMax || bFoundYMax</span>
					|| bFoundZMin || bFoundZMax || bFoundMMin || bFoundMMax) {
<span class="pc bpc" id="L253" title="1 of 4 branches missed.">				if (NumberUtils.isNaN(ymin) || NumberUtils.isNaN(xmax)</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">						|| NumberUtils.isNaN(ymax))</span>
<span class="fc" id="L255">					xmin = NumberUtils.NaN();</span>

<span class="fc" id="L257">				Envelope e = new Envelope(xmin, ymin, xmax, ymax);</span>

<span class="pc bpc" id="L259" title="3 of 4 branches missed.">				if (bFoundZMin &amp;&amp; bFoundZMax)</span>
<span class="nc" id="L260">					e.setInterval(Semantics.Z, 0, zmin, zmax);</span>

<span class="pc bpc" id="L262" title="3 of 4 branches missed.">				if (bFoundMMin &amp;&amp; bFoundMMax)</span>
<span class="nc" id="L263">					e.setInterval(Semantics.M, 0, mmin, mmax);</span>

<span class="fc" id="L265">				geometry = e;</span>
			}

<span class="fc" id="L268">			mp = new MapGeometry(geometry, spatial_reference);</span>

<span class="nc" id="L270">		} catch (Exception e) {</span>
<span class="nc" id="L271">			return null;</span>
<span class="fc" id="L272">		}</span>

<span class="fc" id="L274">		return mp;</span>
	}

	public static MapGeometry fromJsonToUnknown(JsonReader parser)
			throws Exception {

<span class="nc" id="L280">		return importFromJsonParser(Geometry.GeometryType.Unknown, parser);</span>
	}

	public static MapGeometry fromJsonToEnvelope(JsonReader parser)
			throws Exception {
<span class="nc" id="L285">		return importFromJsonParser(Geometry.GeometryType.Envelope, parser);</span>
	}

	public static MapGeometry fromJsonToPoint(JsonReader parser)
			throws Exception {
<span class="nc" id="L290">		return importFromJsonParser(Geometry.GeometryType.Point, parser);</span>
	}

	public static MapGeometry fromJsonToPolygon(JsonReader parser)
			throws Exception {
<span class="nc" id="L295">		return importFromJsonParser(Geometry.GeometryType.Polygon, parser);</span>
	}

	public static MapGeometry fromJsonToPolyline(JsonReader parser)
			throws Exception {
<span class="nc" id="L300">		return importFromJsonParser(Geometry.GeometryType.Polyline, parser);</span>
	}

	public static MapGeometry fromJsonToMultiPoint(JsonReader parser)
			throws Exception {
<span class="nc" id="L305">		return importFromJsonParser(Geometry.GeometryType.MultiPoint, parser);</span>
	}

	private static void windup(JsonReader parser) {
<span class="fc" id="L309">		parser.skipChildren();</span>
<span class="fc" id="L310">	}</span>

	private static double readDouble(JsonReader parser) {
<span class="fc bfc" id="L313" title="All 2 branches covered.">		if (parser.currentToken() == JsonReader.Token.VALUE_NULL</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">				|| parser.currentToken() == JsonReader.Token.VALUE_STRING</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">				&amp;&amp; parser.currentString().equals(&quot;NaN&quot;))</span>
<span class="fc" id="L316">			return NumberUtils.NaN();</span>
		else
<span class="fc" id="L318">			return parser.currentDoubleValue();</span>
	}

	private static Geometry importFromJsonMultiPoint(JsonReader parser,
			AttributeStreamOfDbl as, AttributeStreamOfDbl bs) throws Exception {
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">		if (parser.currentToken() != JsonReader.Token.START_ARRAY)</span>
<span class="nc" id="L324">			throw new GeometryException(</span>
					&quot;failed to parse multipoint: array of vertices is expected&quot;);

<span class="fc" id="L327">		int point_count = 0;</span>
		MultiPoint multipoint;

<span class="fc" id="L330">		multipoint = new MultiPoint();</span>

<span class="fc" id="L332">		AttributeStreamOfDbl position = (AttributeStreamOfDbl) (AttributeStreamBase</span>
<span class="fc" id="L333">				.createDoubleStream(2, 0));</span>

		// At start of rings
		int sz;
<span class="fc" id="L337">		double[] buf = new double[4];</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">		while (parser.nextToken() != JsonReader.Token.END_ARRAY) {</span>
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">			if (parser.currentToken() != JsonReader.Token.START_ARRAY)</span>
<span class="nc" id="L340">				throw new GeometryException(</span>
						&quot;failed to parse multipoint: array is expected, multipoint vertices consist of arrays of cooridinates&quot;);

<span class="fc" id="L343">			sz = 0;</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">			while (parser.nextToken() != JsonReader.Token.END_ARRAY) {</span>
<span class="fc" id="L345">				buf[sz++] = readDouble(parser);</span>
			}

<span class="pc bpc" id="L348" title="1 of 2 branches missed.">			if (sz &lt; 2)</span>
<span class="nc" id="L349">				throw new GeometryException(</span>
						&quot;failed to parse multipoint: each vertex array has to have at least 2 elements&quot;);

<span class="fc bfc" id="L352" title="All 2 branches covered.">			if (position.size() == 2 * point_count) {</span>
<span class="fc" id="L353">				int c = point_count * 3;</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">				if (c % 2 != 0)</span>
<span class="fc" id="L355">					c++;// have to be even</span>
<span class="fc" id="L356">				position.resize(c);</span>
			}

<span class="fc" id="L359">			position.write(2 * point_count, buf[0]);</span>
<span class="fc" id="L360">			position.write(2 * point_count + 1, buf[1]);</span>

<span class="fc bfc" id="L362" title="All 2 branches covered.">			if (as.size() == point_count) {</span>
<span class="fc" id="L363">				int c = (point_count * 3) / 2;</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">				if (c &lt; 4)</span>
<span class="fc" id="L365">					c = 4;</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">				else if (c &lt; 16)</span>
<span class="fc" id="L367">					c = 16;</span>

<span class="fc" id="L369">				as.resize(c);</span>
			}

<span class="fc bfc" id="L372" title="All 2 branches covered.">			if (sz &gt; 2) {</span>
<span class="fc" id="L373">				as.write(point_count, buf[2]);</span>
			} else
<span class="fc" id="L375">				as.write(point_count, NumberUtils.NaN());</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">			if (bs.size() == point_count) {</span>
<span class="fc" id="L378">				int c = (point_count * 3) / 2;</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">				if (c &lt; 4)</span>
<span class="fc" id="L380">					c = 4;</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">				else if (c &lt; 16)</span>
<span class="fc" id="L382">					c = 16;</span>

<span class="fc" id="L384">				bs.resize(c);</span>
			}

<span class="pc bpc" id="L387" title="1 of 2 branches missed.">			if (sz &gt; 3) {</span>
<span class="nc" id="L388">				bs.write(point_count, buf[3]);</span>
			} else
<span class="fc" id="L390">				bs.write(point_count, NumberUtils.NaN());</span>

<span class="fc" id="L392">			point_count++;</span>
		}

<span class="fc bfc" id="L395" title="All 2 branches covered.">		if (point_count != 0) {</span>
<span class="fc" id="L396">			MultiPointImpl mp_impl = (MultiPointImpl) multipoint._getImpl();</span>
<span class="fc" id="L397">			mp_impl.resize(point_count);</span>
<span class="fc" id="L398">			mp_impl.setAttributeStreamRef(Semantics.POSITION, position);</span>
		}
<span class="fc" id="L400">		return multipoint;</span>
	}

	private static Geometry importFromJsonMultiPath(boolean b_polygon,
			JsonReader parser, AttributeStreamOfDbl as, AttributeStreamOfDbl bs)
			throws Exception {
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">		if (parser.currentToken() != JsonReader.Token.START_ARRAY)</span>
<span class="nc" id="L407">			throw new GeometryException(</span>
					&quot;failed to parse multipath: array of array of vertices is expected&quot;);

		MultiPath multipath;

<span class="fc bfc" id="L412" title="All 2 branches covered.">		if (b_polygon)</span>
<span class="fc" id="L413">			multipath = new Polygon();</span>
		else
<span class="fc" id="L415">			multipath = new Polyline();</span>

<span class="fc" id="L417">		AttributeStreamOfInt32 parts = (AttributeStreamOfInt32) AttributeStreamBase</span>
<span class="fc" id="L418">				.createIndexStream(0);</span>
<span class="fc" id="L419">		AttributeStreamOfDbl position = (AttributeStreamOfDbl) AttributeStreamBase</span>
<span class="fc" id="L420">				.createDoubleStream(2, 0);</span>
<span class="fc" id="L421">		AttributeStreamOfInt8 pathFlags = (AttributeStreamOfInt8) AttributeStreamBase</span>
<span class="fc" id="L422">				.createByteStream(0);</span>

		// set up min max variables
<span class="fc" id="L425">		double[] buf = new double[4];</span>
<span class="fc" id="L426">		double[] start = new double[4];</span>

<span class="fc" id="L428">		int point_count = 0;</span>
<span class="fc" id="L429">		int path_count = 0;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">		byte pathFlag = b_polygon ? (byte) PathFlags.enumClosed : 0;</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">		int requiredSize = b_polygon ? 3 : 2;</span>

		// At start of rings
<span class="fc bfc" id="L434" title="All 2 branches covered.">		while (parser.nextToken() != JsonReader.Token.END_ARRAY) {</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">			if (parser.currentToken() != JsonReader.Token.START_ARRAY)</span>
<span class="nc" id="L436">				throw new GeometryException(</span>
						&quot;failed to parse multipath: ring/path array is expected&quot;);

<span class="fc" id="L439">			int pathPointCount = 0;</span>
<span class="fc" id="L440">			boolean b_first = true;</span>
<span class="fc" id="L441">			int sz = 0;</span>
<span class="fc" id="L442">			int szstart = 0;</span>

<span class="fc" id="L444">			parser.nextToken();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">			while (parser.currentToken() != JsonReader.Token.END_ARRAY) {</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">				if (parser.currentToken() != JsonReader.Token.START_ARRAY)</span>
<span class="nc" id="L447">					throw new GeometryException(</span>
							&quot;failed to parse multipath: array is expected, rings/paths vertices consist of arrays of cooridinates&quot;);

<span class="fc" id="L450">				sz = 0;</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">				while (parser.nextToken() != JsonReader.Token.END_ARRAY) {</span>
<span class="fc" id="L452">					buf[sz++] = readDouble(parser);</span>
				}

<span class="pc bpc" id="L455" title="1 of 2 branches missed.">				if (sz &lt; 2)</span>
<span class="nc" id="L456">					throw new GeometryException(</span>
							&quot;failed to parse multipath: each vertex array has to have at least 2 elements&quot;);

<span class="fc" id="L459">				parser.nextToken();</span>

				do {
<span class="fc bfc" id="L462" title="All 2 branches covered.">					if (position.size() == point_count * 2) {</span>
<span class="fc" id="L463">						int c = point_count * 3;</span>

<span class="fc bfc" id="L465" title="All 2 branches covered.">						if (c % 2 != 0)</span>
<span class="fc" id="L466">							c++;// have to be even</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">						if (c &lt; 8)</span>
<span class="fc" id="L468">							c = 8;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">						else if (c &lt; 32)</span>
<span class="fc" id="L470">							c = 32;</span>

<span class="fc" id="L472">						position.resize(c);</span>
					}

<span class="fc" id="L475">					position.write(2 * point_count, buf[0]);</span>
<span class="fc" id="L476">					position.write(2 * point_count + 1, buf[1]);</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">					if (as.size() == point_count) {</span>
<span class="fc" id="L479">						int c = (point_count * 3) / 2;// have to be even</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">						if (c &lt; 4)</span>
<span class="fc" id="L481">							c = 4;</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">						else if (c &lt; 16)</span>
<span class="fc" id="L483">							c = 16;</span>
<span class="fc" id="L484">						as.resize(c);</span>
					}

<span class="fc bfc" id="L487" title="All 2 branches covered.">					if (sz &gt; 2) {</span>
<span class="fc" id="L488">						as.write(point_count, buf[2]);</span>
					} else
<span class="fc" id="L490">						as.write(point_count, NumberUtils.NaN());</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">					if (bs.size() == point_count) {</span>
<span class="fc" id="L493">						int c = (point_count * 3) / 2;// have to be even</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">						if (c &lt; 4)</span>
<span class="fc" id="L495">							c = 4;</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">						else if (c &lt; 16)</span>
<span class="fc" id="L497">							c = 16;</span>
<span class="fc" id="L498">						bs.resize(c);</span>
					}

<span class="fc bfc" id="L501" title="All 2 branches covered.">					if (sz &gt; 3) {</span>
<span class="fc" id="L502">						bs.write(point_count, buf[3]);</span>
					} else
<span class="fc" id="L504">						bs.write(point_count, NumberUtils.NaN());</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">					if (b_first) {</span>
<span class="fc" id="L507">						path_count++;</span>
<span class="fc" id="L508">						parts.add(point_count);</span>
<span class="fc" id="L509">						pathFlags.add(pathFlag);</span>
<span class="fc" id="L510">						b_first = false;</span>
<span class="fc" id="L511">						szstart = sz;</span>
<span class="fc" id="L512">						start[0] = buf[0];</span>
<span class="fc" id="L513">						start[1] = buf[1];</span>
<span class="fc" id="L514">						start[2] = buf[2];</span>
<span class="fc" id="L515">						start[3] = buf[3];</span>
					}
<span class="fc" id="L517">					point_count++;</span>
<span class="fc" id="L518">					pathPointCount++;</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">				} while (pathPointCount &lt; requiredSize</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">						&amp;&amp; parser.currentToken() == JsonReader.Token.END_ARRAY);</span>
			}

<span class="pc bpc" id="L523" title="3 of 14 branches missed.">			if (b_polygon &amp;&amp; pathPointCount &gt; requiredSize &amp;&amp; sz == szstart</span>
					&amp;&amp; start[0] == buf[0] &amp;&amp; start[1] == buf[1]
					&amp;&amp; start[2] == buf[2] &amp;&amp; start[3] == buf[3]) {
				// remove the end point that is equal to the start point.
<span class="fc" id="L527">				point_count--;</span>
<span class="fc" id="L528">				pathPointCount--;</span>
			}

<span class="pc bpc" id="L531" title="1 of 2 branches missed.">			if (pathPointCount == 0)</span>
<span class="nc" id="L532">				continue;// skip empty paths</span>
<span class="fc" id="L533">		}</span>

<span class="fc bfc" id="L535" title="All 2 branches covered.">		if (point_count != 0) {</span>
<span class="fc" id="L536">			parts.resize(path_count);</span>
<span class="fc" id="L537">			pathFlags.resize(path_count);</span>

<span class="pc bpc" id="L539" title="1 of 2 branches missed.">			if (point_count &gt; 0) {</span>
<span class="fc" id="L540">				parts.add(point_count);</span>
<span class="fc" id="L541">				pathFlags.add((byte) 0);</span>
			}

<span class="fc" id="L544">			MultiPathImpl mp_impl = (MultiPathImpl) multipath._getImpl();</span>
<span class="fc" id="L545">			mp_impl.setAttributeStreamRef(Semantics.POSITION, position);</span>
<span class="fc" id="L546">			mp_impl.setPathFlagsStreamRef(pathFlags);</span>
<span class="fc" id="L547">			mp_impl.setPathStreamRef(parts);</span>
		}
<span class="fc" id="L549">		return multipath;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>