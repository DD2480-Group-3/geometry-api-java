<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConstructOffset.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">ConstructOffset.java</span></div><h1>ConstructOffset.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2015 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */
package com.esri.core.geometry;

import java.util.ArrayList;

// Note: m_distance&lt;0 offsets to the left, m_distance&gt;0 offsets to the right

class ConstructOffset {
	ProgressTracker m_progressTracker;
	Geometry m_inputGeometry;
	double m_distance;
	double m_tolerance;
	OperatorOffset.JoinType m_joins;
	double m_miterLimit;

	// multipath offset
	static class GraphicPoint {
		double x, y;
		int m_next, m_prev;
		double m;
		int type;

<span class="fc" id="L45">		GraphicPoint(double x_, double y_) {</span>
<span class="fc" id="L46">			x = x_;</span>
<span class="fc" id="L47">			y = y_;</span>
<span class="fc" id="L48">			type = 0;</span>
<span class="fc" id="L49">			m = 0;</span>
<span class="fc" id="L50">		}</span>

<span class="fc" id="L52">		GraphicPoint(Point2D r) {</span>
<span class="fc" id="L53">			x = r.x;</span>
<span class="fc" id="L54">			y = r.y;</span>
<span class="fc" id="L55">			type = 0;</span>
<span class="fc" id="L56">			m = 0;</span>
<span class="fc" id="L57">		}</span>

<span class="fc" id="L59">		GraphicPoint(GraphicPoint pt) {</span>
<span class="fc" id="L60">			x = pt.x;</span>
<span class="fc" id="L61">			y = pt.y;</span>
<span class="fc" id="L62">			type = pt.type;</span>
<span class="fc" id="L63">			m = pt.m;</span>
<span class="fc" id="L64">		}</span>

<span class="fc" id="L66">		GraphicPoint(GraphicPoint srcPt, double d, double angle) {</span>
<span class="fc" id="L67">			x = srcPt.x + d * Math.cos(angle);</span>
<span class="fc" id="L68">			y = srcPt.y + d * Math.sin(angle);</span>
<span class="fc" id="L69">			type = srcPt.type;</span>
<span class="fc" id="L70">			m = srcPt.m;</span>
<span class="fc" id="L71">		}</span>

<span class="nc" id="L73">		GraphicPoint(GraphicPoint pt1, GraphicPoint pt2) {</span>
<span class="nc" id="L74">			x = (pt1.x + pt2.x) * 0.5;</span>
<span class="nc" id="L75">			y = (pt1.y + pt2.y) * 0.5;</span>
<span class="nc" id="L76">			type = pt1.type;</span>
<span class="nc" id="L77">			m = pt1.m;</span>
<span class="nc" id="L78">		}</span>

<span class="fc" id="L80">		GraphicPoint(GraphicPoint pt1, GraphicPoint pt2, double ratio) {</span>
<span class="fc" id="L81">			x = pt1.x + (pt2.x - pt1.x) * ratio;</span>
<span class="fc" id="L82">			y = pt1.y + (pt2.y - pt1.y) * ratio;</span>
<span class="fc" id="L83">			type = pt1.type;</span>
<span class="fc" id="L84">			m = pt1.m;</span>
<span class="fc" id="L85">		}</span>

	};

<span class="nc" id="L89">	static class GraphicRect {</span>
		double x1, x2, y1, y2;
	};

<span class="fc" id="L93">	static class IntersectionInfo {</span>
		GraphicPoint pt;
		double rFirst;
		double rSecond;
		boolean atExistingPt;
	};

	ArrayList&lt;GraphicPoint&gt; m_srcPts;
	int m_srcPtCount;
	ArrayList&lt;GraphicPoint&gt; m_offsetPts;
	int m_offsetPtCount;

	MultiPath m_resultPath;
	int m_resultPoints;
	double m_a1, m_a2;
	boolean m_bBadSegs;

<span class="fc" id="L110">	ConstructOffset(ProgressTracker progressTracker) {</span>
<span class="fc" id="L111">		m_progressTracker = progressTracker;</span>
<span class="fc" id="L112">	}</span>

	// static
	static Geometry execute(Geometry inputGeometry, double distance,
			OperatorOffset.JoinType joins, double miterLimit, double tolerance,
			ProgressTracker progressTracker) {
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">		if (inputGeometry == null)</span>
<span class="nc" id="L119">			throw new IllegalArgumentException();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">		if (inputGeometry.getDimension() &lt; 1)// can offset Polygons and</span>
												// Polylines only
<span class="fc" id="L122">			throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">		if (distance == 0 || inputGeometry.isEmpty())</span>
<span class="fc" id="L124">			return inputGeometry;</span>
<span class="fc" id="L125">		ConstructOffset offset = new ConstructOffset(progressTracker);</span>
<span class="fc" id="L126">		offset.m_inputGeometry = inputGeometry;</span>
<span class="fc" id="L127">		offset.m_distance = distance;</span>
<span class="fc" id="L128">		offset.m_tolerance = tolerance;</span>
<span class="fc" id="L129">		offset.m_joins = joins;</span>
<span class="fc" id="L130">		offset.m_miterLimit = miterLimit;</span>
<span class="fc" id="L131">		return offset._ConstructOffset();</span>
	}

	Geometry _OffsetLine() {
<span class="nc" id="L135">		Line line = (Line) m_inputGeometry;</span>
<span class="nc" id="L136">		Point2D start = line.getStartXY();</span>
<span class="nc" id="L137">		Point2D end = line.getEndXY();</span>
<span class="nc" id="L138">		Point2D v = new Point2D();</span>
<span class="nc" id="L139">		v.sub(end, start);</span>
<span class="nc" id="L140">		v.normalize();</span>
<span class="nc" id="L141">		v.leftPerpendicular();</span>
<span class="nc" id="L142">		v.scale(m_distance);</span>
<span class="nc" id="L143">		start.add(v);</span>
<span class="nc" id="L144">		end.add(v);</span>
<span class="nc" id="L145">		Line resLine = (Line) line.createInstance();</span>
<span class="nc" id="L146">		line.setStartXY(start);</span>
<span class="nc" id="L147">		line.setEndXY(end);</span>
<span class="nc" id="L148">		return resLine;</span>
	}

	Geometry _OffsetEnvelope() {
<span class="nc" id="L152">		Envelope envelope = (Envelope) m_inputGeometry;</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">		if ((m_distance &gt; 0) &amp;&amp; (m_joins != OperatorOffset.JoinType.Miter)) {</span>
<span class="nc" id="L154">			Polygon poly = new Polygon();</span>
<span class="nc" id="L155">			poly.addEnvelope(envelope, false);</span>
<span class="nc" id="L156">			m_inputGeometry = poly;</span>
<span class="nc" id="L157">			return _ConstructOffset();</span>
		}

<span class="nc" id="L160">		Envelope resEnv = new Envelope(envelope.m_envelope);</span>
<span class="nc" id="L161">		resEnv.inflate(m_distance, m_distance);</span>
<span class="nc" id="L162">		return resEnv;</span>
	}

<span class="fc" id="L165">	private final double pi = Math.PI;// GEOMETRYX_PI;</span>
<span class="fc" id="L166">	private final double two_pi = Math.PI * 2;// GEOMETRYX_2PI;</span>
<span class="fc" id="L167">	private final double half_pi = Math.PI / 2;// GEOMETRYX_HalfPI;</span>
<span class="fc" id="L168">	private final double sqrt2 = 1.4142135623730950488016887242097;</span>
<span class="fc" id="L169">	private final double oneDegree = 0.01745329251994329576923690768489;</span>

<span class="fc" id="L171">	private final int BAD_SEG = 0x0100;</span>
<span class="fc" id="L172">	private final int IS_END = 0x0200;</span>
<span class="fc" id="L173">	private final int CLOSING_SEG = 0x0400;</span>

	void addPoint(GraphicPoint pt) {
<span class="fc" id="L176">		m_offsetPts.add(pt);</span>
<span class="fc" id="L177">		m_offsetPtCount++;</span>
<span class="fc" id="L178">	}</span>

	double scal(GraphicPoint pt1, GraphicPoint pt2, GraphicPoint pt3,
			GraphicPoint pt4) {
<span class="fc" id="L182">		return (pt2.x - pt1.x) * (pt4.x - pt3.x) + (pt2.y - pt1.y)</span>
				* (pt4.y - pt3.y);
	}

	// offPt is the point to add.
	// this point corresponds to the offset version of the end of seg1.
	// it could generate a segment going in the opposite direction of the
	// original segment
	// this situation is handled here by adding an additional &quot;bad&quot; segment
	void addPoint(GraphicPoint offPt, int i_src) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">		if (m_offsetPtCount == 0) // TODO: can we have this outside of this</span>
									// method?
		{
<span class="fc" id="L195">			addPoint(offPt);</span>
<span class="fc" id="L196">			return;</span>
		}

<span class="fc" id="L199">		int n_src = m_srcPtCount;</span>
		GraphicPoint pt1, pt;
<span class="fc bfc" id="L201" title="All 2 branches covered.">		pt1 = m_srcPts.get(i_src == 0 ? n_src - 1 : i_src - 1);</span>
<span class="fc" id="L202">		pt = m_srcPts.get(i_src);</span>

		// calculate scalar product to determine if the offset segment goes in
		// the same/opposite direction compared to the original one
<span class="fc" id="L206">		double s = scal(pt1, pt, m_offsetPts.get(m_offsetPtCount - 1), offPt);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">		if (s &gt; 0)</span>
		// original segment and offset segment go in the same direction. Just
		// add the point
		{
<span class="fc" id="L211">			addPoint(offPt);</span>
<span class="fc" id="L212">			return;</span>
		}

<span class="pc bpc" id="L215" title="1 of 2 branches missed.">		if (s &lt; 0) {</span>
			// we will add a loop. We need to make sure the points we introduce
			// don't generate a &quot;reversed&quot; segment
			// let's project the first point of the reversed segment
			// (m_offsetPts + m_offsetPtCount - 1) to check
			// if it falls on the good side of the original segment (scalar
			// product sign again)
<span class="fc bfc" id="L222" title="All 2 branches covered.">			if (scal(pt1, pt, pt, m_offsetPts.get(m_offsetPtCount - 1)) &gt; 0) {</span>
				GraphicPoint p;

				// change value of m_offsetPts + m_offsetPtCount - 1
				int k;
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">				if (i_src == 0)</span>
<span class="nc" id="L228">					k = n_src - 2;</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">				else if (i_src == 1)</span>
<span class="nc" id="L230">					k = n_src - 1;</span>
				else
<span class="fc" id="L232">					k = i_src - 2;</span>
<span class="fc" id="L233">				GraphicPoint pt0 = m_srcPts.get(k);</span>

<span class="fc" id="L235">				double a = Math.atan2(pt1.y - pt0.y, pt1.x - pt0.x);</span>
<span class="fc" id="L236">				p = new GraphicPoint(pt1, m_distance, a - half_pi);</span>
<span class="fc" id="L237">				m_offsetPts.set(m_offsetPtCount - 1, p);</span>

<span class="pc bpc" id="L239" title="2 of 4 branches missed.">				if (m_joins == OperatorOffset.JoinType.Bevel</span>
						|| m_joins == OperatorOffset.JoinType.Miter) {
					// this block is added as well as the commented BAD_SEG in
					// the next block
<span class="nc" id="L243">					p = new GraphicPoint(p, pt1);</span>
<span class="nc" id="L244">					addPoint(p);</span>

					// &quot;bad&quot; segment
<span class="nc" id="L247">					p = new GraphicPoint(pt1, m_distance, m_a1 + half_pi);</span>

<span class="nc" id="L249">					GraphicPoint p_ = new GraphicPoint(p, pt1);</span>
<span class="nc" id="L250">					p_.type |= BAD_SEG;</span>
<span class="nc" id="L251">					addPoint(p_);</span>

<span class="nc" id="L253">					addPoint(p);</span>
<span class="nc" id="L254">				} else {</span>
					// the working stuff for round and square

					// &quot;bad&quot; segment
<span class="fc" id="L258">					p = new GraphicPoint(pt1, m_distance, m_a1 + half_pi);</span>
<span class="fc" id="L259">					p.type |= BAD_SEG;</span>
<span class="fc" id="L260">					addPoint(p);</span>
				}

				// add offPt
<span class="fc" id="L264">				addPoint(offPt, i_src);</span>
<span class="fc" id="L265">			} else {</span>
				GraphicPoint p;

				// we don't add offPt but the loop containing the &quot;bad&quot; segment
<span class="fc" id="L269">				p = new GraphicPoint(pt, m_distance, m_a1 + half_pi);</span>
<span class="fc" id="L270">				addPoint(p);</span>

<span class="pc bpc" id="L272" title="2 of 4 branches missed.">				if (m_joins == OperatorOffset.JoinType.Bevel</span>
						|| m_joins == OperatorOffset.JoinType.Miter) {
					// this block is added as well as the commented BAD_SEG in
					// the next block
<span class="nc" id="L276">					p = new GraphicPoint(p, pt);</span>
<span class="nc" id="L277">					addPoint(p);</span>

<span class="nc" id="L279">					p = new GraphicPoint(pt, m_distance, m_a2 - half_pi);</span>
<span class="nc" id="L280">					GraphicPoint p_ = new GraphicPoint(p, pt);</span>
<span class="nc" id="L281">					p_.type |= BAD_SEG;</span>
<span class="nc" id="L282">					addPoint(p_);</span>

<span class="nc" id="L284">					addPoint(p);</span>
<span class="nc" id="L285">				} else {</span>
					// the working stuff for round and square
<span class="fc" id="L287">					p = new GraphicPoint(pt, m_distance, m_a2 - half_pi);</span>
<span class="fc" id="L288">					p.type |= BAD_SEG;</span>
<span class="fc" id="L289">					addPoint(p);</span>
				}
			}
		}
<span class="fc" id="L293">	}</span>

	boolean buildOffset() {
		// make sure we have at least three points and no identical points
		int i;
		double a1, a2;
		GraphicPoint pt, pt1, pt2;
		GraphicPoint p;

		// number of points to deal with
<span class="fc" id="L303">		int n = m_srcPtCount;</span>

<span class="fc" id="L305">		m_offsetPtCount = 0;</span>

<span class="fc" id="L307">		double flattenTolerance = m_tolerance * 0.5;</span>

<span class="fc" id="L309">		double a1_0 = 0;</span>
<span class="fc" id="L310">		double a2_0 = 0;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">		for (i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L312">			pt = m_srcPts.get(i);</span>

			// point before
<span class="fc bfc" id="L315" title="All 2 branches covered.">			if (i == 0)</span>
<span class="fc" id="L316">				pt1 = m_srcPts.get(n - 1);</span>
			else
<span class="fc" id="L318">				pt1 = m_srcPts.get(i - 1);</span>

			// point after
<span class="fc bfc" id="L321" title="All 2 branches covered.">			if (i == n - 1)</span>
<span class="fc" id="L322">				pt2 = m_srcPts.get(0);</span>
			else
<span class="fc" id="L324">				pt2 = m_srcPts.get(i + 1);</span>

			// angles of enclosing segments
<span class="fc" id="L327">			double dx1 = pt1.x - pt.x;</span>
<span class="fc" id="L328">			double dy1 = pt1.y - pt.y;</span>
<span class="fc" id="L329">			double dx2 = pt2.x - pt.x;</span>
<span class="fc" id="L330">			double dy2 = pt2.y - pt.y;</span>
<span class="fc" id="L331">			a1 = Math.atan2(dy1, dx1);</span>
<span class="fc" id="L332">			a2 = Math.atan2(dy2, dx2);</span>
<span class="fc" id="L333">			m_a1 = a1;</span>
<span class="fc" id="L334">			m_a2 = a2;</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">			if (i == 0) {</span>
<span class="fc" id="L336">				a1_0 = a1;</span>
<span class="fc" id="L337">				a2_0 = a2;</span>
			}

			// double dot_product = dx1 * dx2 + dy1 * dy2;
<span class="fc" id="L341">			double cross_product = dx1 * dy2 - dx2 * dy1;</span>
			// boolean bInnerAngle = (cross_product == 0) ? (m_distance &gt; 0) :
			// (cross_product * m_distance &gt;= 0.0);

			// check for inner angles (always managed the same, whatever the
			// type of join)
<span class="fc" id="L347">			double saved_a2 = a2;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">			if (a2 &lt; a1)</span>
<span class="fc" id="L349">				a2 += two_pi; // this guaranties that (a1 + a2) / 2 is on the</span>
								// right side of the curve
<span class="fc bfc" id="L351" title="All 2 branches covered.">			if (cross_product * m_distance &gt; 0.0) // inner angle</span>
			{
				// inner angle
<span class="fc bfc" id="L354" title="All 4 branches covered.">				if (m_joins == OperatorOffset.JoinType.Bevel</span>
						|| m_joins == OperatorOffset.JoinType.Miter) {
<span class="fc" id="L356">					p = new GraphicPoint(pt, m_distance, a1 + half_pi);</span>
<span class="fc" id="L357">					addPoint(p);</span>

					// this block is added as well as the commented BAD_SEG in
					// the next block
<span class="fc" id="L361">					double ratio = 0.001; // TODO: the higher the ratio, the</span>
											// better the result (shorter
											// segments)
<span class="fc" id="L364">					p = new GraphicPoint(pt, p, ratio);</span>
<span class="fc" id="L365">					addPoint(p);</span>

					// this is the &quot;bad&quot; segment
<span class="fc" id="L368">					p = new GraphicPoint(pt, m_distance, a2 - half_pi);</span>

<span class="fc" id="L370">					GraphicPoint p_ = new GraphicPoint(pt, p, ratio);</span>
<span class="fc" id="L371">					p_.type |= BAD_SEG;</span>
<span class="fc" id="L372">					addPoint(p_);</span>

<span class="fc" id="L374">					addPoint(p);</span>
<span class="fc" id="L375">				} else {</span>
					// this method works for square and round, but not bevel
<span class="fc" id="L377">					double r = (a2 - a1) * 0.5;</span>
<span class="fc" id="L378">					double d = m_distance / Math.abs(Math.sin(r));</span>
<span class="fc" id="L379">					p = new GraphicPoint(pt, d, (a1 + a2) * 0.5);</span>
<span class="fc" id="L380">					addPoint(p, i); // will deal with reversed segments</span>
				}
<span class="fc" id="L382">				continue;</span>
			}

			// outer angles
			// check if we have an end point first
<span class="fc bfc" id="L387" title="All 2 branches covered.">			if ((pt.type &amp; IS_END) != 0) {</span>
				// TODO: deal with other options. assume rounded and
				// perpendicular for now
				// we need to use the outer regular polygon of the round join
				// TODO: explain this in a doc

				// calculate the number of points based on a flatten tolerance
<span class="fc" id="L394">				double r = 1.0 - flattenTolerance / Math.abs(m_distance);</span>
<span class="fc" id="L395">				long na = 1;</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">				double da = (m_distance &lt; 0) ? -pi : pi; // da is negative when</span>
															// m_offset is
															// negative (???)
<span class="pc bpc" id="L399" title="2 of 4 branches missed.">				if (r &gt; -1.0 &amp;&amp; r &lt; 1.0) {</span>
<span class="fc" id="L400">					double a = Math.acos(r) * 2; // angle where &quot;arrow?&quot; is less</span>
													// than flattenTolerance
					// do not consider an angle smaller than a degree
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">					if (a &lt; oneDegree)</span>
<span class="fc" id="L404">						a = oneDegree;</span>
<span class="fc" id="L405">					na = (long) (pi / a + 1.5);</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">					if (na &gt; 1)</span>
<span class="fc" id="L407">						da /= na;</span>
				}
				// add first point
<span class="fc" id="L410">				double a = a1 + half_pi;</span>
<span class="fc" id="L411">				p = new GraphicPoint(pt, m_distance, a);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">				if (i == 0)</span>
<span class="fc" id="L413">					p.type |= CLOSING_SEG; // TODO: should we simplify this by</span>
											// considering the last point
											// instead of the first one??
<span class="fc" id="L416">				addPoint(p, i); // will deal with reversed segments</span>

<span class="fc" id="L418">				double d = m_distance / Math.cos(da / 2);</span>
<span class="fc" id="L419">				a += da / 2;</span>
<span class="fc" id="L420">				p = new GraphicPoint(pt, d, a);</span>
<span class="fc" id="L421">				p.type |= CLOSING_SEG;</span>
<span class="fc" id="L422">				addPoint(p);</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">				while (--na &gt; 0) {</span>
<span class="fc" id="L425">					a += da;</span>
<span class="fc" id="L426">					p = new GraphicPoint(pt, d, a);</span>
<span class="fc" id="L427">					p.type |= CLOSING_SEG;</span>
<span class="fc" id="L428">					addPoint(p);</span>
				}

				// last point (optional except for the first point)
<span class="fc" id="L432">				p = new GraphicPoint(pt, m_distance, a2 - half_pi); // this one</span>
																	// is
																	// optional
																	// except
																	// for the
																	// first
																	// point
<span class="fc" id="L439">				p.type |= CLOSING_SEG;</span>
<span class="fc" id="L440">				addPoint(p);</span>

<span class="fc" id="L442">				continue;</span>
			}

<span class="fc bfc" id="L445" title="All 2 branches covered.">			else if (m_joins == OperatorOffset.JoinType.Bevel) // bevel</span>
			{
<span class="fc" id="L447">				p = new GraphicPoint(pt, m_distance, a1 + half_pi);</span>
<span class="fc" id="L448">				addPoint(p, i); // will deal with reversed segments</span>
<span class="fc" id="L449">				p = new GraphicPoint(pt, m_distance, a2 - half_pi);</span>
<span class="fc" id="L450">				addPoint(p);</span>
<span class="fc" id="L451">				continue;</span>
			}

<span class="fc bfc" id="L454" title="All 2 branches covered.">			else if (m_joins == OperatorOffset.JoinType.Round) {</span>
				// we need to use the outer regular polygon of the round join
				// TODO: explain this in a doc

				// calculate the number of points based on a flatten tolerance
<span class="fc" id="L459">				double r = 1.0 - flattenTolerance / Math.abs(m_distance);</span>
<span class="fc" id="L460">				long na = 1;</span>
<span class="fc" id="L461">				double da = (a2 - half_pi) - (a1 + half_pi); // da is negative</span>
																// when
																// m_distance is
																// negative
<span class="pc bpc" id="L465" title="2 of 4 branches missed.">				if (r &gt; -1.0 &amp;&amp; r &lt; 1.0) {</span>
<span class="fc" id="L466">					double a = Math.acos(r) * 2.0; // angle where &quot;arrow?&quot; is</span>
													// less than
													// flattenTolerance
					// do not consider an angle smaller than a degree
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">					if (a &lt; oneDegree)</span>
<span class="fc" id="L471">						a = oneDegree;</span>
<span class="fc" id="L472">					na = (long) (Math.abs(da) / a + 1.5);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">					if (na &gt; 1)</span>
<span class="fc" id="L474">						da /= na;</span>
				}
<span class="fc" id="L476">				double d = m_distance / Math.cos(da * 0.5);</span>
<span class="fc" id="L477">				double a = a1 + half_pi + da * 0.5;</span>
<span class="fc" id="L478">				p = new GraphicPoint(pt, d, a);</span>
<span class="fc" id="L479">				addPoint(p, i); // will deal with reversed segments</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">				while (--na &gt; 0) {</span>
<span class="fc" id="L481">					a += da;</span>
<span class="fc" id="L482">					p = new GraphicPoint(pt, d, a);</span>
<span class="fc" id="L483">					addPoint(p);</span>
				}
				continue;
<span class="fc bfc" id="L486" title="All 2 branches covered.">			} else if (m_joins == OperatorOffset.JoinType.Miter) {</span>
<span class="fc" id="L487">				dx1 = pt1.x - pt.x;</span>
<span class="fc" id="L488">				dy1 = pt1.y - pt.y;</span>
<span class="fc" id="L489">				dx2 = pt2.x - pt.x;</span>
<span class="fc" id="L490">				dy2 = pt2.y - pt.y;</span>
<span class="fc" id="L491">				double d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);</span>
<span class="fc" id="L492">				double d2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);</span>
<span class="fc" id="L493">				double cosa = (dx1 * dx2 + dy1 * dy2) / d1 / d2;</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">				if (cosa &gt; 1.0 - 1.0e-8) {</span>
					// there's a spike in the polygon boundary; this could
					// happen when filtering out short segments in Init()
<span class="nc" id="L497">					p = new GraphicPoint(pt, sqrt2 * m_distance, a2 - pi * 0.25);</span>
<span class="nc" id="L498">					addPoint(p, i);</span>
<span class="nc" id="L499">					p = new GraphicPoint(pt, sqrt2 * m_distance, a2 + pi * 0.25);</span>
<span class="nc" id="L500">					addPoint(p);</span>
<span class="nc" id="L501">					continue;</span>
				}
				// original miter code
				// if (m_miterLimit * m_miterLimit * (1 - cosa) &lt; 2)
				// {
				// // bevel join
				// p = new GraphicPoint(pt, m_distance, a1 + half_pi);
				// AddPoint(p, src_poly, srcPtCount, i); // will deal with
				// reversed segments
				// p = new GraphicPoint(pt, m_distance, a2 - half_pi);
				// AddPoint(p);
				// continue;
				// }
<span class="fc" id="L514">				double distanceFromCorner = Math.abs(m_distance</span>
<span class="fc" id="L515">						/ Math.sin(Math.acos(cosa) * 0.5));</span>
<span class="fc" id="L516">				double bevelDistance = Math.abs(m_miterLimit * m_distance);</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">				if (distanceFromCorner &gt; bevelDistance) {</span>
<span class="nc" id="L518">					double r = (a2 - a1) * 0.5;</span>
<span class="nc" id="L519">					double d = m_distance / Math.abs(Math.sin(r));</span>
<span class="nc" id="L520">					p = new GraphicPoint(pt, d, (a1 + a2) * 0.5);</span>

					// construct bevel points, see comment in
					// c:\ArcGIS\System\Geometry\Geometry\ConstructCurveImpl.cpp,
					// ESRI::OffsetCurve::EstimateBevelPoints
<span class="nc" id="L525">					Point2D corner = new Point2D(p.x, p.y);</span>
<span class="nc" id="L526">					Point2D through = new Point2D(pt.x, pt.y);</span>
<span class="nc" id="L527">					Point2D delta = new Point2D();</span>
<span class="nc" id="L528">					delta.sub(corner, through);</span>

					// Point2D midPoint = through + delta * (bevelDistance /
					// delta.Length());
<span class="nc" id="L532">					Point2D midPoint = new Point2D();</span>
<span class="nc" id="L533">					midPoint.scaleAdd(bevelDistance / delta.length(), delta,</span>
							through);

<span class="nc" id="L536">					double sideLength = Math.sqrt(distanceFromCorner</span>
<span class="nc" id="L537">							* distanceFromCorner - m_distance * m_distance), halfWidth = (distanceFromCorner - bevelDistance)</span>
<span class="nc" id="L538">							* Math.abs(m_distance) / sideLength;</span>

					// delta = delta.RotateDirect(0.0, m_distance &gt; 0.0 ? -1.0 :
					// 1.0) * (halfWidth/delta.Length());
<span class="nc bnc" id="L542" title="All 2 branches missed.">					if (m_distance &gt; 0.0)</span>
<span class="nc" id="L543">						delta.leftPerpendicular();</span>
					else
<span class="nc" id="L545">						delta.rightPerpendicular();</span>
<span class="nc" id="L546">					delta.scale(halfWidth / delta.length());</span>

<span class="nc" id="L548">					Point2D from = new Point2D();</span>
<span class="nc" id="L549">					from.add(midPoint, delta);</span>
<span class="nc" id="L550">					Point2D to = new Point2D();</span>
<span class="nc" id="L551">					to.sub(midPoint, delta);</span>
<span class="nc" id="L552">					p = new GraphicPoint(from);</span>
					// _ASSERT(::_finite(p.x));
					// _ASSERT(::_finite(p.y));
<span class="nc" id="L555">					addPoint(p, i);</span>
<span class="nc" id="L556">					p = new GraphicPoint(to);</span>
					// _ASSERT(::_finite(p.x));
					// _ASSERT(::_finite(p.y));
<span class="nc" id="L559">					addPoint(p);</span>
<span class="nc" id="L560">					continue;</span>
				}
				// miter join
<span class="fc" id="L563">				double r = (a2 - a1) * 0.5;</span>
<span class="fc" id="L564">				double d = m_distance / Math.abs(Math.sin(r)); // r should not</span>
																// be null
																// (trapped by
																// the bevel
																// case)
<span class="fc" id="L569">				p = new GraphicPoint(pt, d, (a1 + a2) * 0.5);</span>
<span class="fc" id="L570">				addPoint(p, i); // will deal with reversed segments</span>
<span class="fc" id="L571">				continue;</span>
			} else // the new &quot;square&quot; join
			{
<span class="fc" id="L574">				a2 = saved_a2;</span>

				// identify if angle is less than pi/2
				// in this case, we introduce a segment that is perpendicular to
				// the bissector of the angle
				// TODO: see figure X for details
				boolean bAddSegment;
<span class="fc bfc" id="L581" title="All 2 branches covered.">				if (m_distance &gt; 0.0) {</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">					if (a2 &gt; a1) // &gt; and not &gt;=</span>
<span class="fc" id="L583">						a2 -= two_pi;</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">					bAddSegment = (a1 - a2 &lt; half_pi);</span>
				} else {
<span class="fc bfc" id="L586" title="All 2 branches covered.">					if (a2 &lt; a1) // &lt; and not &lt;=</span>
<span class="fc" id="L587">						a2 += two_pi;</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">					bAddSegment = (a2 - a1 &lt; half_pi);</span>
				}
<span class="fc bfc" id="L590" title="All 2 branches covered.">				if (bAddSegment) {</span>
					// make it continuous when angle is pi/2 (but not tangent to
					// the round join)
<span class="fc" id="L593">					double d = m_distance * sqrt2;</span>
					double a;

<span class="pc bpc" id="L596" title="1 of 2 branches missed.">					if (d &lt; 0.0)</span>
<span class="fc" id="L597">						a = a1 + pi * 0.25;</span>
					else
<span class="nc" id="L599">						a = a1 + 3.0 * pi * 0.25;</span>
<span class="fc" id="L600">					p = new GraphicPoint(pt, d, a);</span>
<span class="fc" id="L601">					addPoint(p, i);</span>

<span class="pc bpc" id="L603" title="1 of 2 branches missed.">					if (d &lt; 0)</span>
<span class="fc" id="L604">						a = a2 - pi * 0.25;</span>
					else
<span class="nc" id="L606">						a = a2 - 3.0 * pi * 0.25;</span>
<span class="fc" id="L607">					p = new GraphicPoint(pt, d, a);</span>
<span class="fc" id="L608">					addPoint(p);</span>
<span class="fc" id="L609">				} else // standard case: we just add the intersection point of</span>
						// offset segments
				{
<span class="fc" id="L612">					double r = (a2 - a1) * 0.5;</span>
<span class="fc" id="L613">					double d = m_distance / Math.abs(Math.sin(r));</span>
<span class="fc bfc" id="L614" title="All 2 branches covered.">					if (a2 &lt; a1)</span>
<span class="fc" id="L615">						a2 += two_pi; // this guaranties that (a1 + a2) / 2 is</span>
										// on the right side with a positive
										// offset
<span class="fc" id="L618">					p = new GraphicPoint(pt, d, (a1 + a2) / 2);</span>
<span class="fc" id="L619">					addPoint(p, i);</span>
				}
			}
		}

		// closing point
<span class="fc" id="L625">		m_a1 = a1_0;</span>
<span class="fc" id="L626">		m_a2 = a2_0;</span>
<span class="fc" id="L627">		addPoint(m_offsetPts.get(0), 0);</span>

		// make sure the first point matches the last (in case a problem of
		// reversed segment happens there)
<span class="fc" id="L631">		pt = new GraphicPoint(m_offsetPts.get(m_offsetPtCount - 1));</span>
<span class="fc" id="L632">		m_offsetPts.set(0, pt);</span>

		// remove loops
<span class="fc" id="L635">		return removeBadSegsFast();</span>
	}

	void addPart(int iStart, int cPts) {
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">		if (cPts &lt; 2)</span>
<span class="nc" id="L640">			return;</span>

<span class="fc bfc" id="L642" title="All 2 branches covered.">		for (int i = 0; i &lt; cPts; i++) {</span>
<span class="fc" id="L643">			GraphicPoint pt = m_offsetPts.get(iStart + i);</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">			if (i != 0)</span>
<span class="fc" id="L645">				m_resultPath.lineTo(new Point2D(pt.x, pt.y));</span>
			else
<span class="fc" id="L647">				m_resultPath.startPath(new Point2D(pt.x, pt.y));</span>
		}
<span class="fc" id="L649">	}</span>

	void _OffsetPath(MultiPath multiPath, int pathIndex, MultiPath resultingPath) {
<span class="fc" id="L652">		int startVertex = multiPath.getPathStart(pathIndex);</span>
<span class="fc" id="L653">		int endVertex = multiPath.getPathEnd(pathIndex);</span>

<span class="fc" id="L655">		m_offsetPts = new ArrayList&lt;GraphicPoint&gt;();</span>

		// test if part is closed
<span class="fc" id="L658">		m_resultPath = resultingPath;</span>
<span class="fc" id="L659">		m_resultPoints = 0;</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">		if (multiPath.isClosedPath(pathIndex)) {</span>
			// check if last point is a duplicate of first
<span class="fc" id="L662">			Point2D ptStart = multiPath.getXY(startVertex);</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">			while (multiPath.getXY(endVertex - 1).isEqual(ptStart))</span>
<span class="nc" id="L664">				endVertex--;</span>

			// we need at least three points for a polygon
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">			if (endVertex - startVertex &gt;= 2) {</span>
<span class="fc" id="L668">				m_srcPtCount = endVertex - startVertex;</span>
<span class="fc" id="L669">				m_srcPts = new ArrayList&lt;GraphicPoint&gt;(m_srcPtCount);</span>
				// TODO: may throw std::bad:alloc()
<span class="fc bfc" id="L671" title="All 2 branches covered.">				for (int i = startVertex; i &lt; endVertex; i++)</span>
<span class="fc" id="L672">					m_srcPts.add(new GraphicPoint(multiPath.getXY(i)));</span>

<span class="fc bfc" id="L674" title="All 2 branches covered.">				if (buildOffset())</span>
<span class="fc" id="L675">					addPart(0, m_offsetPtCount - 1); // do not repeat closing</span>
														// point
			}
<span class="fc" id="L678">		} else {</span>
			// remove duplicate points at extremities
<span class="fc" id="L680">			Point2D ptStart = multiPath.getXY(startVertex);</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">			while ((startVertex &lt; endVertex)</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">					&amp;&amp; multiPath.getXY(startVertex + 1).isEqual(ptStart))</span>
<span class="nc" id="L683">				startVertex++;</span>
<span class="fc" id="L684">			Point2D ptEnd = multiPath.getXY(endVertex - 1);</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">			while ((startVertex &lt; endVertex)</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">					&amp;&amp; multiPath.getXY(endVertex - 2).isEqual(ptEnd))</span>
<span class="nc" id="L687">				endVertex--;</span>

			// we need at least two points for a polyline
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">			if (endVertex - startVertex &gt;= 2) {</span>
				// close the line and mark the opposite segments as non valid
<span class="fc" id="L692">				m_srcPtCount = (endVertex - startVertex) * 2 - 2;</span>
<span class="fc" id="L693">				m_srcPts = new ArrayList&lt;GraphicPoint&gt;(m_srcPtCount);</span>
				// TODO: may throw std::bad:alloc()

<span class="fc" id="L696">				GraphicPoint pt = new GraphicPoint(multiPath.getXY(startVertex));</span>
<span class="fc" id="L697">				pt.type |= IS_END + CLOSING_SEG;</span>
<span class="fc" id="L698">				m_srcPts.add(pt);</span>

<span class="fc bfc" id="L700" title="All 2 branches covered.">				for (int i = startVertex + 1; i &lt; endVertex - 1; i++) {</span>
<span class="fc" id="L701">					pt = new GraphicPoint(multiPath.getXY(i));</span>
<span class="fc" id="L702">					m_srcPts.add(pt);</span>
				}

<span class="fc" id="L705">				pt = new GraphicPoint(multiPath.getXY(endVertex - 1));</span>
<span class="fc" id="L706">				pt.type |= IS_END;</span>
<span class="fc" id="L707">				m_srcPts.add(pt);</span>

<span class="fc bfc" id="L709" title="All 2 branches covered.">				for (int i = endVertex - 2; i &gt;= startVertex + 1; i--) {</span>
<span class="fc" id="L710">					pt = new GraphicPoint(multiPath.getXY(i));</span>
<span class="fc" id="L711">					pt.type |= CLOSING_SEG;</span>
<span class="fc" id="L712">					m_srcPts.add(pt);</span>
				}

<span class="fc bfc" id="L715" title="All 2 branches covered.">				if (buildOffset())</span>

<span class="pc bpc" id="L717" title="1 of 2 branches missed.">					if (m_offsetPts.size() &gt;= 2) {</span>
						// extract the part that doesn't have the CLOSING_SEG
						// attribute

<span class="fc" id="L721">						int iStart = -1;</span>
<span class="fc" id="L722">						int iEnd = -1;</span>
<span class="fc" id="L723">						boolean prevClosed = (m_offsetPts</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">								.get(m_offsetPtCount - 1).type &amp; CLOSING_SEG) != 0;</span>
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">						if (!prevClosed)</span>
<span class="nc" id="L726">							iStart = 0;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">						for (int i = 1; i &lt; m_offsetPtCount; i++) {</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">							boolean closed = (m_offsetPts.get(i).type &amp; CLOSING_SEG) != 0;</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">							if (!closed) {</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">								if (prevClosed) {</span>
									// if ((m_offsetPts[i - 1].type &amp; MOVE_TO)
									// == 0)
									// m_offsetPts[i - 1].type += MOVE_TO -
									// LINE_TO;
<span class="fc" id="L735">									iStart = i - 1;</span>
								}
							} else {
<span class="fc bfc" id="L738" title="All 2 branches covered.">								if (!prevClosed) {</span>
<span class="fc" id="L739">									iEnd = i - 1;</span>
									// for (long i = iStart; i &lt;= iEnd; i++)
									// m_offsetPts[i].type &amp;= OUR_FLAGS_MASK;
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">									if (iEnd - iStart + 1 &gt; 1)</span>
<span class="fc" id="L743">										addPart(iStart, iEnd - iStart + 1);</span>
								}
							}
<span class="fc" id="L746">							prevClosed = closed;</span>
						}
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">						if (!prevClosed) {</span>
<span class="nc" id="L749">							iEnd = m_offsetPtCount - 1;</span>
							// for (long i = iStart; i &lt;= iEnd; i++)
							// m_offsetPts[i].type &amp;= OUR_FLAGS_MASK;
<span class="nc bnc" id="L752" title="All 2 branches missed.">							if (iEnd - iStart + 1 &gt; 1)</span>
<span class="nc" id="L753">								addPart(iStart, iEnd - iStart + 1);</span>
						}
<span class="fc" id="L755">					} else {</span>
<span class="nc" id="L756">						int iStart = 0;</span>
<span class="nc" id="L757">						int iEnd = m_offsetPtCount - 1;</span>
<span class="nc bnc" id="L758" title="All 4 branches missed.">						if (iStart &gt;= 0 &amp;&amp; iEnd - iStart &gt;= 1) {</span>
							// for (long i = iStart; i &lt;= iEnd; i++)
							// m_offsetPts[i].type &amp;= OUR_FLAGS_MASK;
<span class="nc" id="L761">							addPart(iStart, iEnd - iStart + 1);</span>
						}
					}
			}
		}

		// clear source
<span class="fc" id="L768">		m_srcPts = null;</span>
<span class="fc" id="L769">		m_srcPtCount = 0;</span>
		// free offset buffer
<span class="fc" id="L771">		m_offsetPts = null;</span>
<span class="fc" id="L772">		m_offsetPtCount = 0;</span>
<span class="fc" id="L773">	}</span>

	boolean removeBadSegsFast() {
<span class="fc" id="L776">		boolean bWrong = false;</span>

		// initialize circular doubly-linked list
		// skip last point which is dup of first point
<span class="fc bfc" id="L780" title="All 2 branches covered.">		for (int i = 0; i &lt; m_offsetPtCount; i++) {</span>
<span class="fc" id="L781">			GraphicPoint pt = m_offsetPts.get(i);</span>
<span class="fc" id="L782">			pt.m_next = i + 1;</span>
<span class="fc" id="L783">			pt.m_prev = i - 1;</span>
<span class="fc" id="L784">			m_offsetPts.set(i, pt);</span>
		}

		// need to update the first and last elements
		GraphicPoint pt;

<span class="fc" id="L790">		pt = m_offsetPts.get(0);</span>
<span class="fc" id="L791">		pt.m_prev = m_offsetPtCount - 2;</span>
<span class="fc" id="L792">		m_offsetPts.set(0, pt);</span>

<span class="fc" id="L794">		pt = m_offsetPts.get(m_offsetPtCount - 2);</span>
<span class="fc" id="L795">		pt.m_next = 0;</span>
<span class="fc" id="L796">		m_offsetPts.set(m_offsetPtCount - 2, pt);</span>

<span class="fc" id="L798">		int w = 0;</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">		for (int i = 0; i &lt; m_offsetPtCount; i++) {</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">			if ((m_offsetPts.get(w).type &amp; BAD_SEG) != 0) {</span>
<span class="fc" id="L801">				int wNext = deleteClosedSeg(w);</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">				if (wNext != -1)</span>
<span class="fc" id="L803">					w = wNext;</span>
				else {
<span class="fc" id="L805">					bWrong = true;</span>
<span class="fc" id="L806">					break;</span>
				}
<span class="fc" id="L808">			} else</span>
<span class="fc" id="L809">				w = m_offsetPts.get(w).m_next;</span>
		}

<span class="fc bfc" id="L812" title="All 2 branches covered.">		if (bWrong)</span>
<span class="fc" id="L813">			return false;</span>

		// w is the index of a known good (i.e. surviving ) point in the offset
		// array
<span class="fc" id="L817">		compressOffsetArray(w);</span>
<span class="fc" id="L818">		return true;</span>
	}

	int deleteClosedSeg(int seg) {
<span class="fc" id="L822">		int n = m_offsetPtCount - 1; // number of segments</span>

		// check combinations of segments
<span class="fc" id="L825">		int ip0 = seg, ip, im;</span>

<span class="fc bfc" id="L827" title="All 2 branches covered.">		for (int i = 1; i &lt;= n - 2; i++) {</span>
<span class="fc" id="L828">			ip0 = m_offsetPts.get(ip0).m_next;</span>

<span class="fc" id="L830">			ip = ip0;</span>
<span class="fc" id="L831">			im = seg;</span>

<span class="fc bfc" id="L833" title="All 2 branches covered.">			for (int j = 1; j &lt;= i; j++) {</span>
<span class="fc" id="L834">				im = m_offsetPts.get(im).m_prev;</span>

<span class="fc bfc" id="L836" title="All 2 branches covered.">				if ((m_offsetPts.get(im).type &amp; BAD_SEG) == 0</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">						&amp;&amp; (m_offsetPts.get(ip).type &amp; BAD_SEG) == 0) {</span>
<span class="fc" id="L838">					int rSegNext = handleClosedIntersection(im, ip);</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">					if (rSegNext != -1)</span>
<span class="fc" id="L840">						return rSegNext;</span>
				}

<span class="fc" id="L843">				ip = m_offsetPts.get(ip).m_prev;</span>
			}
		}

<span class="fc" id="L847">		return -1;</span>
	}

	// line segments defined by (im-1, im) and (ip-1, ip)
	int handleClosedIntersection(int im, int ip) {
		GraphicPoint pt1, pt2, pt3, pt4;
<span class="fc" id="L853">		pt1 = m_offsetPts.get(m_offsetPts.get(im).m_prev);</span>
<span class="fc" id="L854">		pt2 = m_offsetPts.get(im);</span>
<span class="fc" id="L855">		pt3 = m_offsetPts.get(m_offsetPts.get(ip).m_prev);</span>
<span class="fc" id="L856">		pt4 = m_offsetPts.get(ip);</span>

<span class="fc bfc" id="L858" title="All 2 branches covered.">		if (!sectGraphicRect(pt1, pt2, pt3, pt4))</span>
<span class="fc" id="L859">			return -1;</span>

		// intersection
<span class="fc" id="L862">		IntersectionInfo ii = new IntersectionInfo();</span>
<span class="fc bfc" id="L863" title="All 4 branches covered.">		if (findIntersection(pt1, pt2, pt3, pt4, ii) &amp;&amp; !ii.atExistingPt)</span>
<span class="fc" id="L864">			if (Math.signum((pt2.x - pt1.x) * (pt4.y - pt3.y) - (pt2.y - pt1.y)</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">					* (pt4.x - pt3.x)) != Math.signum(m_distance)) {</span>
<span class="fc" id="L866">				int prev0 = m_offsetPts.get(im).m_prev;</span>

<span class="fc" id="L868">				ii.pt.type = pt2.type;</span>
<span class="fc" id="L869">				ii.pt.m_next = ip;</span>
<span class="fc" id="L870">				ii.pt.m_prev = prev0;</span>
<span class="fc" id="L871">				m_offsetPts.set(im, ii.pt);</span>

<span class="fc" id="L873">				ii.pt = m_offsetPts.get(ip);</span>
<span class="fc" id="L874">				ii.pt.m_prev = im;</span>
<span class="fc" id="L875">				m_offsetPts.set(ip, ii.pt);</span>

<span class="fc" id="L877">				return ip;</span>
			}
<span class="fc" id="L879">		return -1;</span>
	}

	boolean sectGraphicRect(GraphicPoint pt1, GraphicPoint pt2,
			GraphicPoint pt3, GraphicPoint pt4) {
<span class="fc bfc" id="L884" title="All 2 branches covered.">		return (Math.max(pt1.x, pt2.x) &gt;= Math.min(pt3.x, pt4.x)</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">				&amp;&amp; Math.max(pt3.x, pt4.x) &gt;= Math.min(pt1.x, pt2.x)</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">				&amp;&amp; Math.max(pt1.y, pt2.y) &gt;= Math.min(pt3.y, pt4.y) &amp;&amp; Math</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">				.max(pt3.y, pt4.y) &gt;= Math.min(pt1.y, pt2.y));</span>
	}

	boolean findIntersection(GraphicPoint bp1, GraphicPoint bp2,
			GraphicPoint bp3, GraphicPoint bp4,
			IntersectionInfo intersectionInfo) {
<span class="fc" id="L893">		intersectionInfo.atExistingPt = false;</span>

		// Note: test if rectangles intersect already done by caller

		// intersection
		double i, j, r, r1;
<span class="fc" id="L899">		i = (bp2.y - bp1.y) * (bp4.x - bp3.x) - (bp2.x - bp1.x)</span>
				* (bp4.y - bp3.y);
<span class="fc" id="L901">		j = (bp3.y - bp1.y) * (bp2.x - bp1.x) - (bp3.x - bp1.x)</span>
				* (bp2.y - bp1.y);
<span class="fc bfc" id="L903" title="All 2 branches covered.">		if (i == 0.0)</span>
<span class="fc" id="L904">			r = 2.0;</span>
		else
<span class="fc" id="L906">			r = j / i;</span>

<span class="fc bfc" id="L908" title="All 4 branches covered.">		if ((r &gt;= 0.0) &amp;&amp; (r &lt;= 1.0)) {</span>
<span class="fc" id="L909">			r1 = r;</span>
<span class="fc" id="L910">			i = (bp4.y - bp3.y) * (bp2.x - bp1.x) - (bp4.x - bp3.x)</span>
					* (bp2.y - bp1.y);
<span class="fc" id="L912">			j = (bp1.y - bp3.y) * (bp4.x - bp3.x) - (bp1.x - bp3.x)</span>
					* (bp4.y - bp3.y);

<span class="pc bpc" id="L915" title="1 of 2 branches missed.">			if (i == 0.0)</span>
<span class="nc" id="L916">				r = 2.0;</span>
			else
<span class="fc" id="L918">				r = j / i;</span>

<span class="fc bfc" id="L920" title="All 4 branches covered.">			if ((r &gt;= 0.0) &amp;&amp; (r &lt;= 1.0)) {</span>
<span class="fc" id="L921">				intersectionInfo.pt = new GraphicPoint(bp1.x + r</span>
						* (bp2.x - bp1.x), bp1.y + r * (bp2.y - bp1.y));
<span class="fc" id="L923">				intersectionInfo.pt.m = bp3.m + r1 * (bp4.m - bp3.m);</span>
<span class="fc bfc" id="L924" title="All 8 branches covered.">				if (((r1 == 0.0) || (r1 == 1.0)) &amp;&amp; ((r == 0.0) || (r == 1.0)))</span>
<span class="fc" id="L925">					intersectionInfo.atExistingPt = true;</span>

<span class="fc" id="L927">				intersectionInfo.rFirst = r;</span>
<span class="fc" id="L928">				intersectionInfo.rSecond = r1;</span>

<span class="fc bfc" id="L930" title="All 16 branches covered.">				if (((r1 == 0.0) || (r1 == 1.0)) &amp;&amp; ((r &gt; 0.0) &amp;&amp; (r &lt; 1.0))</span>
						|| ((r == 0.0) || (r == 1.0))
						&amp;&amp; ((r1 &gt; 0.0) &amp;&amp; (r1 &lt; 1.0))) {
<span class="fc" id="L933">					return false;</span>
				}

<span class="fc" id="L936">				return true;</span>
			}
		}
<span class="fc" id="L939">		return false;</span>
	}

	// i0 is the index of a known good point in the offset points array; that
	// is, its the index of a point that isn't part of a deleted loop
	void compressOffsetArray(int i0) {
<span class="fc" id="L945">		int i_ = i0;</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">		while (m_offsetPts.get(i_).m_prev &lt; i_)</span>
<span class="fc" id="L947">			i_ = m_offsetPts.get(i_).m_prev;</span>

<span class="fc" id="L949">		int j = 0, i = i_;</span>

		do {
<span class="fc" id="L952">			GraphicPoint pt = m_offsetPts.get(i);</span>
<span class="fc" id="L953">			m_offsetPts.set(j, pt);</span>
<span class="fc" id="L954">			i = pt.m_next;</span>
<span class="fc" id="L955">			j++;</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">		} while (i != i_);</span>

<span class="fc" id="L958">		m_offsetPts.set(j, m_offsetPts.get(0)); // duplicate closing point</span>

<span class="fc" id="L960">		m_offsetPtCount = j + 1;</span>
<span class="fc" id="L961">	}</span>

	void _OffsetMultiPath(MultiPath resultingPath) {
		// we process all path independently, then merge the results
<span class="fc" id="L965">		MultiPath multiPath = (MultiPath) m_inputGeometry;</span>
<span class="fc" id="L966">		SegmentIterator segmentIterator = multiPath.querySegmentIterator();</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">		if (segmentIterator == null)</span>
<span class="nc" id="L968">			return; // TODO: strategy on error?</span>

<span class="fc" id="L970">		segmentIterator.resetToFirstPath();</span>
<span class="fc" id="L971">		int pathIndex = -1;</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">		while (segmentIterator.nextPath()) {</span>
<span class="fc" id="L973">			pathIndex++;</span>
<span class="fc" id="L974">			_OffsetPath(multiPath, pathIndex, resultingPath);</span>
		}
<span class="fc" id="L976">	}</span>

	Geometry _ConstructOffset() {
<span class="fc" id="L979">		int gt = m_inputGeometry.getType().value();</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">		if (gt == Geometry.GeometryType.Line) {</span>
<span class="nc" id="L981">			return _OffsetLine();</span>
		}
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">		if (gt == Geometry.GeometryType.Envelope) {</span>
<span class="nc" id="L984">			return _OffsetEnvelope();</span>
		}
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">		if (Geometry.isSegment(gt)) {</span>
<span class="nc" id="L987">			Polyline poly = new Polyline();</span>
<span class="nc" id="L988">			poly.addSegment((Segment) m_inputGeometry, true);</span>
<span class="nc" id="L989">			m_inputGeometry = poly;</span>
<span class="nc" id="L990">			return _ConstructOffset();</span>
		}
<span class="fc bfc" id="L992" title="All 2 branches covered.">		if (gt == Geometry.GeometryType.Polyline) {</span>
<span class="fc" id="L993">			Polyline polyline = new Polyline();</span>
<span class="fc" id="L994">			_OffsetMultiPath(polyline);</span>
<span class="fc" id="L995">			return polyline;</span>
		}
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">		if (gt == Geometry.GeometryType.Polygon) {</span>
<span class="fc" id="L998">			Polygon polygon = new Polygon();</span>
<span class="fc" id="L999">			_OffsetMultiPath(polygon);</span>
<span class="fc" id="L1000">			return polygon;</span>
		}
		// throw new GeometryException(&quot;not implemented&quot;);
<span class="nc" id="L1003">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>