<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConvexHull.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">ConvexHull.java</span></div><h1>ConvexHull.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2015 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */
package com.esri.core.geometry;

<span class="fc" id="L26">class ConvexHull {</span>
	/*
	 * Constructor for a Convex_hull object. Used for dynamic insertion of geometries to create a convex hull.
	 */
<span class="fc" id="L30">	ConvexHull() {</span>
<span class="fc" id="L31">		m_tree_hull = new Treap();</span>
<span class="fc" id="L32">		m_tree_hull.setCapacity(20);</span>
<span class="fc" id="L33">		m_shape = new EditShape();</span>
<span class="fc" id="L34">		m_geometry_handle = m_shape.createGeometry(Geometry.Type.MultiPoint);</span>
<span class="fc" id="L35">		m_path_handle = m_shape.insertPath(m_geometry_handle, -1);</span>
<span class="fc" id="L36">		m_call_back = new CallBackShape(this);</span>
<span class="fc" id="L37">	}</span>

<span class="fc" id="L39">	private ConvexHull(AttributeStreamOfDbl stream, int n) {</span>
<span class="fc" id="L40">		m_tree_hull = new Treap();</span>
<span class="fc" id="L41">		m_tree_hull.setCapacity(Math.min(20, n));</span>
<span class="fc" id="L42">		m_stream = stream;</span>
<span class="fc" id="L43">		m_call_back = new CallBackStream(this);</span>
<span class="fc" id="L44">	}</span>

<span class="fc" id="L46">	private ConvexHull(Point2D[] points, int n) {</span>
<span class="fc" id="L47">		m_tree_hull = new Treap();</span>
<span class="fc" id="L48">		m_tree_hull.setCapacity(Math.min(20, n));</span>
<span class="fc" id="L49">		m_points = points;</span>
<span class="fc" id="L50">		m_call_back = new CallBackPoints(this);</span>
<span class="fc" id="L51">	}</span>

	/**
	 * Adds a geometry to the current bounding geometry using an incremental algorithm for dynamic insertion.
	 * @param geometry The geometry to add to the bounding geometry.
	 */

	void addGeometry(Geometry geometry) {
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">		if (geometry.isEmpty())</span>
<span class="nc" id="L60">			return;</span>
		
<span class="fc" id="L62">		int type = geometry.getType().value();</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">		if (MultiVertexGeometry.isMultiVertex(type))</span>
<span class="fc" id="L65">			addMultiVertexGeometry_((MultiVertexGeometry) geometry);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">		else if (MultiPath.isSegment(type))</span>
<span class="fc" id="L67">			addSegment_((Segment) geometry);</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">		else if (type == Geometry.GeometryType.Envelope)</span>
<span class="fc" id="L69">			addEnvelope_((Envelope) geometry);</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">		else if (type == Geometry.GeometryType.Point)</span>
<span class="fc" id="L71">			addPoint_((Point) geometry);</span>
		else
<span class="nc" id="L73">			throw new IllegalArgumentException(&quot;invalid shape type&quot;);</span>
<span class="fc" id="L74">	}</span>

	/**
	 * Gets the current bounding geometry.
	 * Returns a Geometry.
	 */

	Geometry getBoundingGeometry() {
		// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.
<span class="fc" id="L83">		Point point = new Point();</span>
<span class="fc" id="L84">		int first = m_tree_hull.getFirst(-1);</span>
<span class="fc" id="L85">		Polygon hull = new Polygon(m_shape.getVertexDescription());</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">		if (m_tree_hull.size(-1) == 0)</span>
<span class="nc" id="L87">			return hull;</span>
		
<span class="fc" id="L89">		m_shape.queryPoint(m_tree_hull.getElement(first), point);</span>
<span class="fc" id="L90">		hull.startPath(point);</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">		for (int i = m_tree_hull.getNext(first); i != -1; i = m_tree_hull.getNext(i)) {</span>
<span class="fc" id="L93">			m_shape.queryPoint(m_tree_hull.getElement(i), point);</span>
<span class="fc" id="L94">			hull.lineTo(point);</span>
		}

<span class="fc" id="L97">		return hull;</span>
	}

	/**
	 * Static method to construct the convex hull of a Multi_vertex_geometry.
	 * Returns a Geometry.
	 * \param mvg The geometry used to create the convex hull.
	 */

	static Geometry construct(MultiVertexGeometry mvg) {
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">		if (mvg.isEmpty())</span>
<span class="nc" id="L108">			return new Polygon(mvg.getDescription());</span>

<span class="fc" id="L110">		MultiVertexGeometryImpl mvg_impl = (MultiVertexGeometryImpl) mvg._getImpl();</span>
<span class="fc" id="L111">		int N = mvg_impl.getPointCount();</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">		if (N &lt;= 2) {</span>
<span class="pc bpc" id="L114" title="1 of 4 branches missed.">			if (N == 1 || mvg_impl.getXY(0).equals(mvg_impl.getXY(1))) {</span>
<span class="fc" id="L115">				Point point = new Point(mvg_impl.getDescription());</span>
<span class="fc" id="L116">				mvg_impl.getPointByVal(0, point);</span>
<span class="fc" id="L117">				return point;</span>
			} else {
<span class="fc" id="L119">				Point pt = new Point();</span>
<span class="fc" id="L120">				Polyline polyline = new Polyline(mvg_impl.getDescription());</span>
<span class="fc" id="L121">				mvg_impl.getPointByVal(0, pt);</span>
<span class="fc" id="L122">				polyline.startPath(pt);</span>
<span class="fc" id="L123">				mvg_impl.getPointByVal(1, pt);</span>
<span class="fc" id="L124">				polyline.lineTo(pt);</span>
<span class="fc" id="L125">				return polyline;</span>
			}
		}

<span class="fc" id="L129">		AttributeStreamOfDbl stream = (AttributeStreamOfDbl) mvg_impl.getAttributeStreamRef(VertexDescription.Semantics.POSITION);</span>
<span class="fc" id="L130">		ConvexHull convex_hull = new ConvexHull(stream, N);</span>

<span class="fc" id="L132">		int t0 = 0, tm = 1;</span>
<span class="fc" id="L133">		Point2D pt_0 = new Point2D();</span>
<span class="fc" id="L134">		Point2D pt_m = new Point2D();</span>
<span class="fc" id="L135">		Point2D pt_p = new Point2D();</span>

<span class="fc" id="L137">		stream.read(t0 &lt;&lt; 1, pt_0);</span>

		while (true) {
<span class="fc bfc" id="L140" title="All 2 branches covered.">			if (tm &gt;= N)</span>
<span class="fc" id="L141">				break;</span>

<span class="fc" id="L143">			stream.read(tm &lt;&lt; 1, pt_m);</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">			if (!pt_m.isEqual(pt_0, NumberUtils.doubleEps()))</span>
<span class="fc" id="L145">				break;</span>

<span class="fc" id="L147">			tm++; // We don't want to close the gap between t0 and tm.</span>
		}

<span class="fc" id="L150">		convex_hull.m_tree_hull.addElement(t0, -1);</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">		if (tm &lt; N) {</span>
<span class="fc" id="L153">			convex_hull.m_tree_hull.addBiggestElement(tm, -1);</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">			for (int tp = tm + 1; tp &lt; mvg_impl.getPointCount(); tp++) {// Dynamically insert into the current convex hull</span>

<span class="fc" id="L157">				stream.read(tp &lt;&lt; 1, pt_p);</span>
<span class="fc" id="L158">				int p = convex_hull.treeHull_(pt_p);</span>

<span class="fc bfc" id="L160" title="All 2 branches covered.">				if (p != -1)</span>
<span class="fc" id="L161">					convex_hull.m_tree_hull.setElement(p, tp); // reset the place holder to the point index.</span>
			}
		}

		// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.

<span class="fc" id="L167">		VertexDescription description = mvg_impl.getDescription();</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">		boolean b_has_attributes = (description.getAttributeCount() &gt; 1);</span>
<span class="fc" id="L169">		int point_count = convex_hull.m_tree_hull.size(-1);</span>

		Geometry hull;

<span class="fc bfc" id="L173" title="All 2 branches covered.">		if (point_count &gt;= 2) {</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">			if (point_count &gt;= 3)</span>
<span class="fc" id="L175">				hull = new Polygon(description);</span>
			else
<span class="fc" id="L177">				hull = new Polyline(description);</span>

<span class="fc" id="L179">			MultiPathImpl hull_impl = (MultiPathImpl) hull._getImpl();</span>
<span class="fc" id="L180">			hull_impl.addPath((Point2D[]) null, 0, true);</span>

<span class="fc" id="L182">			Point point = null;</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">			if (b_has_attributes)</span>
<span class="fc" id="L184">				point = new Point();</span>

<span class="fc bfc" id="L186" title="All 2 branches covered.">			for (int i = convex_hull.m_tree_hull.getFirst(-1); i != -1; i = convex_hull.m_tree_hull.getNext(i)) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">				if (b_has_attributes) {</span>
<span class="fc" id="L188">					mvg_impl.getPointByVal(convex_hull.m_tree_hull.getElement(i), point);</span>
<span class="fc" id="L189">					hull_impl.insertPoint(0, -1, point);</span>
				} else {
<span class="fc" id="L191">					stream.read(convex_hull.m_tree_hull.getElement(i) &lt;&lt; 1, pt_p);</span>
<span class="fc" id="L192">					hull_impl.insertPoint(0, -1, pt_p);</span>
				}
			}
<span class="fc" id="L195">		} else {</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">			assert (point_count == 1);</span>

<span class="pc bpc" id="L198" title="1 of 2 branches missed.">			if (b_has_attributes) {</span>
<span class="nc" id="L199">				Point point = new Point(description);</span>
<span class="nc" id="L200">				mvg_impl.getPointByVal(convex_hull.m_tree_hull.getElement(convex_hull.m_tree_hull.getFirst(-1)), point);</span>
<span class="nc" id="L201">				hull = point;</span>
<span class="nc" id="L202">			} else {</span>
<span class="fc" id="L203">				stream.read(convex_hull.m_tree_hull.getElement(convex_hull.m_tree_hull.getFirst(-1)) &lt;&lt; 1, pt_p);</span>
<span class="fc" id="L204">				hull = new Point(pt_p);</span>
			}
		}

<span class="fc" id="L208">		return hull;</span>
	}

	/**
	 * Static method to construct the convex hull from an array of points. The
	 * out_convex_hull array will be populated with the subset of index
	 * positions which contribute to the convex hull.
	 * Returns the number of points in the convex hull.
	 * \param points The points used to create the convex hull.
	 * \param count The number of points in the input Point2D array.
	 * \param out_convex_hull An index array allocated by the user at least as big as the size of the input points array.
	 */
	static int construct(Point2D[] points, int count, int[] out_convex_hull) {
<span class="fc" id="L221">		ConvexHull convex_hull = new ConvexHull(points, count);</span>

<span class="fc" id="L223">		int t0 = 0, tm = 1;</span>
<span class="fc" id="L224">		Point2D pt_0 = points[t0];</span>

<span class="fc bfc" id="L226" title="All 4 branches covered.">		while (tm &lt; count &amp;&amp; points[tm].isEqual(pt_0, NumberUtils.doubleEps()))</span>
<span class="fc" id="L227">			tm++; // We don't want to close the gap between t0 and tm.</span>

<span class="fc" id="L229">		convex_hull.m_tree_hull.addElement(t0, -1);</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">		if (tm &lt; count) {</span>
<span class="fc" id="L232">			convex_hull.m_tree_hull.addBiggestElement(tm, -1);</span>

<span class="fc bfc" id="L234" title="All 2 branches covered.">			for (int tp = tm + 1; tp &lt; count; tp++) {// Dynamically insert into the current convex hull.</span>

<span class="fc" id="L236">				Point2D pt_p = points[tp];</span>
<span class="fc" id="L237">				int p = convex_hull.treeHull_(pt_p);</span>

<span class="pc bpc" id="L239" title="1 of 2 branches missed.">				if (p != -1)</span>
<span class="fc" id="L240">					convex_hull.m_tree_hull.setElement(p, tp); // reset the place holder to the point index.</span>
			}
		}

		// Extracts the convex hull from the tree. Reading the tree in order from first to last is the resulting convex hull.
<span class="fc" id="L245">		int out_count = 0;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">		for (int i = convex_hull.m_tree_hull.getFirst(-1); i != -1; i = convex_hull.m_tree_hull.getNext(i))</span>
<span class="fc" id="L247">			out_convex_hull[out_count++] = convex_hull.m_tree_hull.getElement(i);</span>

<span class="fc" id="L249">		return out_count;</span>
	}

	/**
	 * Returns true if the given path of the input MultiPath is convex. Returns false otherwise.
	 * \param multi_path The MultiPath to check if the path is convex.
	 * \param path_index The path of the MultiPath to check if its convex.
	 */
	static boolean isPathConvex(MultiPath multi_path, int path_index, ProgressTracker progress_tracker) {
<span class="fc" id="L258">		MultiPathImpl mimpl = (MultiPathImpl) multi_path._getImpl();</span>
<span class="fc" id="L259">		int path_start = mimpl.getPathStart(path_index);</span>
<span class="fc" id="L260">		int path_end = mimpl.getPathEnd(path_index);</span>

<span class="pc bpc" id="L262" title="3 of 4 branches missed.">		boolean bxyclosed = !mimpl.isClosedPath(path_index) &amp;&amp; mimpl.isClosedPathInXYPlane(path_index);</span>

<span class="fc" id="L264">		AttributeStreamOfDbl position = (AttributeStreamOfDbl) (mimpl.getAttributeStreamRef(VertexDescription.Semantics.POSITION));</span>
<span class="fc" id="L265">		int position_start = 2 * path_start;</span>
<span class="fc" id="L266">		int position_end = 2 * path_end;</span>

<span class="pc bpc" id="L268" title="1 of 2 branches missed.">		if (bxyclosed)</span>
<span class="nc" id="L269">			position_end -= 2;</span>

<span class="pc bpc" id="L271" title="1 of 2 branches missed.">		if (position_end - position_start &lt; 6)</span>
<span class="nc" id="L272">			return true;</span>

		// This matches the logic for case 1 of the tree hull algorithm. The idea is inductive. We assume we have a convex hull pt_0,...,pt_m, and we see if
		// a new point (pt_pivot) is among the transitive tournament for pt_0, knowing that pt_pivot comes after pt_m.

		// We check three conditions:
		// 1) pt_m-&gt;pt_pivot-&gt;pt_0 is clockwise (closure across the boundary is convex)
		// 2) pt_1-&gt;pt_pivot-&gt;pt_0 is clockwise (the first step forward is convex)  (pt_1 is the next point after pt_0)
		// 3) pt_m-&gt;pt_pivot-&gt;pt_m_prev is clockwise (the first step backwards is convex)  (pt_m_prev is the previous point before pt_m)

		// If all three of the above conditions are clockwise, then pt_pivot is among the transitive tournament for pt_0, and therefore the polygon pt_0, ..., pt_m, pt_pivot is convex.

<span class="fc" id="L284">		Point2D pt_0 = new Point2D(), pt_m = new Point2D(), pt_pivot = new Point2D();</span>
<span class="fc" id="L285">		position.read(position_start, pt_0);</span>
<span class="fc" id="L286">		position.read(position_start + 2, pt_m);</span>
<span class="fc" id="L287">		position.read(position_start + 4, pt_pivot);</span>

		// Initial inductive step
<span class="fc" id="L290">		ECoordinate det_ec = determinant_(pt_m, pt_pivot, pt_0);</span>

<span class="fc bfc" id="L292" title="All 4 branches covered.">		if (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))</span>
<span class="fc" id="L293">			return false;</span>

<span class="fc" id="L295">		Point2D pt_1 = new Point2D(pt_m.x, pt_m.y);</span>
<span class="fc" id="L296">		Point2D pt_m_prev = new Point2D();</span>

		// Assume that pt_0,...,pt_m is convex. Check if the next point, pt_pivot, maintains the convex invariant.
<span class="fc bfc" id="L299" title="All 2 branches covered.">		for (int i = position_start + 6; i &lt; position_end; i += 2) {</span>
<span class="fc" id="L300">			pt_m_prev.setCoords(pt_m);</span>
<span class="fc" id="L301">			pt_m.setCoords(pt_pivot);</span>
<span class="fc" id="L302">			position.read(i, pt_pivot);</span>

<span class="fc" id="L304">			det_ec = determinant_(pt_m, pt_pivot, pt_0);</span>

<span class="fc bfc" id="L306" title="All 4 branches covered.">			if (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))</span>
<span class="fc" id="L307">				return false;</span>

<span class="fc" id="L309">			det_ec = determinant_(pt_1, pt_pivot, pt_0);</span>

<span class="pc bpc" id="L311" title="2 of 4 branches missed.">			if (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))</span>
<span class="nc" id="L312">				return false;</span>

<span class="fc" id="L314">			det_ec = determinant_(pt_m, pt_pivot, pt_m_prev);</span>

<span class="pc bpc" id="L316" title="1 of 4 branches missed.">			if (det_ec.isFuzzyZero() || !isClockwise_(det_ec.value()))</span>
<span class="fc" id="L317">				return false;</span>
		}

<span class="fc" id="L320">		return true;</span>
	}

	// Dynamically inserts each geometry into the convex hull.
	private void addMultiVertexGeometry_(MultiVertexGeometry mvg) {
<span class="fc" id="L325">		Point point = new Point();</span>
<span class="fc" id="L326">		Point2D pt_p = new Point2D();</span>

<span class="fc bfc" id="L328" title="All 2 branches covered.">		for (int i = 0; i &lt; mvg.getPointCount(); i++) {</span>
<span class="fc" id="L329">			mvg.getXY(i, pt_p);</span>
<span class="fc" id="L330">			int p = addPoint_(pt_p);</span>

<span class="fc bfc" id="L332" title="All 2 branches covered.">			if (p != -1) {</span>
<span class="fc" id="L333">				mvg.getPointByVal(i, point);</span>
<span class="fc" id="L334">				int tp = m_shape.addPoint(m_path_handle, point);</span>
<span class="fc" id="L335">				m_tree_hull.setElement(p, tp); // reset the place holder to tp</span>
			}
		}
<span class="fc" id="L338">	}</span>

	private void addEnvelope_(Envelope envelope) {
<span class="fc" id="L341">		Point point = new Point();</span>
<span class="fc" id="L342">		Point2D pt_p = new Point2D();</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">		for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc" id="L345">			envelope.queryCorner(i, pt_p);</span>
<span class="fc" id="L346">			int p = addPoint_(pt_p);</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">			if (p != -1) {</span>
<span class="fc" id="L349">				envelope.queryCornerByVal(i, point);</span>
<span class="fc" id="L350">				int tp = m_shape.addPoint(m_path_handle, point);</span>
<span class="fc" id="L351">				m_tree_hull.setElement(p, tp); // reset the place holder to tp</span>
			}
		}
<span class="fc" id="L354">	}</span>

	private void addSegment_(Segment segment) {
<span class="fc" id="L357">		Point point = new Point();</span>

<span class="fc" id="L359">		Point2D pt_start = segment.getStartXY();</span>
<span class="fc" id="L360">		int p_start = addPoint_(pt_start);</span>

<span class="pc bpc" id="L362" title="1 of 2 branches missed.">		if (p_start != -1) {</span>
<span class="nc" id="L363">			segment.queryStart(point);</span>
<span class="nc" id="L364">			int t_start = m_shape.addPoint(m_path_handle, point);</span>
<span class="nc" id="L365">			m_tree_hull.setElement(p_start, t_start); // reset the place holder</span>
			// to tp
		}

<span class="fc" id="L369">		Point2D pt_end = segment.getEndXY();</span>
<span class="fc" id="L370">		int p_end = addPoint_(pt_end);</span>

<span class="pc bpc" id="L372" title="1 of 2 branches missed.">		if (p_end != -1) {</span>
<span class="fc" id="L373">			segment.queryEnd(point);</span>
<span class="fc" id="L374">			int t_end = m_shape.addPoint(m_path_handle, point);</span>
<span class="fc" id="L375">			m_tree_hull.setElement(p_end, t_end); // reset the place holder to</span>
			// tp
		}
<span class="fc" id="L378">	}</span>

	private void addPoint_(Point point) {
<span class="fc" id="L381">		Point2D pt_p = point.getXY();</span>
<span class="fc" id="L382">		int p = addPoint_(pt_p);</span>

<span class="pc bpc" id="L384" title="1 of 2 branches missed.">		if (p != -1) {</span>
<span class="fc" id="L385">			int tp = m_shape.addPoint(m_path_handle, point);</span>
<span class="fc" id="L386">			m_tree_hull.setElement(p, tp); // reset the place holder to tp</span>
		}
<span class="fc" id="L388">	}</span>

	private int addPoint_(Point2D pt_p) {
<span class="fc" id="L391">		int p = -1;</span>

<span class="fc bfc" id="L393" title="All 2 branches covered.">		if (m_tree_hull.size(-1) == 0) {</span>
<span class="fc" id="L394">			p = m_tree_hull.addElement(-4, -1); // reset the place holder to tp</span>
<span class="fc" id="L395">			return p;</span>
		}

<span class="fc bfc" id="L398" title="All 2 branches covered.">		if (m_tree_hull.size(-1) == 1) {</span>
<span class="fc" id="L399">			int t0 = m_tree_hull.getElement(m_tree_hull.getFirst(-1));</span>
<span class="fc" id="L400">			Point2D pt_0 = m_shape.getXY(t0);</span>

<span class="fc bfc" id="L402" title="All 2 branches covered.">			if (!pt_p.isEqual(pt_0, NumberUtils.doubleEps())) // We don't want to close the gap between t0 and tm.</span>
<span class="fc" id="L403">				p = m_tree_hull.addBiggestElement(-5, -1); // set place holder to -5 to indicate the second element being added (tm).</span>

<span class="fc" id="L405">			return p;</span>
		}

<span class="fc" id="L408">		p = treeHull_(pt_p);</span>
<span class="fc" id="L409">		return p;</span>
	}

	// Algorithm taken from &quot;Axioms and Hulls&quot; by D.E. Knuth, Lecture Notes in Computer Science 606, page 47.
	private int treeHull_(Point2D pt_pivot) {
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">		assert (m_tree_hull.size(-1) &gt;= 2);</span>

<span class="fc" id="L416">		int p = -1;</span>

		do {
<span class="fc" id="L419">			int first = m_tree_hull.getFirst(-1);</span>
<span class="fc" id="L420">			int last = m_tree_hull.getLast(-1);</span>
<span class="fc" id="L421">			int t0 = m_tree_hull.getElement(first);</span>
<span class="fc" id="L422">			int tm = m_tree_hull.getElement(last);</span>

<span class="fc" id="L424">			Point2D pt_0 = new Point2D(); // should the memory be cached?</span>
<span class="fc" id="L425">			Point2D pt_m = new Point2D(); // should the memory be cached?</span>
<span class="fc" id="L426">			m_call_back.getXY(t0, pt_0);</span>
<span class="fc" id="L427">			m_call_back.getXY(tm, pt_m);</span>

<span class="pc bpc" id="L429" title="1 of 2 branches missed.">			assert (!pt_0.isEqual(pt_m, NumberUtils.doubleEps())); // assert that the gap is not closed</span>

<span class="fc" id="L431">			int orient_m_p_0 = Point2D.orientationRobust(pt_m, pt_pivot, pt_0); // determines case 1, 2, 3</span>

<span class="fc bfc" id="L433" title="All 2 branches covered.">			if (isClockwise_(orient_m_p_0)) {// Case 1: tp-&gt;t0-&gt;tm is clockwise</span>

<span class="fc" id="L435">				p = m_tree_hull.addBiggestElement(-1, -1); // set place holder to -1 for case 1.</span>
<span class="fc" id="L436">				int l = treeHullWalkBackward_(pt_pivot, last, first);</span>

<span class="pc bpc" id="L438" title="1 of 2 branches missed.">				if (l != first)</span>
<span class="fc" id="L439">					treeHullWalkForward_(pt_pivot, first, m_tree_hull.getPrev(l));</span>

				continue;
			}

<span class="fc bfc" id="L444" title="All 2 branches covered.">			if (isCounterClockwise_(orient_m_p_0)) {// Case 2: tp-&gt;tm-&gt;t0 is clockwise</span>
<span class="fc" id="L445">				int k = m_tree_hull.getRoot(-1), k_min = m_tree_hull.getFirst(-1), k_max = m_tree_hull.getLast(-1), k_prev;</span>
				int tk, tk_prev;
<span class="fc" id="L447">				Point2D pt_k = new Point2D();</span>
<span class="fc" id="L448">				Point2D pt_k_prev = new Point2D();</span>

<span class="fc bfc" id="L450" title="All 2 branches covered.">				while (k_min != m_tree_hull.getPrev(k_max)) {// binary search to find k such that t0-&gt;tp-&gt;tj holds (i.e. clockwise) for j &gt;= k. Hence, tj-&gt;tp-&gt;t0 is clockwise (or degenerate) for j &lt; k.</span>
<span class="fc" id="L451">					tk = m_tree_hull.getElement(k);</span>
<span class="fc" id="L452">					m_call_back.getXY(tk, pt_k);</span>
<span class="fc" id="L453">					int orient_k_p_0 = Point2D.orientationRobust(pt_k, pt_pivot, pt_0);</span>

<span class="fc bfc" id="L455" title="All 2 branches covered.">					if (isCounterClockwise_(orient_k_p_0)) {</span>
<span class="fc" id="L456">						k_max = k;</span>
<span class="fc" id="L457">						k = m_tree_hull.getLeft(k);</span>
					} else {
<span class="fc" id="L459">						k_min = k;</span>
<span class="fc" id="L460">						k = m_tree_hull.getRight(k);</span>
					}
<span class="fc" id="L462">				}</span>

<span class="fc" id="L464">				k = k_max;</span>
<span class="fc" id="L465">				k_prev = k_min;</span>
<span class="fc" id="L466">				tk = m_tree_hull.getElement(k);</span>
<span class="fc" id="L467">				tk_prev = m_tree_hull.getElement(k_prev);</span>
<span class="fc" id="L468">				m_call_back.getXY(tk, pt_k);</span>
<span class="fc" id="L469">				m_call_back.getXY(tk_prev, pt_k_prev);</span>
<span class="pc bpc" id="L470" title="2 of 4 branches missed.">				assert (isCounterClockwise_(Point2D.orientationRobust(pt_k, pt_pivot, pt_0)) &amp;&amp; !isCounterClockwise_(Point2D.orientationRobust(pt_k_prev, pt_pivot, pt_0)));</span>
<span class="pc bpc" id="L471" title="1 of 4 branches missed.">				assert (k_prev != first || isCounterClockwise_(Point2D.orientationRobust(pt_k, pt_pivot, pt_0)));</span>

<span class="fc bfc" id="L473" title="All 2 branches covered.">				if (k_prev != first) {</span>
<span class="fc" id="L474">					int orient_k_prev_p_k = Point2D.orientationRobust(pt_k_prev, pt_pivot, pt_k);</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">					if (!isClockwise_(orient_k_prev_p_k))</span>
<span class="fc" id="L477">						continue; // pt_pivot is inside the hull (or on the boundary)</span>
				}

<span class="fc" id="L480">				p = m_tree_hull.addElementAtPosition(k_prev, k, -2, true, false, -1); // set place holder to -2 for case 2.</span>
<span class="fc" id="L481">				treeHullWalkForward_(pt_pivot, k, last);</span>
<span class="fc" id="L482">				treeHullWalkBackward_(pt_pivot, k_prev, first);</span>

<span class="fc" id="L484">				continue;</span>
			}

<span class="pc bpc" id="L487" title="1 of 2 branches missed.">			assert (isDegenerate_(orient_m_p_0));</span>
			{// Case 3: degenerate
<span class="fc" id="L489">				int between = isBetween_(pt_pivot, pt_m, pt_0);</span>

<span class="fc bfc" id="L491" title="All 2 branches covered.">				if (between == -1) {</span>
<span class="fc" id="L492">					int l = m_tree_hull.getPrev(last);</span>
<span class="fc" id="L493">					m_tree_hull.deleteNode(last, -1);</span>
<span class="fc" id="L494">					p = m_tree_hull.addBiggestElement(-3, -1); // set place holder to -3 for case 3.</span>
<span class="fc" id="L495">					treeHullWalkBackward_(pt_pivot, l, first);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">				} else if (between == 1) {</span>
<span class="fc" id="L497">					int j = m_tree_hull.getNext(first);</span>
<span class="fc" id="L498">					m_tree_hull.deleteNode(first, -1);</span>
<span class="fc" id="L499">					p = m_tree_hull.addElementAtPosition(-1, j, -3, true, false, -1); // set place holder to -3 for case 3.</span>
<span class="fc" id="L500">					treeHullWalkForward_(pt_pivot, j, last);</span>
<span class="fc" id="L501">				}</span>

				continue;
			}

		} while (false);

<span class="fc" id="L508">		return p;</span>
	}

	private int treeHullWalkForward_(Point2D pt_pivot, int start, int end) {
<span class="fc bfc" id="L512" title="All 2 branches covered.">		if (start == end)</span>
<span class="fc" id="L513">			return end;</span>

<span class="fc" id="L515">		int j = start;</span>
<span class="fc" id="L516">		int tj = m_tree_hull.getElement(j);</span>
<span class="fc" id="L517">		int j_next = m_tree_hull.getNext(j);</span>
<span class="fc" id="L518">		Point2D pt_j = new Point2D();</span>
<span class="fc" id="L519">		Point2D pt_j_next = new Point2D();</span>

<span class="fc" id="L521">		m_call_back.getXY(tj, pt_j);</span>

<span class="pc bpc" id="L523" title="1 of 4 branches missed.">		while (j != end &amp;&amp; m_tree_hull.size(-1) &gt; 2) {//Stops when we find a clockwise triple containting the pivot point, or when the tree_hull size is 2. Deletes non-clockwise triples along the way.</span>
<span class="fc" id="L524">			int tj_next = m_tree_hull.getElement(j_next);</span>
<span class="fc" id="L525">			m_call_back.getXY(tj_next, pt_j_next);</span>

<span class="fc" id="L527">			int orient_j_next_p_j = Point2D.orientationRobust(pt_j_next, pt_pivot, pt_j);</span>

<span class="fc bfc" id="L529" title="All 2 branches covered.">			if (isClockwise_(orient_j_next_p_j))</span>
<span class="fc" id="L530">				break;</span>

<span class="fc" id="L532">			int ccw = j;</span>

<span class="fc" id="L534">			j = j_next;</span>
<span class="fc" id="L535">			pt_j.setCoords(pt_j_next);</span>
<span class="fc" id="L536">			j_next = m_tree_hull.getNext(j);</span>
<span class="fc" id="L537">			m_call_back.deleteNode(ccw);</span>
<span class="fc" id="L538">		}</span>

<span class="fc" id="L540">		return j;</span>
	}

	private int treeHullWalkBackward_(Point2D pt_pivot, int start, int end) {
<span class="fc bfc" id="L544" title="All 2 branches covered.">		if (start == end)</span>
<span class="fc" id="L545">			return end;</span>

<span class="fc" id="L547">		int l = start;</span>
<span class="fc" id="L548">		int tl = m_tree_hull.getElement(l);</span>
<span class="fc" id="L549">		int l_prev = m_tree_hull.getPrev(l);</span>
<span class="fc" id="L550">		Point2D pt_l = new Point2D();</span>
<span class="fc" id="L551">		Point2D pt_l_prev = new Point2D();</span>

<span class="fc" id="L553">		m_call_back.getXY(tl, pt_l);</span>

<span class="pc bpc" id="L555" title="1 of 4 branches missed.">		while (l != end &amp;&amp; m_tree_hull.size(-1) &gt; 2) {//Stops when we find a clockwise triple containting the pivot point, or when the tree_hull size is 2. Deletes non-clockwise triples along the way.</span>
<span class="fc" id="L556">			int tl_prev = m_tree_hull.getElement(l_prev);</span>
<span class="fc" id="L557">			m_call_back.getXY(tl_prev, pt_l_prev);</span>

<span class="fc" id="L559">			int orient_l_p_l_prev = Point2D.orientationRobust(pt_l, pt_pivot, pt_l_prev);</span>

<span class="fc bfc" id="L561" title="All 2 branches covered.">			if (isClockwise_(orient_l_p_l_prev))</span>
<span class="fc" id="L562">				break;</span>

<span class="fc" id="L564">			int ccw = l;</span>

<span class="fc" id="L566">			l = l_prev;</span>
<span class="fc" id="L567">			pt_l.setCoords(pt_l_prev);</span>
<span class="fc" id="L568">			l_prev = m_tree_hull.getPrev(l);</span>
<span class="fc" id="L569">			m_call_back.deleteNode(ccw);</span>
<span class="fc" id="L570">		}</span>

<span class="fc" id="L572">		return l;</span>
	}

	// Orientation predicates
	private static ECoordinate determinant_(Point2D p, Point2D q, Point2D r) {
<span class="fc" id="L577">		ECoordinate det_ec = new ECoordinate();</span>
<span class="fc" id="L578">		det_ec.set(q.x);</span>
<span class="fc" id="L579">		det_ec.sub(p.x);</span>

<span class="fc" id="L581">		ECoordinate rp_y_ec = new ECoordinate();</span>
<span class="fc" id="L582">		rp_y_ec.set(r.y);</span>
<span class="fc" id="L583">		rp_y_ec.sub(p.y);</span>

<span class="fc" id="L585">		ECoordinate qp_y_ec = new ECoordinate();</span>
<span class="fc" id="L586">		qp_y_ec.set(q.y);</span>
<span class="fc" id="L587">		qp_y_ec.sub(p.y);</span>

<span class="fc" id="L589">		ECoordinate rp_x_ec = new ECoordinate();</span>
<span class="fc" id="L590">		rp_x_ec.set(r.x);</span>
<span class="fc" id="L591">		rp_x_ec.sub(p.x);</span>

<span class="fc" id="L593">		det_ec.mul(rp_y_ec);</span>
<span class="fc" id="L594">		qp_y_ec.mul(rp_x_ec);</span>
<span class="fc" id="L595">		det_ec.sub(qp_y_ec);</span>
<span class="fc" id="L596">		return det_ec;</span>
	}

	private static boolean isClockwise_(double det) {
<span class="fc bfc" id="L600" title="All 2 branches covered.">		return det &lt; 0.0;</span>
	}

	private static boolean isCounterClockwise_(double det) {
<span class="nc bnc" id="L604" title="All 2 branches missed.">		return det &gt; 0.0;</span>
	}

	private static boolean isDegenerate_(double det) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">		return det == 0.0;</span>
	}

	private static boolean isClockwise_(int orientation) {
<span class="fc bfc" id="L612" title="All 2 branches covered.">		return orientation &lt; 0.0;</span>
	}

	private static boolean isCounterClockwise_(int orientation) {
<span class="fc bfc" id="L616" title="All 2 branches covered.">		return orientation &gt; 0.0;</span>
	}

	private static boolean isDegenerate_(int orientation) {
<span class="pc bpc" id="L620" title="1 of 2 branches missed.">		return orientation == 0.0;</span>
	}

	private static int isBetween_(Point2D pt_pivot, Point2D pt_m, Point2D pt_0) {
<span class="fc" id="L624">		int ordinate = -1;</span>

<span class="fc bfc" id="L626" title="All 2 branches covered.">		if (pt_m.y == pt_0.y) {</span>
<span class="fc" id="L627">			ordinate = 0;</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">		} else if (pt_m.x == pt_0.x) {</span>
<span class="fc" id="L629">			ordinate = 1;</span>
		} else {// use bigger ordinate, but shouldn't matter

<span class="fc" id="L632">			double diff_x = Math.abs(pt_m.x - pt_0.x);</span>
<span class="fc" id="L633">			double diff_y = Math.abs(pt_m.y - pt_0.y);</span>

<span class="fc bfc" id="L635" title="All 2 branches covered.">			if (diff_x &gt;= diff_y)</span>
<span class="fc" id="L636">				ordinate = 0;</span>
			else
<span class="fc" id="L638">				ordinate = 1;</span>
		}

<span class="fc" id="L641">		int res = -1;</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">		if (ordinate == 0) {</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">			assert (pt_m.x != pt_0.x);</span>

<span class="fc bfc" id="L646" title="All 2 branches covered.">			if (pt_m.x &lt; pt_0.x) {</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">				if (pt_pivot.x &lt; pt_m.x)</span>
<span class="fc" id="L648">					res = -1;</span>
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">				else if (pt_0.x &lt; pt_pivot.x)</span>
<span class="nc" id="L650">					res = 1;</span>
				else
<span class="fc" id="L652">					res = 0;</span>
			} else {
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">				assert (pt_0.x &lt; pt_m.x);</span>

<span class="fc bfc" id="L656" title="All 2 branches covered.">				if (pt_m.x &lt; pt_pivot.x)</span>
<span class="fc" id="L657">					res = -1;</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">				else if (pt_pivot.x &lt; pt_0.x)</span>
<span class="fc" id="L659">					res = 1;</span>
				else
<span class="fc" id="L661">					res = 0;</span>
			}
		} else {
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">			assert (pt_m.y != pt_0.y);</span>

<span class="fc bfc" id="L666" title="All 2 branches covered.">			if (pt_m.y &lt; pt_0.y) {</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">				if (pt_pivot.y &lt; pt_m.y)</span>
<span class="nc" id="L668">					res = -1;</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">				else if (pt_0.y &lt; pt_pivot.y)</span>
<span class="nc" id="L670">					res = 1;</span>
				else
<span class="fc" id="L672">					res = 0;</span>
			} else {
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">				assert (pt_0.y &lt; pt_m.y);</span>

<span class="fc bfc" id="L676" title="All 2 branches covered.">				if (pt_m.y &lt; pt_pivot.y)</span>
<span class="fc" id="L677">					res = -1;</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">				else if (pt_pivot.y &lt; pt_0.y)</span>
<span class="nc" id="L679">					res = 1;</span>
				else
<span class="fc" id="L681">					res = 0;</span>
			}
		}

<span class="fc" id="L685">		return res;</span>
	}

	private static abstract class CallBack {
		abstract void getXY(int ti, Point2D pt);

		abstract void deleteNode(int i);
	}

	private static final class CallBackShape extends CallBack {
		private ConvexHull m_convex_hull;

<span class="fc" id="L697">		CallBackShape(ConvexHull convex_hull) {</span>
<span class="fc" id="L698">			m_convex_hull = convex_hull;</span>
<span class="fc" id="L699">		}</span>

		@Override
		void getXY(int ti, Point2D pt) {
<span class="fc" id="L703">			m_convex_hull.m_shape.getXY(ti, pt);</span>
<span class="fc" id="L704">		}</span>

		@Override
		void deleteNode(int i) {
<span class="fc" id="L708">			int ti = m_convex_hull.m_tree_hull.getElement(i);</span>
<span class="fc" id="L709">			m_convex_hull.m_tree_hull.deleteNode(i, -1);</span>
<span class="fc" id="L710">			m_convex_hull.m_shape.removeVertex(ti, false);</span>
<span class="fc" id="L711">		}</span>
	}

	private static final class CallBackStream extends CallBack {
		private ConvexHull m_convex_hull;

<span class="fc" id="L717">		CallBackStream(ConvexHull convex_hull) {</span>
<span class="fc" id="L718">			m_convex_hull = convex_hull;</span>
<span class="fc" id="L719">		}</span>

		@Override
		void getXY(int ti, Point2D pt) {
<span class="fc" id="L723">			m_convex_hull.m_stream.read(ti &lt;&lt; 1, pt);</span>
<span class="fc" id="L724">		}</span>

		@Override
		void deleteNode(int i) {
<span class="fc" id="L728">			m_convex_hull.m_tree_hull.deleteNode(i, -1);</span>
<span class="fc" id="L729">		}</span>
	}

	private static final class CallBackPoints extends CallBack {
		private ConvexHull m_convex_hull;

<span class="fc" id="L735">		CallBackPoints(ConvexHull convex_hull) {</span>
<span class="fc" id="L736">			m_convex_hull = convex_hull;</span>
<span class="fc" id="L737">		}</span>

		@Override
		void getXY(int ti, Point2D pt) {
<span class="fc" id="L741">			pt.setCoords(m_convex_hull.m_points[ti]);</span>
<span class="fc" id="L742">		}</span>

		@Override
		void deleteNode(int i) {
<span class="nc" id="L746">			m_convex_hull.m_tree_hull.deleteNode(i, -1);</span>
<span class="nc" id="L747">		}</span>
	}

	// Members
	private Treap m_tree_hull;
	private EditShape m_shape;
	private AttributeStreamOfDbl m_stream;
	private Point2D[] m_points;
	private int m_geometry_handle;
	private int m_path_handle;
	private Line m_line;
	private CallBack m_call_back;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>