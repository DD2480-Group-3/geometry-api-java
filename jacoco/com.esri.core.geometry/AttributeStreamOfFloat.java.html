<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AttributeStreamOfFloat.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">AttributeStreamOfFloat.java</span></div><h1>AttributeStreamOfFloat.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2017 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */


package com.esri.core.geometry;

import com.esri.core.geometry.VertexDescription.Persistence;

import java.nio.ByteBuffer;

import static com.esri.core.geometry.SizeOf.SIZE_OF_ATTRIBUTE_STREAM_OF_FLOAT;
import static com.esri.core.geometry.SizeOf.sizeOfFloatArray;

final class AttributeStreamOfFloat extends AttributeStreamBase {
<span class="nc" id="L36">	private float[] m_buffer = null;</span>
	private int m_size;

	public int size() {
<span class="nc" id="L40">		return m_size;</span>
	}

	public void reserve(int reserve)// only in Java
	{
<span class="nc bnc" id="L45" title="All 2 branches missed.">		if (reserve &lt;= 0)</span>
<span class="nc" id="L46">			return;</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">		if (m_buffer == null)</span>
<span class="nc" id="L48">			m_buffer = new float[reserve];</span>
		else {
<span class="nc bnc" id="L50" title="All 2 branches missed.">			if (reserve &lt;= m_buffer.length)</span>
<span class="nc" id="L51">				return;</span>
<span class="nc" id="L52">			float[] buf = new float[reserve];</span>
<span class="nc" id="L53">			System.arraycopy(m_buffer, 0, buf, 0, m_size);</span>
<span class="nc" id="L54">			m_buffer = buf;</span>
		}

<span class="nc" id="L57">	}</span>

	public int capacity() {
<span class="nc bnc" id="L60" title="All 2 branches missed.">		return m_buffer != null ? m_buffer.length : 0;</span>
	}
	
<span class="nc" id="L63">	public AttributeStreamOfFloat(int size) {</span>
<span class="nc" id="L64">		int sz = size;</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">		if (sz &lt; 2)</span>
<span class="nc" id="L66">			sz = 2;</span>
<span class="nc" id="L67">		m_buffer = new float[sz];</span>
<span class="nc" id="L68">		m_size = size;</span>
<span class="nc" id="L69">	}</span>

<span class="nc" id="L71">	public AttributeStreamOfFloat(int size, float defaultValue) {</span>
<span class="nc" id="L72">		int sz = size;</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">		if (sz &lt; 2)</span>
<span class="nc" id="L74">			sz = 2;</span>
<span class="nc" id="L75">		m_buffer = new float[sz];</span>
<span class="nc" id="L76">		m_size = size;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">		for (int i = 0; i &lt; size; i++)</span>
<span class="nc" id="L78">			m_buffer[i] = defaultValue;</span>
<span class="nc" id="L79">	}</span>

<span class="nc" id="L81">	public AttributeStreamOfFloat(AttributeStreamOfFloat other) {</span>
<span class="nc" id="L82">		m_buffer = other.m_buffer.clone();</span>
<span class="nc" id="L83">		m_size = other.m_size;</span>
<span class="nc" id="L84">	}</span>

<span class="nc" id="L86">	public AttributeStreamOfFloat(AttributeStreamOfFloat other, int maxSize) {</span>
<span class="nc" id="L87">		m_size = other.size();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">		if (m_size &gt; maxSize)</span>
<span class="nc" id="L89">			m_size = maxSize;</span>
<span class="nc" id="L90">		int sz = m_size;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (sz &lt; 2)</span>
<span class="nc" id="L92">			sz = 2;</span>
<span class="nc" id="L93">		m_buffer = new float[sz];</span>
<span class="nc" id="L94">		System.arraycopy(other.m_buffer, 0, m_buffer, 0, m_size);</span>
<span class="nc" id="L95">	}</span>

	/**
	 * Reads a value from the buffer at given offset.
	 * 
	 * @param offset
	 *            is the element number in the stream.
	 */
	public float read(int offset) {
<span class="nc" id="L104">		return m_buffer[offset];</span>
	}

	/**
	 * Overwrites given element with new value.
	 * 
	 * @param offset
	 *            is the element number in the stream.
	 * @param value
	 *            is the value to write.
	 */
	public void write(int offset, float value) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">		if (m_bReadonly) {</span>
<span class="nc" id="L117">			throw new RuntimeException(&quot;invalid_call&quot;);</span>
		}
<span class="nc" id="L119">		m_buffer[offset] = value;</span>
<span class="nc" id="L120">	}</span>

	/**
	 * Adds a new value at the end of the stream.
	 * 
	 * @param offset
	 *            is the element number in the stream.
	 * @param value
	 *            is the value to write.
	 */
	public void add(float v) {
<span class="nc" id="L131">		resize(m_size + 1);</span>
<span class="nc" id="L132">		m_buffer[m_size - 1] = v;</span>
<span class="nc" id="L133">	}</span>

	@Override
	public AttributeStreamBase restrictedClone(int maxsize) {
<span class="nc" id="L137">		int len = m_size;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">		int newSize = maxsize &lt; len ? maxsize : len;</span>
<span class="nc" id="L139">		float[] newBuffer = new float[newSize];</span>
<span class="nc" id="L140">		System.arraycopy(m_buffer, 0, newBuffer, 0, newSize);</span>
<span class="nc" id="L141">		m_buffer = newBuffer;</span>
<span class="nc" id="L142">		m_size = newSize;</span>
<span class="nc" id="L143">		return this;</span>
	}

	@Override
	public int virtualSize() {
<span class="nc" id="L148">		return size();</span>
	}

	@Override
	public long estimateMemorySize()
	{
<span class="nc" id="L154">		return SIZE_OF_ATTRIBUTE_STREAM_OF_FLOAT + sizeOfFloatArray(m_buffer.length);</span>
	}

	@Override
	public int getPersistence() {
<span class="nc" id="L159">		return Persistence.enumFloat;</span>
	}

	@Override
	public double readAsDbl(int offset) {
<span class="nc" id="L164">		return read(offset);</span>
	}

	@Override
	public int readAsInt(int offset) {
<span class="nc" id="L169">		return (int) read(offset);</span>
	}

	@Override
	public long readAsInt64(int offset) {
<span class="nc" id="L174">		return (long) read(offset);</span>
	}

	@Override
	public void resize(int newSize) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">		if (m_bLockedInSize)</span>
<span class="nc" id="L180">			throw new GeometryException(</span>
					&quot;invalid call. Attribute Stream is locked and cannot be resized.&quot;);

<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (newSize &lt;= m_size) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">			if ((newSize * 5) / 4 &lt; m_buffer.length) {// decrease when the 25%</span>
														// margin is exceeded
<span class="nc" id="L186">				float[] newBuffer = new float[newSize];</span>
<span class="nc" id="L187">				System.arraycopy(m_buffer, 0, newBuffer, 0, newSize);</span>
<span class="nc" id="L188">				m_buffer = newBuffer;</span>
			}
<span class="nc" id="L190">			m_size = newSize;</span>
		} else {
<span class="nc bnc" id="L192" title="All 2 branches missed.">			if (newSize &gt; m_buffer.length) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">				int sz = (newSize &lt; 64) ? Math.max(newSize * 2, 4)</span>
<span class="nc" id="L194">						: (newSize * 5) / 4;</span>
<span class="nc" id="L195">				float[] newBuffer = new float[sz];</span>
<span class="nc" id="L196">				System.arraycopy(m_buffer, 0, newBuffer, 0, m_size);</span>
<span class="nc" id="L197">				m_buffer = newBuffer;</span>
			}

<span class="nc" id="L200">			m_size = newSize;</span>
		}
<span class="nc" id="L202">	}</span>

	@Override
	public void resizePreserveCapacity(int newSize)// java only method
	{
<span class="nc bnc" id="L207" title="All 4 branches missed.">		if (m_buffer == null || newSize &gt; m_buffer.length)</span>
<span class="nc" id="L208">			resize(newSize);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">		if (m_bLockedInSize)</span>
<span class="nc" id="L210">			throw new GeometryException(</span>
					&quot;invalid call. Attribute Stream is locked and cannot be resized.&quot;);

<span class="nc" id="L213">		m_size = newSize;</span>
<span class="nc" id="L214">	}</span>

	@Override
	public void resize(int newSize, double defaultValue) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">		if (m_bLockedInSize)</span>
<span class="nc" id="L219">			throw new GeometryException(</span>
					&quot;invalid call. Attribute Stream is locked and cannot be resized.&quot;);
<span class="nc bnc" id="L221" title="All 2 branches missed.">		if (newSize &lt;= m_size) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">			if ((newSize * 5) / 4 &lt; m_buffer.length) {// decrease when the 25%</span>
														// margin is exceeded
<span class="nc" id="L224">				float[] newBuffer = new float[newSize];</span>
<span class="nc" id="L225">				System.arraycopy(m_buffer, 0, newBuffer, 0, newSize);</span>
<span class="nc" id="L226">				m_buffer = newBuffer;</span>
			}
<span class="nc" id="L228">			m_size = newSize;</span>
		} else {
<span class="nc bnc" id="L230" title="All 2 branches missed.">			if (newSize &gt; m_buffer.length) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">				int sz = (newSize &lt; 64) ? Math.max(newSize * 2, 4)</span>
<span class="nc" id="L232">						: (newSize * 5) / 4;</span>
<span class="nc" id="L233">				float[] newBuffer = new float[sz];</span>
<span class="nc" id="L234">				System.arraycopy(m_buffer, 0, newBuffer, 0, m_size);</span>
<span class="nc" id="L235">				m_buffer = newBuffer;</span>
			}

<span class="nc bnc" id="L238" title="All 2 branches missed.">			for (int i = m_size; i &lt; newSize; i++)</span>
<span class="nc" id="L239">				m_buffer[i] = (float) defaultValue;</span>

<span class="nc" id="L241">			m_size = newSize;</span>
		}
<span class="nc" id="L243">	}</span>

	@Override
	public void writeAsDbl(int offset, double d) {
<span class="nc" id="L247">		write(offset, (float) d);</span>
<span class="nc" id="L248">	}</span>

	@Override
	public void writeAsInt64(int offset, long d) {
<span class="nc" id="L252">		write(offset, (float) d);</span>
<span class="nc" id="L253">	}</span>

	@Override
	public void writeAsInt(int offset, int d) {
<span class="nc" id="L257">		write(offset, (float) d);</span>
<span class="nc" id="L258">	}</span>

	// @Override
	// public void writeRange(int srcStart, int count, ByteBuffer dst,
	// int dstOffsetBytes) {
	// // TODO Auto-generated method stub
	//
	// }

	@Override
	public int calculateHashImpl(int hashCode, int start, int end) {
<span class="nc bnc" id="L269" title="All 4 branches missed.">		for (int i = start, n = size(); i &lt; n &amp;&amp; i &lt; end; i++)</span>
<span class="nc" id="L270">			hashCode = NumberUtils.hash(hashCode, read(i));</span>

<span class="nc" id="L272">		return hashCode;</span>
	}

	@Override
	public boolean equals(AttributeStreamBase other, int start, int end) {
<span class="nc bnc" id="L277" title="All 2 branches missed.">		if (other == null)</span>
<span class="nc" id="L278">			return false;</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">		if (!(other instanceof AttributeStreamOfFloat))</span>
<span class="nc" id="L281">			return false;</span>

<span class="nc" id="L283">		AttributeStreamOfFloat _other = (AttributeStreamOfFloat) other;</span>

<span class="nc" id="L285">		int size = size();</span>
<span class="nc" id="L286">		int sizeOther = _other.size();</span>

<span class="nc bnc" id="L288" title="All 6 branches missed.">		if (end &gt; size || end &gt; sizeOther &amp;&amp; (size != sizeOther))</span>
<span class="nc" id="L289">			return false;</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">		if (end &gt; size)</span>
<span class="nc" id="L292">			end = size;</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">		for (int i = start; i &lt; end; i++)</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">			if (read(i) != _other.read(i))</span>
<span class="nc" id="L296">				return false;</span>

<span class="nc" id="L298">		return true;</span>
	}

	// public void addRange(AttributeStreamBase src, int srcStartIndex, int
	// count) {
	// if ((src == this) || !(src instanceof AttributeStreamOfFloat))
	// throw new IllegalArgumentException();
	//
	// AttributeStreamOfFloat as = (AttributeStreamOfFloat) src;
	//
	// int len = as.size();
	// int oldSize = m_size;
	// resize(oldSize + len, 0);
	// for (int i = 0; i &lt; len; i++) {
	// m_buffer[oldSize + i] = as.read(i);
	// }
	// }

	@Override
	public void addRange(AttributeStreamBase src, int start, int count,
			boolean bForward, int stride) {
<span class="nc bnc" id="L319" title="All 2 branches missed.">		if (m_bReadonly)</span>
<span class="nc" id="L320">			throw new GeometryException(&quot;invalid_call&quot;);</span>

<span class="nc bnc" id="L322" title="All 6 branches missed.">		if (!bForward &amp;&amp; (stride &lt; 1 || count % stride != 0))</span>
<span class="nc" id="L323">			throw new IllegalArgumentException();</span>

<span class="nc" id="L325">		int oldSize = m_size;</span>
<span class="nc" id="L326">		int newSize = oldSize + count;</span>
<span class="nc" id="L327">		resize(newSize);</span>

<span class="nc bnc" id="L329" title="All 2 branches missed.">		if (bForward) {</span>
<span class="nc" id="L330">			System.arraycopy(((AttributeStreamOfFloat) src).m_buffer, start,</span>
					m_buffer, oldSize, count);
		} else {
<span class="nc" id="L333">			int n = count;</span>

<span class="nc bnc" id="L335" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i += stride) {</span>
<span class="nc" id="L336">				n -= stride;</span>

<span class="nc bnc" id="L338" title="All 2 branches missed.">				for (int s = 0; s &lt; stride; s++) {</span>
<span class="nc" id="L339">					m_buffer[oldSize + i + s] = ((AttributeStreamOfFloat) src).m_buffer[start</span>
							+ n + s];
				}
			}
		}
<span class="nc" id="L344">	}</span>

	@Override
	public void insertRange(int start, AttributeStreamBase src, int srcStart,
			int count, boolean bForward, int stride, int validSize) {
<span class="nc bnc" id="L349" title="All 2 branches missed.">		if (m_bReadonly)</span>
<span class="nc" id="L350">			throw new GeometryException(&quot;invalid_call&quot;);</span>

<span class="nc bnc" id="L352" title="All 6 branches missed.">		if (!bForward &amp;&amp; (stride &lt; 1 || count % stride != 0))</span>
<span class="nc" id="L353">			throw new IllegalArgumentException();</span>

<span class="nc" id="L355">		System.arraycopy(m_buffer, start, m_buffer, start + count, validSize</span>
				- start);

<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (m_buffer == ((AttributeStreamOfFloat) src).m_buffer) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">			if (start &lt; srcStart)</span>
<span class="nc" id="L360">				srcStart += count;</span>
		}

<span class="nc bnc" id="L363" title="All 2 branches missed.">		if (bForward) {</span>
<span class="nc" id="L364">			System.arraycopy(((AttributeStreamOfFloat) src).m_buffer, srcStart,</span>
					m_buffer, start, count);
		} else {
<span class="nc" id="L367">			int n = count;</span>

<span class="nc bnc" id="L369" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i += stride) {</span>
<span class="nc" id="L370">				n -= stride;</span>

<span class="nc bnc" id="L372" title="All 2 branches missed.">				for (int s = 0; s &lt; stride; s++) {</span>
<span class="nc" id="L373">					m_buffer[start + i + s] = ((AttributeStreamOfFloat) src).m_buffer[srcStart</span>
							+ n + s];
				}
			}
		}
<span class="nc" id="L378">	}</span>

	@Override
	public void insertRange(int start, double value, int count, int validSize) {
<span class="nc bnc" id="L382" title="All 2 branches missed.">		if (m_bReadonly)</span>
<span class="nc" id="L383">			throw new GeometryException(&quot;invalid_call&quot;);</span>

<span class="nc" id="L385">		System.arraycopy(m_buffer, start, m_buffer, start + count, validSize</span>
				- start);

<span class="nc" id="L388">		float v = (float) value;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">		for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L390">			m_buffer[start + i] = v;</span>
		}
<span class="nc" id="L392">	}</span>

	@Override
	public void insertAttributes(int start, Point pt, int semantics,
			int validSize) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">		if (m_bReadonly)</span>
<span class="nc" id="L398">			throw new GeometryException(&quot;invalid_call&quot;);</span>

<span class="nc" id="L400">		int comp = VertexDescription.getComponentCount(semantics);</span>

<span class="nc" id="L402">		System.arraycopy(m_buffer, start, m_buffer, start + comp, validSize</span>
				- start);

<span class="nc bnc" id="L405" title="All 2 branches missed.">		for (int c = 0; c &lt; comp; c++) {</span>
<span class="nc" id="L406">			m_buffer[start + c] = (float) pt.getAttributeAsDbl(semantics, c);</span>
		}
<span class="nc" id="L408">	}</span>

	@Override
	public void eraseRange(int index, int count, int validSize) {
<span class="nc bnc" id="L412" title="All 2 branches missed.">		if (m_bReadonly)</span>
<span class="nc" id="L413">			throw new GeometryException(&quot;invalid_call&quot;);</span>

<span class="nc bnc" id="L415" title="All 2 branches missed.">		if (index + count &gt; m_size)</span>
<span class="nc" id="L416">			throw new GeometryException(&quot;invalid_call&quot;);</span>

<span class="nc" id="L418">		System.arraycopy(m_buffer, index + count, m_buffer, index, validSize</span>
				- (index + count));
<span class="nc" id="L420">		m_size -= count;</span>
<span class="nc" id="L421">	}</span>

	@Override
	public void readRange(int srcStart, int count, ByteBuffer dst,
			int dstOffset, boolean bForward) {
<span class="nc bnc" id="L426" title="All 6 branches missed.">		if (srcStart &lt; 0 || count &lt; 0 || dstOffset &lt; 0</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">				|| size() &lt; count + srcStart)</span>
<span class="nc" id="L428">			throw new IllegalArgumentException();</span>

<span class="nc" id="L430">		final int elmSize = NumberUtils.sizeOf((double) 0);</span>

<span class="nc bnc" id="L432" title="All 2 branches missed.">		if (dst.capacity() &lt; (int) (dstOffset + elmSize * count))</span>
<span class="nc" id="L433">			throw new IllegalArgumentException();</span>

<span class="nc bnc" id="L435" title="All 2 branches missed.">		if (count == 0)</span>
<span class="nc" id="L436">			return;</span>

<span class="nc" id="L438">		int j = srcStart;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">		if (!bForward)</span>
<span class="nc" id="L440">			j += count - 1;</span>

<span class="nc bnc" id="L442" title="All 2 branches missed.">		final int dj = bForward ? 1 : -1;</span>

<span class="nc" id="L444">		int offset = dstOffset;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">		for (int i = 0; i &lt; count; i++, offset += elmSize) {</span>
<span class="nc" id="L446">			dst.putFloat(offset, m_buffer[j]);</span>
<span class="nc" id="L447">			j += dj;</span>
		}

<span class="nc" id="L450">	}</span>

	@Override
	public void reverseRange(int index, int count, int stride) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">		if (m_bReadonly)</span>
<span class="nc" id="L455">			throw new GeometryException(&quot;invalid_call&quot;);</span>

<span class="nc bnc" id="L457" title="All 4 branches missed.">		if (stride &lt; 1 || count % stride != 0)</span>
<span class="nc" id="L458">			throw new GeometryException(&quot;invalid_call&quot;);</span>

<span class="nc" id="L460">		int cIterations = count &gt;&gt; 1;</span>
<span class="nc" id="L461">		int n = count;</span>

<span class="nc bnc" id="L463" title="All 2 branches missed.">		for (int i = 0; i &lt; cIterations; i += stride) {</span>
<span class="nc" id="L464">			n -= stride;</span>

<span class="nc bnc" id="L466" title="All 2 branches missed.">			for (int s = 0; s &lt; stride; s++) {</span>
<span class="nc" id="L467">				float temp = m_buffer[index + i + s];</span>
<span class="nc" id="L468">				m_buffer[index + i + s] = m_buffer[index + n + s];</span>
<span class="nc" id="L469">				m_buffer[index + n + s] = temp;</span>
			}
		}
<span class="nc" id="L472">	}</span>

	@Override
	public void setRange(double value, int start, int count) {
<span class="nc bnc" id="L476" title="All 8 branches missed.">		if (start &lt; 0 || count &lt; 0 || start &lt; 0 || count + start &gt; size())</span>
<span class="nc" id="L477">			throw new IllegalArgumentException();</span>

<span class="nc" id="L479">		float v = (float) value;</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">		for (int i = start, n = start + count; i &lt; n; i++)</span>
<span class="nc" id="L481">			write(i, v);</span>
<span class="nc" id="L482">	}</span>

	@Override
	public void writeRange(int startElement, int count,
			AttributeStreamBase _src, int srcStart, boolean bForward, int stride) {
<span class="nc bnc" id="L487" title="All 6 branches missed.">		if (startElement &lt; 0 || count &lt; 0 || srcStart &lt; 0)</span>
<span class="nc" id="L488">			throw new IllegalArgumentException();</span>

<span class="nc bnc" id="L490" title="All 6 branches missed.">		if (!bForward &amp;&amp; (stride &lt;= 0 || (count % stride != 0)))</span>
<span class="nc" id="L491">			throw new IllegalArgumentException();</span>

<span class="nc" id="L493">		AttributeStreamOfFloat src = (AttributeStreamOfFloat) _src; // the input</span>
																	// type must
																	// match

<span class="nc bnc" id="L497" title="All 2 branches missed.">		if (src.size() &lt; (int) (srcStart + count))</span>
<span class="nc" id="L498">			throw new IllegalArgumentException();</span>

<span class="nc bnc" id="L500" title="All 2 branches missed.">		if (count == 0)</span>
<span class="nc" id="L501">			return;</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">		if (size() &lt; count + startElement)</span>
<span class="nc" id="L504">			resize(count + startElement);</span>

<span class="nc bnc" id="L506" title="All 2 branches missed.">		if (_src == (AttributeStreamBase) this) {</span>
<span class="nc" id="L507">			_selfWriteRangeImpl(startElement, count, srcStart, bForward, stride);</span>
<span class="nc" id="L508">			return;</span>
		}

<span class="nc bnc" id="L511" title="All 2 branches missed.">		if (bForward) {</span>
<span class="nc" id="L512">			int j = startElement;</span>
<span class="nc" id="L513">			int offset = srcStart;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L515">				m_buffer[j] = src.m_buffer[offset];</span>
<span class="nc" id="L516">				j++;</span>
<span class="nc" id="L517">				offset++;</span>
			}
<span class="nc" id="L519">		} else {</span>
<span class="nc" id="L520">			int j = startElement;</span>
<span class="nc" id="L521">			int offset = srcStart + count - stride;</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">			if (stride == 1) {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">				for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L524">					m_buffer[j] = src.m_buffer[offset];</span>
<span class="nc" id="L525">					j++;</span>
<span class="nc" id="L526">					offset--;</span>
				}
			} else {
<span class="nc bnc" id="L529" title="All 2 branches missed.">				for (int i = 0, n = count / stride; i &lt; n; i++) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">					for (int k = 0; k &lt; stride; k++)</span>
<span class="nc" id="L531">						m_buffer[j + k] = src.m_buffer[offset + k];</span>

<span class="nc" id="L533">					j += stride;</span>
<span class="nc" id="L534">					offset -= stride;</span>
				}
			}
		}
<span class="nc" id="L538">	}</span>

	private void _selfWriteRangeImpl(int toElement, int count, int fromElement,
			boolean bForward, int stride) {

		// writing from to this stream.
<span class="nc bnc" id="L544" title="All 2 branches missed.">		if (bForward) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">			if (toElement == fromElement)</span>
<span class="nc" id="L546">				return;</span>
		}

		int offset;
		int j;
		int dj;

<span class="nc bnc" id="L553" title="All 2 branches missed.">		if (fromElement &lt; toElement) {</span>
<span class="nc" id="L554">			offset = fromElement + count - stride;</span>
<span class="nc" id="L555">			j = toElement + count - stride;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">			for (int i = 0, n = count / 2; i &lt; n; i++) {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">				for (int k = 0; k &lt; stride; k++) {</span>
<span class="nc" id="L558">					m_buffer[j + k] = m_buffer[offset + k];</span>
				}
<span class="nc" id="L560">				j -= stride;</span>
<span class="nc" id="L561">				offset -= stride;</span>
			}
		} else {
<span class="nc" id="L564">			offset = fromElement;</span>
<span class="nc" id="L565">			j = toElement;</span>
<span class="nc" id="L566">			dj = 1;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">			for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L568">				m_buffer[j] = m_buffer[offset];</span>
<span class="nc" id="L569">				j += 1;</span>
<span class="nc" id="L570">				offset++;</span>
			}
		}

<span class="nc bnc" id="L574" title="All 2 branches missed.">		if (!bForward) {</span>
			// reverse what we written
<span class="nc" id="L576">			j = toElement;</span>
<span class="nc" id="L577">			offset = toElement + count - stride;</span>
<span class="nc" id="L578">			dj = stride;</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">			for (int i = 0, n = count / 2; i &lt; n; i++) {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">				for (int k = 0; k &lt; stride; k++) {</span>
<span class="nc" id="L581">					float v = m_buffer[j + k];</span>
<span class="nc" id="L582">					m_buffer[j + k] = m_buffer[offset + k];</span>
<span class="nc" id="L583">					m_buffer[offset + k] = v;</span>
				}
<span class="nc" id="L585">				j += stride;</span>
<span class="nc" id="L586">				offset -= stride;</span>
			}
		}
<span class="nc" id="L589">	}</span>

	@Override
	public void writeRange(int startElement, int count, ByteBuffer src,
			int offsetBytes, boolean bForward) {
<span class="nc bnc" id="L594" title="All 6 branches missed.">		if (startElement &lt; 0 || count &lt; 0 || offsetBytes &lt; 0)</span>
<span class="nc" id="L595">			throw new IllegalArgumentException();</span>

<span class="nc" id="L597">		final int elmSize = NumberUtils.sizeOf((double) 0);</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">		if (src.capacity() &lt; (int) (offsetBytes + elmSize * count))</span>
<span class="nc" id="L599">			throw new IllegalArgumentException();</span>

<span class="nc bnc" id="L601" title="All 2 branches missed.">		if (count == 0)</span>
<span class="nc" id="L602">			return;</span>

<span class="nc bnc" id="L604" title="All 2 branches missed.">		if (size() &lt; count + startElement)</span>
<span class="nc" id="L605">			resize(count + startElement);</span>

<span class="nc" id="L607">		int j = startElement;</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">		if (!bForward)</span>
<span class="nc" id="L609">			j += count - 1;</span>

<span class="nc bnc" id="L611" title="All 2 branches missed.">		final int dj = bForward ? 1 : -1;</span>

<span class="nc" id="L613">		int offset = offsetBytes;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">		for (int i = 0; i &lt; count; i++, offset += elmSize) {</span>
<span class="nc" id="L615">			m_buffer[j] = src.getFloat(offset);</span>
<span class="nc" id="L616">			j += dj;</span>
		}

<span class="nc" id="L619">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>