<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OperatorExportToWktLocal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">OperatorExportToWktLocal.java</span></div><h1>OperatorExportToWktLocal.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2015 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */
package com.esri.core.geometry;

<span class="fc" id="L26">class OperatorExportToWktLocal extends OperatorExportToWkt {</span>
	@Override
	public String execute(int export_flags, Geometry geometry,
			ProgressTracker progress_tracker) {
<span class="fc" id="L30">		StringBuilder string = new StringBuilder();</span>
<span class="fc" id="L31">		exportToWkt(export_flags, geometry, string);</span>

<span class="fc" id="L33">		return string.toString();</span>
	}

	static void exportToWkt(int export_flags, Geometry geometry,
			StringBuilder string) {
<span class="fc" id="L38">		int type = geometry.getType().value();</span>
<span class="pc bpc" id="L39" title="1 of 6 branches missed.">		switch (type) {</span>
		case Geometry.GeometryType.Polygon:
<span class="pc bpc" id="L41" title="4 of 8 branches missed.">			if ((export_flags &amp; WktExportFlags.wktExportLineString) != 0</span>
					|| (export_flags &amp; WktExportFlags.wktExportMultiLineString) != 0
					|| (export_flags &amp; WktExportFlags.wktExportPoint) != 0
					|| (export_flags &amp; WktExportFlags.wktExportMultiPoint) != 0)
<span class="nc" id="L45">				throw new IllegalArgumentException(&quot;Cannot export a Polygon as (Multi)LineString/(Multi)Point : &quot;+export_flags);</span>

<span class="fc" id="L47">			exportPolygonToWkt(export_flags, (Polygon) geometry, string);</span>
<span class="fc" id="L48">			return;</span>

		case Geometry.GeometryType.Polyline:
<span class="pc bpc" id="L51" title="4 of 8 branches missed.">			if ((export_flags &amp; WktExportFlags.wktExportPolygon) != 0</span>
					|| (export_flags &amp; WktExportFlags.wktExportMultiPolygon) != 0
					|| (export_flags &amp; WktExportFlags.wktExportPoint) != 0
					|| (export_flags &amp; WktExportFlags.wktExportMultiPoint) != 0)
<span class="nc" id="L55">				throw new IllegalArgumentException(&quot;Cannot export a Polyline as (Multi)Polygon/(Multi)Point : &quot;+export_flags);</span>

<span class="fc" id="L57">			exportPolylineToWkt(export_flags, (Polyline) geometry, string);</span>
<span class="fc" id="L58">			return;</span>

		case Geometry.GeometryType.MultiPoint:
<span class="pc bpc" id="L61" title="4 of 8 branches missed.">			if ((export_flags &amp; WktExportFlags.wktExportLineString) != 0</span>
					|| (export_flags &amp; WktExportFlags.wktExportMultiLineString) != 0
					|| (export_flags &amp; WktExportFlags.wktExportPolygon) != 0
					|| (export_flags &amp; WktExportFlags.wktExportMultiPolygon) != 0)
<span class="nc" id="L65">				throw new IllegalArgumentException(&quot;Cannot export a MultiPoint as (Multi)LineString/(Multi)Polygon: &quot;+export_flags);</span>

<span class="fc" id="L67">			exportMultiPointToWkt(export_flags, (MultiPoint) geometry, string);</span>
<span class="fc" id="L68">			return;</span>

		case Geometry.GeometryType.Point:
<span class="pc bpc" id="L71" title="4 of 8 branches missed.">			if ((export_flags &amp; WktExportFlags.wktExportLineString) != 0</span>
					|| (export_flags &amp; WktExportFlags.wktExportMultiLineString) != 0
					|| (export_flags &amp; WktExportFlags.wktExportPolygon) != 0
					|| (export_flags &amp; WktExportFlags.wktExportMultiPolygon) != 0)
<span class="nc" id="L75">				throw new IllegalArgumentException(&quot;Cannot export a Point as (Multi)LineString/(Multi)Polygon: &quot;+export_flags);</span>

<span class="fc" id="L77">			exportPointToWkt(export_flags, (Point) geometry, string);</span>
<span class="fc" id="L78">			return;</span>

		case Geometry.GeometryType.Envelope:
<span class="pc bpc" id="L81" title="4 of 8 branches missed.">			if ((export_flags &amp; WktExportFlags.wktExportLineString) != 0</span>
					|| (export_flags &amp; WktExportFlags.wktExportMultiLineString) != 0
					|| (export_flags &amp; WktExportFlags.wktExportPoint) != 0
					|| (export_flags &amp; WktExportFlags.wktExportMultiPoint) != 0)
<span class="nc" id="L85">				throw new IllegalArgumentException(&quot;Cannot export an Envelope as (Multi)LineString/(Multi)Point: &quot;+export_flags);</span>

<span class="fc" id="L87">			exportEnvelopeToWkt(export_flags, (Envelope) geometry, string);</span>
<span class="fc" id="L88">			return;</span>

		default: {
<span class="nc" id="L91">			throw GeometryException.GeometryInternalError();</span>
		}
		}
	}

	static void exportPolygonToWkt(int export_flags, Polygon polygon,
			StringBuilder string) {
<span class="fc" id="L98">		MultiPathImpl polygon_impl = (MultiPathImpl) polygon._getImpl();</span>

<span class="pc bpc" id="L100" title="1 of 2 branches missed.">		if ((export_flags &amp; WktExportFlags.wktExportFailIfNotSimple) != 0) {</span>
<span class="nc" id="L101">			int simple = polygon_impl.getIsSimple(0.0);</span>

<span class="nc bnc" id="L103" title="All 2 branches missed.">			if (simple != MultiPathImpl.GeometryXSimple.Strong)</span>
<span class="nc" id="L104">				throw new GeometryException(&quot;corrupted geometry&quot;);</span>
		}

<span class="fc" id="L107">		int point_count = polygon.getPointCount();</span>
<span class="fc" id="L108">		int polygon_count = polygon_impl.getOGCPolygonCount();</span>

<span class="pc bpc" id="L110" title="1 of 4 branches missed.">		if (point_count &gt; 0 &amp;&amp; polygon_count == 0)</span>
<span class="nc" id="L111">			throw new GeometryException(&quot;corrupted geometry&quot;);</span>

<span class="fc" id="L113">		int precision = 17 - (7 &amp; (export_flags &gt;&gt; 13));</span>
<span class="fc" id="L114">		boolean b_export_zs = polygon_impl</span>
<span class="pc bpc" id="L115" title="1 of 4 branches missed.">				.hasAttribute(VertexDescription.Semantics.Z)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripZs) == 0;
<span class="fc" id="L117">		boolean b_export_ms = polygon_impl</span>
<span class="pc bpc" id="L118" title="1 of 4 branches missed.">				.hasAttribute(VertexDescription.Semantics.M)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripMs) == 0;

<span class="fc" id="L121">		int path_count = 0;</span>
<span class="fc" id="L122">		AttributeStreamOfDbl position = null;</span>
<span class="fc" id="L123">		AttributeStreamOfDbl zs = null;</span>
<span class="fc" id="L124">		AttributeStreamOfDbl ms = null;</span>
<span class="fc" id="L125">		AttributeStreamOfInt8 path_flags = null;</span>
<span class="fc" id="L126">		AttributeStreamOfInt32 paths = null;</span>

<span class="fc bfc" id="L128" title="All 2 branches covered.">		if (point_count &gt; 0) {</span>
<span class="fc" id="L129">			position = (AttributeStreamOfDbl) (polygon_impl</span>
<span class="fc" id="L130">					.getAttributeStreamRef(VertexDescription.Semantics.POSITION));</span>
<span class="fc" id="L131">			path_flags = polygon_impl.getPathFlagsStreamRef();</span>
<span class="fc" id="L132">			paths = polygon_impl.getPathStreamRef();</span>
<span class="fc" id="L133">			path_count = polygon_impl.getPathCount();</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">			if (b_export_zs) {</span>
<span class="fc" id="L136">				if (polygon_impl</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">						._attributeStreamIsAllocated(VertexDescription.Semantics.Z))</span>
<span class="fc" id="L138">					zs = (AttributeStreamOfDbl) polygon_impl</span>
<span class="fc" id="L139">							.getAttributeStreamRef(VertexDescription.Semantics.Z);</span>
			}

<span class="pc bpc" id="L142" title="1 of 2 branches missed.">			if (b_export_ms) {</span>
<span class="nc" id="L143">				if (polygon_impl</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">						._attributeStreamIsAllocated(VertexDescription.Semantics.M))</span>
<span class="nc" id="L145">					ms = (AttributeStreamOfDbl) polygon_impl</span>
<span class="nc" id="L146">							.getAttributeStreamRef(VertexDescription.Semantics.M);</span>
			}
		}

<span class="fc bfc" id="L150" title="All 2 branches covered.">		if ((export_flags &amp; WktExportFlags.wktExportPolygon) != 0) {</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">			if (polygon_count &gt; 1)</span>
<span class="nc" id="L152">				throw new IllegalArgumentException(&quot;Cannot export a Polygon with specified export flags: &quot;+export_flags);</span>

<span class="fc" id="L154">			polygonTaggedText_(precision, b_export_zs, b_export_ms, zs, ms,</span>
					position, path_flags, paths, path_count, string);
		} else {
<span class="fc" id="L157">			multiPolygonTaggedText_(precision, b_export_zs, b_export_ms, zs,</span>
					ms, position, path_flags, paths, polygon_count, path_count,
					string);
		}
<span class="fc" id="L161">	}</span>

	static void exportPolylineToWkt(int export_flags, Polyline polyline,
			StringBuilder string) {
<span class="fc" id="L165">		MultiPathImpl polyline_impl = (MultiPathImpl) polyline._getImpl();</span>

<span class="fc" id="L167">		int point_count = polyline_impl.getPointCount();</span>
<span class="fc" id="L168">		int path_count = polyline_impl.getPathCount();</span>

<span class="pc bpc" id="L170" title="1 of 4 branches missed.">		if (point_count &gt; 0 &amp;&amp; path_count == 0)</span>
<span class="nc" id="L171">			throw new GeometryException(&quot;corrupted geometry&quot;);</span>

<span class="fc" id="L173">		int precision = 17 - (7 &amp; (export_flags &gt;&gt; 13));</span>
<span class="fc" id="L174">		boolean b_export_zs = polyline_impl</span>
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">				.hasAttribute(VertexDescription.Semantics.Z)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripZs) == 0;
<span class="fc" id="L177">		boolean b_export_ms = polyline_impl</span>
<span class="pc bpc" id="L178" title="1 of 4 branches missed.">				.hasAttribute(VertexDescription.Semantics.M)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripMs) == 0;

<span class="fc" id="L181">		AttributeStreamOfDbl position = null;</span>
<span class="fc" id="L182">		AttributeStreamOfDbl zs = null;</span>
<span class="fc" id="L183">		AttributeStreamOfDbl ms = null;</span>
<span class="fc" id="L184">		AttributeStreamOfInt8 path_flags = null;</span>
<span class="fc" id="L185">		AttributeStreamOfInt32 paths = null;</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">		if (point_count &gt; 0) {</span>
<span class="fc" id="L188">			position = (AttributeStreamOfDbl) polyline_impl</span>
<span class="fc" id="L189">					.getAttributeStreamRef(VertexDescription.Semantics.POSITION);</span>
<span class="fc" id="L190">			path_flags = polyline_impl.getPathFlagsStreamRef();</span>
<span class="fc" id="L191">			paths = polyline_impl.getPathStreamRef();</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">			if (b_export_zs) {</span>
<span class="fc" id="L194">				if (polyline_impl</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">						._attributeStreamIsAllocated(VertexDescription.Semantics.Z))</span>
<span class="fc" id="L196">					zs = (AttributeStreamOfDbl) (polyline_impl</span>
<span class="fc" id="L197">							.getAttributeStreamRef(VertexDescription.Semantics.Z));</span>
			}

<span class="fc bfc" id="L200" title="All 2 branches covered.">			if (b_export_ms) {</span>
<span class="fc" id="L201">				if (polyline_impl</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">						._attributeStreamIsAllocated(VertexDescription.Semantics.M))</span>
<span class="fc" id="L203">					ms = (AttributeStreamOfDbl) (polyline_impl</span>
<span class="fc" id="L204">							.getAttributeStreamRef(VertexDescription.Semantics.M));</span>
			}
		}

<span class="fc bfc" id="L208" title="All 2 branches covered.">		if ((export_flags &amp; WktExportFlags.wktExportLineString) != 0) {</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">			if (path_count &gt; 1)</span>
<span class="nc" id="L210">				throw new IllegalArgumentException(&quot;Cannot export a LineString with specified export flags: &quot;+export_flags);</span>

<span class="fc" id="L212">			lineStringTaggedText_(precision, b_export_zs, b_export_ms, zs, ms,</span>
					position, path_flags, paths, string);
		} else {
<span class="fc" id="L215">			multiLineStringTaggedText_(precision, b_export_zs, b_export_ms, zs,</span>
					ms, position, path_flags, paths, path_count, string);
		}
<span class="fc" id="L218">	}</span>

	static void exportMultiPointToWkt(int export_flags, MultiPoint multipoint,
			StringBuilder string) {
<span class="fc" id="L222">		MultiPointImpl multipoint_impl = (MultiPointImpl) multipoint._getImpl();</span>

<span class="fc" id="L224">		int point_count = multipoint_impl.getPointCount();</span>

<span class="fc" id="L226">		int precision = 17 - (7 &amp; (export_flags &gt;&gt; 13));</span>
<span class="fc" id="L227">		boolean b_export_zs = multipoint_impl</span>
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">				.hasAttribute(VertexDescription.Semantics.Z)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripZs) == 0;
<span class="fc" id="L230">		boolean b_export_ms = multipoint_impl</span>
<span class="pc bpc" id="L231" title="1 of 4 branches missed.">				.hasAttribute(VertexDescription.Semantics.M)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripMs) == 0;

<span class="fc" id="L234">		AttributeStreamOfDbl position = null;</span>
<span class="fc" id="L235">		AttributeStreamOfDbl zs = null;</span>
<span class="fc" id="L236">		AttributeStreamOfDbl ms = null;</span>

<span class="fc bfc" id="L238" title="All 2 branches covered.">		if (point_count &gt; 0) {</span>
<span class="fc" id="L239">			position = (AttributeStreamOfDbl) (multipoint_impl</span>
<span class="fc" id="L240">					.getAttributeStreamRef(VertexDescription.Semantics.POSITION));</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">			if (b_export_zs) {</span>
<span class="fc" id="L243">				if (multipoint_impl</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">						._attributeStreamIsAllocated(VertexDescription.Semantics.Z))</span>
<span class="fc" id="L245">					zs = (AttributeStreamOfDbl) (multipoint_impl</span>
<span class="fc" id="L246">							.getAttributeStreamRef(VertexDescription.Semantics.Z));</span>
			}

<span class="fc bfc" id="L249" title="All 2 branches covered.">			if (b_export_ms) {</span>
<span class="fc" id="L250">				if (multipoint_impl</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">						._attributeStreamIsAllocated(VertexDescription.Semantics.M))</span>
<span class="fc" id="L252">					ms = (AttributeStreamOfDbl) (multipoint_impl</span>
<span class="fc" id="L253">							.getAttributeStreamRef(VertexDescription.Semantics.M));</span>
			}
		}

<span class="fc bfc" id="L257" title="All 2 branches covered.">		if ((export_flags &amp; WktExportFlags.wktExportPoint) != 0) {</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">			if (point_count &gt; 1)</span>
<span class="nc" id="L259">				throw new IllegalArgumentException(&quot;Cannot export a Point with specified export flags: &quot;+export_flags);</span>

<span class="fc" id="L261">			pointTaggedTextFromMultiPoint_(precision, b_export_zs, b_export_ms,</span>
					zs, ms, position, string);
		} else {
<span class="fc" id="L264">			multiPointTaggedText_(precision, b_export_zs, b_export_ms, zs, ms,</span>
					position, point_count, string);
		}
<span class="fc" id="L267">	}</span>

	static void exportPointToWkt(int export_flags, Point point,
			StringBuilder string) {
<span class="fc" id="L271">		int precision = 17 - (7 &amp; (export_flags &gt;&gt; 13));</span>
<span class="pc bpc" id="L272" title="1 of 4 branches missed.">		boolean b_export_zs = point.hasAttribute(VertexDescription.Semantics.Z)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripZs) == 0;
<span class="pc bpc" id="L274" title="1 of 4 branches missed.">		boolean b_export_ms = point.hasAttribute(VertexDescription.Semantics.M)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripMs) == 0;

<span class="fc" id="L277">		double x = NumberUtils.TheNaN;</span>
<span class="fc" id="L278">		double y = NumberUtils.TheNaN;</span>
<span class="fc" id="L279">		double z = NumberUtils.TheNaN;</span>
<span class="fc" id="L280">		double m = NumberUtils.TheNaN;</span>

<span class="fc bfc" id="L282" title="All 2 branches covered.">		if (!point.isEmpty()) {</span>
<span class="fc" id="L283">			x = point.getX();</span>
<span class="fc" id="L284">			y = point.getY();</span>

<span class="fc bfc" id="L286" title="All 2 branches covered.">			if (b_export_zs)</span>
<span class="fc" id="L287">				z = point.getZ();</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">			if (b_export_ms)</span>
<span class="fc" id="L290">				m = point.getM();</span>
		}

<span class="fc bfc" id="L293" title="All 2 branches covered.">		if ((export_flags &amp; WktExportFlags.wktExportMultiPoint) != 0) {</span>
<span class="fc" id="L294">			multiPointTaggedTextFromPoint_(precision, b_export_zs, b_export_ms,</span>
					x, y, z, m, string);
		} else {
<span class="fc" id="L297">			pointTaggedText_(precision, b_export_zs, b_export_ms, x, y, z, m,</span>
					string);
		}
<span class="fc" id="L300">	}</span>

	static void exportEnvelopeToWkt(int export_flags, Envelope envelope,
			StringBuilder string) {
<span class="fc" id="L304">		int precision = 17 - (7 &amp; (export_flags &gt;&gt; 13));</span>
<span class="fc" id="L305">		boolean b_export_zs = envelope</span>
<span class="pc bpc" id="L306" title="2 of 4 branches missed.">				.hasAttribute(VertexDescription.Semantics.Z)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripZs) == 0;
<span class="fc" id="L308">		boolean b_export_ms = envelope</span>
<span class="pc bpc" id="L309" title="3 of 4 branches missed.">				.hasAttribute(VertexDescription.Semantics.M)</span>
				&amp;&amp; (export_flags &amp; WktExportFlags.wktExportStripMs) == 0;

<span class="fc" id="L312">		double xmin = NumberUtils.TheNaN;</span>
<span class="fc" id="L313">		double ymin = NumberUtils.TheNaN;</span>
<span class="fc" id="L314">		double xmax = NumberUtils.TheNaN;</span>
<span class="fc" id="L315">		double ymax = NumberUtils.TheNaN;</span>
<span class="fc" id="L316">		double zmin = NumberUtils.TheNaN;</span>
<span class="fc" id="L317">		double zmax = NumberUtils.TheNaN;</span>
<span class="fc" id="L318">		double mmin = NumberUtils.TheNaN;</span>
<span class="fc" id="L319">		double mmax = NumberUtils.TheNaN;</span>
		Envelope1D interval;

<span class="fc bfc" id="L322" title="All 2 branches covered.">		if (!envelope.isEmpty()) {</span>
<span class="fc" id="L323">			xmin = envelope.getXMin();</span>
<span class="fc" id="L324">			ymin = envelope.getYMin();</span>
<span class="fc" id="L325">			xmax = envelope.getXMax();</span>
<span class="fc" id="L326">			ymax = envelope.getYMax();</span>

<span class="pc bpc" id="L328" title="1 of 2 branches missed.">			if (b_export_zs) {</span>
<span class="fc" id="L329">				interval = envelope.queryInterval(</span>
						VertexDescription.Semantics.Z, 0);
<span class="fc" id="L331">				zmin = interval.vmin;</span>
<span class="fc" id="L332">				zmax = interval.vmax;</span>
			}

<span class="pc bpc" id="L335" title="1 of 2 branches missed.">			if (b_export_ms) {</span>
<span class="nc" id="L336">				interval = envelope.queryInterval(</span>
						VertexDescription.Semantics.M, 0);
<span class="nc" id="L338">				mmin = interval.vmin;</span>
<span class="nc" id="L339">				mmax = interval.vmax;</span>
			}
		}

<span class="fc bfc" id="L343" title="All 2 branches covered.">		if ((export_flags &amp; WktExportFlags.wktExportMultiPolygon) != 0) {</span>
<span class="fc" id="L344">			multiPolygonTaggedTextFromEnvelope_(precision, b_export_zs,</span>
					b_export_ms, xmin, ymin, xmax, ymax, zmin, zmax, mmin,
					mmax, string);
		} else {
<span class="fc" id="L348">			polygonTaggedTextFromEnvelope_(precision, b_export_zs, b_export_ms,</span>
					xmin, ymin, xmax, ymax, zmin, zmax, mmin, mmax, string);
		}
<span class="fc" id="L351">	}</span>

	static void multiPolygonTaggedText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			AttributeStreamOfInt8 path_flags, AttributeStreamOfInt32 paths,
			int polygon_count, int path_count, StringBuilder string) {
<span class="fc" id="L358">		string.append(&quot;MULTIPOLYGON &quot;);</span>

<span class="pc bpc" id="L360" title="1 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L361">			string.append(&quot;ZM &quot;);</span>
<span class="pc bpc" id="L362" title="1 of 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="fc" id="L363">			string.append(&quot;Z &quot;);</span>
<span class="pc bpc" id="L364" title="1 of 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="fc" id="L365">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L367" title="All 2 branches covered.">		if (position == null) {</span>
<span class="fc" id="L368">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L369">			return;</span>
		}

<span class="fc" id="L372">		string.append('(');</span>

<span class="fc" id="L374">		multiPolygonText_(precision, b_export_zs, b_export_ms, zs, ms,</span>
				position, path_flags, paths, polygon_count, path_count, string);

<span class="fc" id="L377">		string.append(')');</span>
<span class="fc" id="L378">	}</span>

	static void multiPolygonTaggedTextFromEnvelope_(int precision,
			boolean b_export_zs, boolean b_export_ms, double xmin, double ymin,
			double xmax, double ymax, double zmin, double zmax, double mmin,
			double mmax, StringBuilder string) {
<span class="fc" id="L384">		string.append(&quot;MULTIPOLYGON &quot;);</span>

<span class="pc bpc" id="L386" title="2 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L387">			string.append(&quot;ZM &quot;);</span>
<span class="pc bpc" id="L388" title="2 of 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="fc" id="L389">			string.append(&quot;Z &quot;);</span>
<span class="nc bnc" id="L390" title="All 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L391">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L393" title="All 2 branches covered.">		if (NumberUtils.isNaN(xmin)) {</span>
<span class="fc" id="L394">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L395">			return;</span>
		}

<span class="fc" id="L398">		string.append('(');</span>

<span class="fc" id="L400">		writeEnvelopeAsWktPolygon_(precision, b_export_zs, b_export_ms, xmin,</span>
				ymin, xmax, ymax, zmin, zmax, mmin, mmax, string);

<span class="fc" id="L403">		string.append(')');</span>
<span class="fc" id="L404">	}</span>

	static void multiLineStringTaggedText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			AttributeStreamOfInt8 path_flags, AttributeStreamOfInt32 paths,
			int path_count, StringBuilder string) {
<span class="fc" id="L411">		string.append(&quot;MULTILINESTRING &quot;);</span>

<span class="pc bpc" id="L413" title="1 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L414">			string.append(&quot;ZM &quot;);</span>
<span class="pc bpc" id="L415" title="1 of 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="fc" id="L416">			string.append(&quot;Z &quot;);</span>
<span class="pc bpc" id="L417" title="1 of 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="fc" id="L418">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L420" title="All 2 branches covered.">		if (position == null) {</span>
<span class="fc" id="L421">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L422">			return;</span>
		}

<span class="fc" id="L425">		string.append('(');</span>

<span class="fc" id="L427">		multiLineStringText_(precision, b_export_zs, b_export_ms, zs, ms,</span>
				position, path_flags, paths, path_count, string);

<span class="fc" id="L430">		string.append(')');</span>
<span class="fc" id="L431">	}</span>

	static void multiPointTaggedText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			int point_count, StringBuilder string) {
<span class="fc" id="L437">		string.append(&quot;MULTIPOINT &quot;);</span>

<span class="pc bpc" id="L439" title="1 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="fc" id="L440">			string.append(&quot;ZM &quot;);</span>
<span class="pc bpc" id="L441" title="3 of 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="nc" id="L442">			string.append(&quot;Z &quot;);</span>
<span class="pc bpc" id="L443" title="2 of 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L444">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L446" title="All 2 branches covered.">		if (position == null) {</span>
<span class="fc" id="L447">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L448">			return;</span>
		}

<span class="fc" id="L451">		string.append('(');</span>

<span class="fc" id="L453">		multiPointText_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
				point_count, string);

<span class="fc" id="L456">		string.append(')');</span>
<span class="fc" id="L457">	}</span>

	static void multiPointTaggedTextFromPoint_(int precision,
			boolean b_export_zs, boolean b_export_ms, double x, double y,
			double z, double m, StringBuilder string) {
<span class="fc" id="L462">		string.append(&quot;MULTIPOINT &quot;);</span>

<span class="pc bpc" id="L464" title="2 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="fc" id="L465">			string.append(&quot;ZM &quot;);</span>
<span class="nc bnc" id="L466" title="All 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="nc" id="L467">			string.append(&quot;Z &quot;);</span>
<span class="nc bnc" id="L468" title="All 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L469">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L471" title="All 2 branches covered.">		if (NumberUtils.isNaN(x)) {</span>
<span class="fc" id="L472">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L473">			return;</span>
		}

<span class="fc" id="L476">		string.append('(');</span>

<span class="fc" id="L478">		pointText_(precision, b_export_zs, b_export_ms, x, y, z, m, string);</span>

<span class="fc" id="L480">		string.append(')');</span>
<span class="fc" id="L481">	}</span>

	static void polygonTaggedText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			AttributeStreamOfInt8 path_flags, AttributeStreamOfInt32 paths,
			int path_count, StringBuilder string) {
<span class="fc" id="L488">		string.append(&quot;POLYGON &quot;);</span>

<span class="pc bpc" id="L490" title="1 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L491">			string.append(&quot;ZM &quot;);</span>
<span class="pc bpc" id="L492" title="1 of 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="fc" id="L493">			string.append(&quot;Z &quot;);</span>
<span class="pc bpc" id="L494" title="2 of 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L495">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L497" title="All 2 branches covered.">		if (position == null) {</span>
<span class="fc" id="L498">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L499">			return;</span>
		}

<span class="fc" id="L502">		polygonText_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
				path_flags, paths, 0, path_count, string);
<span class="fc" id="L504">	}</span>

	static void polygonTaggedTextFromEnvelope_(int precision,
			boolean b_export_zs, boolean b_export_ms, double xmin, double ymin,
			double xmax, double ymax, double zmin, double zmax, double mmin,
			double mmax, StringBuilder string) {
<span class="fc" id="L510">		string.append(&quot;POLYGON &quot;);</span>

<span class="pc bpc" id="L512" title="2 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L513">			string.append(&quot;ZM &quot;);</span>
<span class="pc bpc" id="L514" title="2 of 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="fc" id="L515">			string.append(&quot;Z &quot;);</span>
<span class="nc bnc" id="L516" title="All 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L517">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">		if (NumberUtils.isNaN(xmin)) {</span>
<span class="fc" id="L520">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L521">			return;</span>
		}

<span class="fc" id="L524">		writeEnvelopeAsWktPolygon_(precision, b_export_zs, b_export_ms, xmin,</span>
				ymin, xmax, ymax, zmin, zmax, mmin, mmax, string);
<span class="fc" id="L526">	}</span>

	static void lineStringTaggedText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			AttributeStreamOfInt8 path_flags, AttributeStreamOfInt32 paths,
			StringBuilder string) {
<span class="fc" id="L533">		string.append(&quot;LINESTRING &quot;);</span>

<span class="pc bpc" id="L535" title="1 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L536">			string.append(&quot;ZM &quot;);</span>
<span class="pc bpc" id="L537" title="1 of 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="fc" id="L538">			string.append(&quot;Z &quot;);</span>
<span class="pc bpc" id="L539" title="2 of 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L540">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L542" title="All 2 branches covered.">		if (position == null) {</span>
<span class="fc" id="L543">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L544">			return;</span>
		}

<span class="pc bpc" id="L547" title="1 of 2 branches missed.">		boolean b_closed = ((path_flags.read(0) &amp; PathFlags.enumClosed) != 0);</span>

<span class="fc" id="L549">		lineStringText_(false, b_closed, precision, b_export_zs, b_export_ms,</span>
				zs, ms, position, paths, 0, string);
<span class="fc" id="L551">	}</span>

	static void pointTaggedText_(int precision, boolean b_export_zs,
			boolean b_export_ms, double x, double y, double z, double m,
			StringBuilder string) {
<span class="fc" id="L556">		string.append(&quot;POINT &quot;);</span>

<span class="pc bpc" id="L558" title="1 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="fc" id="L559">			string.append(&quot;ZM &quot;);</span>
<span class="pc bpc" id="L560" title="3 of 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="nc" id="L561">			string.append(&quot;Z &quot;);</span>
<span class="pc bpc" id="L562" title="2 of 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L563">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L565" title="All 2 branches covered.">		if (NumberUtils.isNaN(x)) {</span>
<span class="fc" id="L566">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L567">			return;</span>
		}

<span class="fc" id="L570">		pointText_(precision, b_export_zs, b_export_ms, x, y, z, m, string);</span>
<span class="fc" id="L571">	}</span>

	static void pointTaggedTextFromMultiPoint_(int precision,
			boolean b_export_zs, boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			StringBuilder string) {
<span class="fc" id="L577">		string.append(&quot;POINT &quot;);</span>

<span class="pc bpc" id="L579" title="2 of 4 branches missed.">		if (b_export_zs &amp;&amp; b_export_ms)</span>
<span class="fc" id="L580">			string.append(&quot;ZM &quot;);</span>
<span class="nc bnc" id="L581" title="All 4 branches missed.">		else if (b_export_zs &amp;&amp; !b_export_ms)</span>
<span class="nc" id="L582">			string.append(&quot;Z &quot;);</span>
<span class="nc bnc" id="L583" title="All 4 branches missed.">		else if (!b_export_zs &amp;&amp; b_export_ms)</span>
<span class="nc" id="L584">			string.append(&quot;M &quot;);</span>

<span class="fc bfc" id="L586" title="All 2 branches covered.">		if (position == null) {</span>
<span class="fc" id="L587">			string.append(&quot;EMPTY&quot;);</span>
<span class="fc" id="L588">			return;</span>
		}

<span class="fc" id="L591">		pointText_(precision, b_export_zs, b_export_ms, zs, ms, position, 0,</span>
				string);
<span class="fc" id="L593">	}</span>

	static void multiPolygonText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			AttributeStreamOfInt8 path_flags, AttributeStreamOfInt32 paths,
			int polygon_count, int path_count, StringBuilder string) {
<span class="fc" id="L600">		int polygon_start = 0;</span>
<span class="fc" id="L601">		int polygon_end = 1;</span>

<span class="fc bfc" id="L603" title="All 2 branches covered.">		while (polygon_end &lt; path_count</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">				&amp;&amp; (path_flags.read(polygon_end) &amp; PathFlags.enumOGCStartPolygon) == 0)</span>
<span class="fc" id="L605">			polygon_end++;</span>

<span class="fc" id="L607">		polygonText_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
				path_flags, paths, polygon_start, polygon_end, string);

<span class="fc bfc" id="L610" title="All 2 branches covered.">		for (int ipolygon = 1; ipolygon &lt; polygon_count; ipolygon++) {</span>
<span class="fc" id="L611">			polygon_start = polygon_end;</span>
<span class="fc" id="L612">			polygon_end++;</span>

<span class="fc bfc" id="L614" title="All 2 branches covered.">			while (polygon_end &lt; path_count</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">					&amp;&amp; (path_flags.read(polygon_end) &amp; PathFlags.enumOGCStartPolygon) == 0)</span>
<span class="fc" id="L616">				polygon_end++;</span>

<span class="fc" id="L618">			string.append(&quot;, &quot;);</span>
<span class="fc" id="L619">			polygonText_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
					path_flags, paths, polygon_start, polygon_end, string);
		}
<span class="fc" id="L622">	}</span>

	static void multiLineStringText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			AttributeStreamOfInt8 path_flags, AttributeStreamOfInt32 paths,
			int path_count, StringBuilder string) {
<span class="fc bfc" id="L629" title="All 2 branches covered.">		boolean b_closed = ((path_flags.read(0) &amp; PathFlags.enumClosed) != 0);</span>

<span class="fc" id="L631">		lineStringText_(false, b_closed, precision, b_export_zs, b_export_ms,</span>
				zs, ms, position, paths, 0, string);

<span class="fc bfc" id="L634" title="All 2 branches covered.">		for (int path = 1; path &lt; path_count; path++) {</span>
<span class="fc" id="L635">			string.append(&quot;, &quot;);</span>

<span class="fc bfc" id="L637" title="All 2 branches covered.">			b_closed = ((path_flags.read(path) &amp; PathFlags.enumClosed) != 0);</span>

<span class="fc" id="L639">			lineStringText_(false, b_closed, precision, b_export_zs,</span>
					b_export_ms, zs, ms, position, paths, path, string);
		}
<span class="fc" id="L642">	}</span>

	static void multiPointText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			int point_count, StringBuilder string) {
<span class="fc" id="L648">		pointText_(precision, b_export_zs, b_export_ms, zs, ms, position, 0,</span>
				string);

<span class="fc bfc" id="L651" title="All 2 branches covered.">		for (int point = 1; point &lt; point_count; point++) {</span>
<span class="fc" id="L652">			string.append(&quot;, &quot;);</span>
<span class="fc" id="L653">			pointText_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
					point, string);
		}
<span class="fc" id="L656">	}</span>

	static void polygonText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			AttributeStreamOfInt8 path_flags, AttributeStreamOfInt32 paths,
			int polygon_start, int polygon_end, StringBuilder string) {
<span class="fc" id="L663">		string.append('(');</span>

<span class="fc" id="L665">		lineStringText_(true, true, precision, b_export_zs, b_export_ms, zs,</span>
				ms, position, paths, polygon_start, string);

<span class="fc bfc" id="L668" title="All 2 branches covered.">		for (int path = polygon_start + 1; path &lt; polygon_end; path++) {</span>
<span class="fc" id="L669">			string.append(&quot;, &quot;);</span>
<span class="fc" id="L670">			lineStringText_(true, true, precision, b_export_zs, b_export_ms,</span>
					zs, ms, position, paths, path, string);
		}

<span class="fc" id="L674">		string.append(')');</span>
<span class="fc" id="L675">	}</span>

	static void lineStringText_(boolean bRing, boolean b_closed, int precision,
			boolean b_export_zs, boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position,
			AttributeStreamOfInt32 paths, int path, StringBuilder string) {
<span class="fc" id="L681">		int istart = paths.read(path);</span>
<span class="fc" id="L682">		int iend = paths.read(path + 1);</span>

<span class="pc bpc" id="L684" title="1 of 2 branches missed.">		if (istart == iend) {</span>
<span class="nc" id="L685">			string.append(&quot;EMPTY&quot;);</span>
<span class="nc" id="L686">			return;</span>
		}

<span class="fc" id="L689">		string.append('(');</span>

<span class="fc bfc" id="L691" title="All 2 branches covered.">		if (bRing) {</span>
<span class="fc" id="L692">			point_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
					istart, string);
<span class="fc" id="L694">			string.append(&quot;, &quot;);</span>

<span class="fc bfc" id="L696" title="All 2 branches covered.">			for (int point = iend - 1; point &gt;= istart + 1; point--) {</span>
<span class="fc" id="L697">				point_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
						point, string);
<span class="fc" id="L699">				string.append(&quot;, &quot;);</span>
			}

<span class="fc" id="L702">			point_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
					istart, string);
		} else {
<span class="fc bfc" id="L705" title="All 2 branches covered.">			for (int point = istart; point &lt; iend - 1; point++) {</span>
<span class="fc" id="L706">				point_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
						point, string);
<span class="fc" id="L708">				string.append(&quot;, &quot;);</span>
			}

<span class="fc" id="L711">			point_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
					iend - 1, string);

<span class="fc bfc" id="L714" title="All 2 branches covered.">			if (b_closed) {</span>
<span class="fc" id="L715">				string.append(&quot;, &quot;);</span>
<span class="fc" id="L716">				point_(precision, b_export_zs, b_export_ms, zs, ms, position,</span>
						istart, string);
			}
		}

<span class="fc" id="L721">		string.append(')');</span>
<span class="fc" id="L722">	}</span>

	static int pointText_(int precision, boolean b_export_zs,
			boolean b_export_ms, double x, double y, double z, double m,
			StringBuilder string) {
<span class="fc" id="L727">		string.append('(');</span>
<span class="fc" id="L728">		point_(precision, b_export_zs, b_export_ms, x, y, z, m, string);</span>
<span class="fc" id="L729">		string.append(')');</span>

<span class="fc" id="L731">		return 1;</span>
	}

	static void pointText_(int precision, boolean b_export_zs,
			boolean b_export_ms, AttributeStreamOfDbl zs,
			AttributeStreamOfDbl ms, AttributeStreamOfDbl position, int point,
			StringBuilder string) {
<span class="fc" id="L738">		double x = position.read(2 * point);</span>
<span class="fc" id="L739">		double y = position.read(2 * point + 1);</span>
<span class="fc" id="L740">		double z = NumberUtils.TheNaN;</span>
<span class="fc" id="L741">		double m = NumberUtils.TheNaN;</span>

<span class="fc bfc" id="L743" title="All 2 branches covered.">		if (b_export_zs)</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">			z = (zs != null ? zs.read(point) : VertexDescription</span>
<span class="pc" id="L745">					.getDefaultValue(VertexDescription.Semantics.Z));</span>

<span class="fc bfc" id="L747" title="All 2 branches covered.">		if (b_export_ms)</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">			m = (ms != null ? ms.read(point) : VertexDescription</span>
<span class="pc" id="L749">					.getDefaultValue(VertexDescription.Semantics.M));</span>

<span class="fc" id="L751">		pointText_(precision, b_export_zs, b_export_ms, x, y, z, m, string);</span>
<span class="fc" id="L752">	}</span>

	static void point_(int precision, boolean b_export_zs, boolean b_export_ms,
			double x, double y, double z, double m, StringBuilder string) {
<span class="fc" id="L756">		writeSignedNumericLiteral_(x, precision, string);</span>
<span class="fc" id="L757">		string.append(' ');</span>
<span class="fc" id="L758">		writeSignedNumericLiteral_(y, precision, string);</span>

<span class="fc bfc" id="L760" title="All 2 branches covered.">		if (b_export_zs) {</span>
<span class="fc" id="L761">			string.append(' ');</span>
<span class="fc" id="L762">			writeSignedNumericLiteral_(z, precision, string);</span>
		}

<span class="fc bfc" id="L765" title="All 2 branches covered.">		if (b_export_ms) {</span>
<span class="fc" id="L766">			string.append(' ');</span>
<span class="fc" id="L767">			writeSignedNumericLiteral_(m, precision, string);</span>
		}
<span class="fc" id="L769">	}</span>

	static void point_(int precision, boolean b_export_zs, boolean b_export_ms,
			AttributeStreamOfDbl zs, AttributeStreamOfDbl ms,
			AttributeStreamOfDbl position, int point, StringBuilder string) {
<span class="fc" id="L774">		double x = position.read(2 * point);</span>
<span class="fc" id="L775">		double y = position.read(2 * point + 1);</span>
<span class="fc" id="L776">		double z = NumberUtils.TheNaN;</span>
<span class="fc" id="L777">		double m = NumberUtils.TheNaN;</span>

<span class="fc bfc" id="L779" title="All 2 branches covered.">		if (b_export_zs)</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">			z = (zs != null ? zs.read(point) : VertexDescription</span>
<span class="pc" id="L781">					.getDefaultValue(VertexDescription.Semantics.Z));</span>

<span class="fc bfc" id="L783" title="All 2 branches covered.">		if (b_export_ms)</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">			m = (ms != null ? ms.read(point) : VertexDescription</span>
<span class="pc" id="L785">					.getDefaultValue(VertexDescription.Semantics.M));</span>

<span class="fc" id="L787">		point_(precision, b_export_zs, b_export_ms, x, y, z, m, string);</span>
<span class="fc" id="L788">	}</span>

	static boolean writeSignedNumericLiteral_(double v, int precision,
			StringBuilder string) {
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">		if (NumberUtils.isNaN(v)) {</span>
<span class="nc" id="L793">			string.append(&quot;NAN&quot;);</span>
<span class="nc" id="L794">			return false;</span>
		}

<span class="fc" id="L797">		StringUtils.appendDouble(v, precision, string);</span>
<span class="fc" id="L798">		return true;</span>
	}

	static void writeEnvelopeAsWktPolygon_(int precision, boolean b_export_zs,
			boolean b_export_ms, double xmin, double ymin, double xmax,
			double ymax, double zmin, double zmax, double mmin, double mmax,
			StringBuilder string) {
<span class="fc" id="L805">		string.append(&quot;((&quot;);</span>

<span class="fc" id="L807">		writeSignedNumericLiteral_(xmin, precision, string);</span>
<span class="fc" id="L808">		string.append(' ');</span>
<span class="fc" id="L809">		writeSignedNumericLiteral_(ymin, precision, string);</span>

<span class="pc bpc" id="L811" title="1 of 2 branches missed.">		if (b_export_zs) {</span>
<span class="fc" id="L812">			string.append(' ');</span>
<span class="fc" id="L813">			writeSignedNumericLiteral_(zmin, precision, string);</span>
		}

<span class="pc bpc" id="L816" title="1 of 2 branches missed.">		if (b_export_ms) {</span>
<span class="nc" id="L817">			string.append(' ');</span>
<span class="nc" id="L818">			writeSignedNumericLiteral_(mmin, precision, string);</span>
		}

<span class="fc" id="L821">		string.append(&quot;, &quot;);</span>

<span class="fc" id="L823">		writeSignedNumericLiteral_(xmax, precision, string);</span>
<span class="fc" id="L824">		string.append(' ');</span>
<span class="fc" id="L825">		writeSignedNumericLiteral_(ymin, precision, string);</span>

<span class="pc bpc" id="L827" title="1 of 2 branches missed.">		if (b_export_zs) {</span>
<span class="fc" id="L828">			string.append(' ');</span>
<span class="fc" id="L829">			writeSignedNumericLiteral_(zmax, precision, string);</span>
		}

<span class="pc bpc" id="L832" title="1 of 2 branches missed.">		if (b_export_ms) {</span>
<span class="nc" id="L833">			string.append(' ');</span>
<span class="nc" id="L834">			writeSignedNumericLiteral_(mmax, precision, string);</span>
		}

<span class="fc" id="L837">		string.append(&quot;, &quot;);</span>

<span class="fc" id="L839">		writeSignedNumericLiteral_(xmax, precision, string);</span>
<span class="fc" id="L840">		string.append(' ');</span>
<span class="fc" id="L841">		writeSignedNumericLiteral_(ymax, precision, string);</span>

<span class="pc bpc" id="L843" title="1 of 2 branches missed.">		if (b_export_zs) {</span>
<span class="fc" id="L844">			string.append(' ');</span>
<span class="fc" id="L845">			writeSignedNumericLiteral_(zmin, precision, string);</span>
		}

<span class="pc bpc" id="L848" title="1 of 2 branches missed.">		if (b_export_ms) {</span>
<span class="nc" id="L849">			string.append(' ');</span>
<span class="nc" id="L850">			writeSignedNumericLiteral_(mmin, precision, string);</span>
		}

<span class="fc" id="L853">		string.append(&quot;, &quot;);</span>

<span class="fc" id="L855">		writeSignedNumericLiteral_(xmin, precision, string);</span>
<span class="fc" id="L856">		string.append(' ');</span>
<span class="fc" id="L857">		writeSignedNumericLiteral_(ymax, precision, string);</span>

<span class="pc bpc" id="L859" title="1 of 2 branches missed.">		if (b_export_zs) {</span>
<span class="fc" id="L860">			string.append(' ');</span>
<span class="fc" id="L861">			writeSignedNumericLiteral_(zmax, precision, string);</span>
		}

<span class="pc bpc" id="L864" title="1 of 2 branches missed.">		if (b_export_ms) {</span>
<span class="nc" id="L865">			string.append(' ');</span>
<span class="nc" id="L866">			writeSignedNumericLiteral_(mmax, precision, string);</span>
		}

<span class="fc" id="L869">		string.append(&quot;, &quot;);</span>

<span class="fc" id="L871">		writeSignedNumericLiteral_(xmin, precision, string);</span>
<span class="fc" id="L872">		string.append(' ');</span>
<span class="fc" id="L873">		writeSignedNumericLiteral_(ymin, precision, string);</span>

<span class="pc bpc" id="L875" title="1 of 2 branches missed.">		if (b_export_zs) {</span>
<span class="fc" id="L876">			string.append(' ');</span>
<span class="fc" id="L877">			writeSignedNumericLiteral_(zmin, precision, string);</span>
		}

<span class="pc bpc" id="L880" title="1 of 2 branches missed.">		if (b_export_ms) {</span>
<span class="nc" id="L881">			string.append(' ');</span>
<span class="nc" id="L882">			writeSignedNumericLiteral_(mmin, precision, string);</span>
		}

<span class="fc" id="L885">		string.append(&quot;))&quot;);</span>
<span class="fc" id="L886">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>