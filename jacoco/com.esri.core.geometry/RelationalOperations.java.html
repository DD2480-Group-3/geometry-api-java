<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RelationalOperations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">RelationalOperations.java</span></div><h1>RelationalOperations.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2015 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */
package com.esri.core.geometry;

import java.util.ArrayList;

<span class="fc" id="L28">class RelationalOperations {</span>
	interface Relation {
		static final int contains = 1;
		static final int within = 2;
		static final int equals = 3;
		static final int disjoint = 4;
		static final int touches = 8;
		static final int crosses = 16;
		static final int overlaps = 32;

		static final int unknown = 0;
		static final int intersects = 0x40000000;
	}

	static boolean relate(Geometry geometry_a, Geometry geometry_b,
			SpatialReference sr, int relation, ProgressTracker progress_tracker) {
<span class="fc" id="L44">		int type_a = geometry_a.getType().value();</span>
<span class="fc" id="L45">		int type_b = geometry_b.getType().value();</span>

		// Give preference to the Point vs Envelope, Envelope vs Envelope and
		// Point vs Point realtions:
<span class="fc bfc" id="L49" title="All 2 branches covered.">		if (type_a == Geometry.GeometryType.Envelope) {</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">			if (type_b == Geometry.GeometryType.Envelope) {</span>
<span class="fc" id="L51">				return relate((Envelope) geometry_a, (Envelope) geometry_b, sr,</span>
						relation, progress_tracker);
<span class="fc bfc" id="L53" title="All 2 branches covered.">			} else if (type_b == Geometry.GeometryType.Point) {</span>
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">				if (relation == Relation.within)</span>
<span class="nc" id="L55">					relation = Relation.contains;</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">				else if (relation == Relation.contains)</span>
<span class="fc" id="L57">					relation = Relation.within;</span>

<span class="fc" id="L59">				return relate((Point) geometry_b, (Envelope) geometry_a, sr,</span>
						relation, progress_tracker);
			} else {
				// proceed below
			}
<span class="fc bfc" id="L64" title="All 2 branches covered.">		} else if (type_a == Geometry.GeometryType.Point) {</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">			if (type_b == Geometry.GeometryType.Envelope) {</span>
<span class="fc" id="L66">				return relate((Point) geometry_a, (Envelope) geometry_b, sr,</span>
						relation, progress_tracker);
<span class="fc bfc" id="L68" title="All 2 branches covered.">			} else if (type_b == Geometry.GeometryType.Point) {</span>
<span class="fc" id="L69">				return relate((Point) geometry_a, (Point) geometry_b, sr,</span>
						relation, progress_tracker);
			} else {
				// proceed below
			}
		} else {
			// proceed below
		}

<span class="fc bfc" id="L78" title="All 4 branches covered.">		if (geometry_a.isEmpty() || geometry_b.isEmpty()) {</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">			if (relation == Relation.disjoint)</span>
<span class="fc" id="L80">				return true; // Always true</span>

<span class="fc" id="L82">			return false; // Always false</span>
		}

<span class="fc" id="L85">		Envelope2D env1 = new Envelope2D();</span>
<span class="fc" id="L86">		geometry_a.queryEnvelope2D(env1);</span>
<span class="fc" id="L87">		Envelope2D env2 = new Envelope2D();</span>
<span class="fc" id="L88">		geometry_b.queryEnvelope2D(env2);</span>

<span class="fc" id="L90">		Envelope2D envMerged = new Envelope2D();</span>
<span class="fc" id="L91">		envMerged.setCoords(env1);</span>
<span class="fc" id="L92">		envMerged.merge(env2);</span>
<span class="fc" id="L93">		double tolerance = InternalUtils.calculateToleranceFromGeometry(sr,</span>
				envMerged, false);

<span class="fc bfc" id="L96" title="All 2 branches covered.">		if (envelopeDisjointEnvelope_(env1, env2, tolerance, progress_tracker)) {</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">			if (relation == Relation.disjoint)</span>
<span class="fc" id="L98">				return true;</span>

<span class="fc" id="L100">			return false;</span>
		}

<span class="fc" id="L103">		boolean bRelation = false;</span>

		Geometry _geometry_a;
		Geometry _geometry_b;
		Polyline polyline_a, polyline_b;

<span class="pc bpc" id="L109" title="1 of 2 branches missed.">		if (MultiPath.isSegment(type_a)) {</span>
<span class="nc" id="L110">			polyline_a = new Polyline(geometry_a.getDescription());</span>
<span class="nc" id="L111">			polyline_a.addSegment((Segment) geometry_a, true);</span>
<span class="nc" id="L112">			_geometry_a = polyline_a;</span>
<span class="nc" id="L113">			type_a = Geometry.GeometryType.Polyline;</span>
		} else {
<span class="fc" id="L115">			_geometry_a = geometry_a;</span>
		}

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">		if (MultiPath.isSegment(type_b)) {</span>
<span class="nc" id="L119">			polyline_b = new Polyline(geometry_b.getDescription());</span>
<span class="nc" id="L120">			polyline_b.addSegment((Segment) geometry_b, true);</span>
<span class="nc" id="L121">			_geometry_b = polyline_b;</span>
<span class="nc" id="L122">			type_b = Geometry.GeometryType.Polyline;</span>
		} else {
<span class="fc" id="L124">			_geometry_b = geometry_b;</span>
		}

<span class="fc bfc" id="L127" title="All 4 branches covered.">		if (type_a != Geometry.GeometryType.Envelope</span>
				&amp;&amp; type_b != Geometry.GeometryType.Envelope) {
<span class="pc bpc" id="L129" title="1 of 6 branches missed.">			if (_geometry_a.getDimension() &lt; _geometry_b.getDimension()</span>
					|| (type_a == Geometry.GeometryType.Point &amp;&amp; type_b == Geometry.GeometryType.MultiPoint)) {// we
																												// will
																												// switch
																												// the
																												// order
																												// of
																												// the
																												// geometries
																												// below.
<span class="fc bfc" id="L139" title="All 2 branches covered.">				if (relation == Relation.within)</span>
<span class="fc" id="L140">					relation = Relation.contains;</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">				else if (relation == Relation.contains)</span>
<span class="fc" id="L142">					relation = Relation.within;</span>
			}
		} else {
<span class="fc bfc" id="L145" title="All 4 branches covered.">			if (type_a != Geometry.GeometryType.Polygon</span>
					&amp;&amp; type_b != Geometry.GeometryType.Envelope) { // we will
																	// switch
																	// the order
																	// of the
																	// geometries
																	// below.
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">				if (relation == Relation.within)</span>
<span class="nc" id="L153">					relation = Relation.contains;</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">				else if (relation == Relation.contains)</span>
<span class="fc" id="L155">					relation = Relation.within;</span>
			}
		}

<span class="pc bpc" id="L159" title="1 of 6 branches missed.">		switch (type_a) {</span>
		case Geometry.GeometryType.Polygon:
<span class="pc bpc" id="L161" title="1 of 6 branches missed.">			switch (type_b) {</span>
			case Geometry.GeometryType.Polygon:
<span class="fc" id="L163">				bRelation = polygonRelatePolygon_((Polygon) (_geometry_a),</span>
						(Polygon) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L166">				break;</span>

			case Geometry.GeometryType.Polyline:
<span class="fc" id="L169">				bRelation = polygonRelatePolyline_((Polygon) (_geometry_a),</span>
						(Polyline) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L172">				break;</span>

			case Geometry.GeometryType.Point:
<span class="fc" id="L175">				bRelation = polygonRelatePoint_((Polygon) (_geometry_a),</span>
						(Point) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L178">				break;</span>

			case Geometry.GeometryType.MultiPoint:
<span class="fc" id="L181">				bRelation = polygonRelateMultiPoint_((Polygon) (_geometry_a),</span>
						(MultiPoint) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L184">				break;</span>

			case Geometry.GeometryType.Envelope:
<span class="fc" id="L187">				bRelation = polygonRelateEnvelope_((Polygon) (_geometry_a),</span>
						(Envelope) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L190">				break;</span>

			default:
<span class="nc" id="L193">				break; // warning fix</span>
			}
			break;

		case Geometry.GeometryType.Polyline:
<span class="pc bpc" id="L198" title="1 of 6 branches missed.">			switch (type_b) {</span>
			case Geometry.GeometryType.Polygon:
<span class="fc" id="L200">				bRelation = polygonRelatePolyline_((Polygon) (_geometry_b),</span>
						(Polyline) (_geometry_a), tolerance, relation,
						progress_tracker);
<span class="fc" id="L203">				break;</span>

			case Geometry.GeometryType.Polyline:
<span class="fc" id="L206">				bRelation = polylineRelatePolyline_((Polyline) (_geometry_a),</span>
						(Polyline) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L209">				break;</span>

			case Geometry.GeometryType.Point:
<span class="fc" id="L212">				bRelation = polylineRelatePoint_((Polyline) (_geometry_a),</span>
						(Point) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L215">				break;</span>

			case Geometry.GeometryType.MultiPoint:
<span class="fc" id="L218">				bRelation = polylineRelateMultiPoint_((Polyline) (_geometry_a),</span>
						(MultiPoint) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L221">				break;</span>

			case Geometry.GeometryType.Envelope:
<span class="fc" id="L224">				bRelation = polylineRelateEnvelope_((Polyline) (_geometry_a),</span>
						(Envelope) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L227">				break;</span>

			default:
<span class="nc" id="L230">				break; // warning fix</span>
			}
			break;

		case Geometry.GeometryType.Point:
<span class="pc bpc" id="L235" title="1 of 4 branches missed.">			switch (type_b) {</span>
			case Geometry.GeometryType.Polygon:
<span class="fc" id="L237">				bRelation = polygonRelatePoint_((Polygon) (_geometry_b),</span>
						(Point) (_geometry_a), tolerance, relation,
						progress_tracker);
<span class="fc" id="L240">				break;</span>

			case Geometry.GeometryType.Polyline:
<span class="fc" id="L243">				bRelation = polylineRelatePoint_((Polyline) (_geometry_b),</span>
						(Point) (_geometry_a), tolerance, relation,
						progress_tracker);
<span class="fc" id="L246">				break;</span>

			case Geometry.GeometryType.MultiPoint:
<span class="fc" id="L249">				bRelation = multiPointRelatePoint_((MultiPoint) (_geometry_b),</span>
						(Point) (_geometry_a), tolerance, relation,
						progress_tracker);
<span class="fc" id="L252">				break;</span>

			default:
<span class="nc" id="L255">				break; // warning fix</span>
			}
			break;

		case Geometry.GeometryType.MultiPoint:
<span class="pc bpc" id="L260" title="1 of 6 branches missed.">			switch (type_b) {</span>
			case Geometry.GeometryType.Polygon:
<span class="fc" id="L262">				bRelation = polygonRelateMultiPoint_((Polygon) (_geometry_b),</span>
						(MultiPoint) (_geometry_a), tolerance, relation,
						progress_tracker);
<span class="fc" id="L265">				break;</span>

			case Geometry.GeometryType.Polyline:
<span class="fc" id="L268">				bRelation = polylineRelateMultiPoint_((Polyline) (_geometry_b),</span>
						(MultiPoint) (_geometry_a), tolerance, relation,
						progress_tracker);
<span class="fc" id="L271">				break;</span>

			case Geometry.GeometryType.MultiPoint:
<span class="fc" id="L274">				bRelation = multiPointRelateMultiPoint_(</span>
						(MultiPoint) (_geometry_a), (MultiPoint) (_geometry_b),
						tolerance, relation, progress_tracker);
<span class="fc" id="L277">				break;</span>

			case Geometry.GeometryType.Point:
<span class="fc" id="L280">				bRelation = multiPointRelatePoint_((MultiPoint) (_geometry_a),</span>
						(Point) (_geometry_b), tolerance, relation,
						progress_tracker);
<span class="fc" id="L283">				break;</span>

			case Geometry.GeometryType.Envelope:
<span class="fc" id="L286">				bRelation = multiPointRelateEnvelope_(</span>
						(MultiPoint) (_geometry_a), (Envelope) (_geometry_b),
						tolerance, relation, progress_tracker);
<span class="fc" id="L289">				break;</span>

			default:
<span class="nc" id="L292">				break; // warning fix</span>
			}
			break;

		case Geometry.GeometryType.Envelope:
<span class="pc bpc" id="L297" title="1 of 4 branches missed.">			switch (type_b) {</span>
			case Geometry.GeometryType.Polygon:
<span class="fc" id="L299">				bRelation = polygonRelateEnvelope_((Polygon) (_geometry_b),</span>
						(Envelope) (_geometry_a), tolerance, relation,
						progress_tracker);
<span class="fc" id="L302">				break;</span>

			case Geometry.GeometryType.Polyline:
<span class="fc" id="L305">				bRelation = polylineRelateEnvelope_((Polyline) (_geometry_b),</span>
						(Envelope) (_geometry_a), tolerance, relation,
						progress_tracker);
<span class="fc" id="L308">				break;</span>

			case Geometry.GeometryType.MultiPoint:
<span class="fc" id="L311">				bRelation = multiPointRelateEnvelope_(</span>
						(MultiPoint) (_geometry_b), (Envelope) (_geometry_a),
						tolerance, relation, progress_tracker);
<span class="fc" id="L314">				break;</span>

			default:
<span class="nc" id="L317">				break; // warning fix</span>
			}
			break;

		default:
			break; // warning fix
		}

<span class="fc" id="L325">		return bRelation;</span>
	}

	// Computes the necessary 9 intersection relationships of boundary,
	// interior, and exterior of envelope_a vs envelope_b for the given
	// relation.
	private static boolean relate(Envelope envelope_a, Envelope envelope_b,
			SpatialReference sr, int relation, ProgressTracker progress_tracker) {
<span class="pc bpc" id="L333" title="2 of 4 branches missed.">		if (envelope_a.isEmpty() || envelope_b.isEmpty()) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">			if (relation == Relation.disjoint)</span>
<span class="nc" id="L335">				return true; // Always true</span>

<span class="nc" id="L337">			return false; // Always false</span>
		}

<span class="fc" id="L340">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), env_merged = new Envelope2D();</span>
<span class="fc" id="L341">		envelope_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L342">		envelope_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L343">		env_merged.setCoords(env_a);</span>
<span class="fc" id="L344">		env_merged.merge(env_b);</span>

<span class="fc" id="L346">		double tolerance = InternalUtils.calculateToleranceFromGeometry(sr,</span>
				env_merged, false);

<span class="pc bpc" id="L349" title="2 of 8 branches missed.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L351">			return envelopeDisjointEnvelope_(env_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.within:
<span class="nc" id="L355">			return envelopeContainsEnvelope_(env_b, env_a, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L359">			return envelopeContainsEnvelope_(env_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.equals:
<span class="fc" id="L363">			return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L367">			return envelopeTouchesEnvelope_(env_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.overlaps:
<span class="fc" id="L371">			return envelopeOverlapsEnvelope_(env_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.crosses:
<span class="fc" id="L375">			return envelopeCrossesEnvelope_(env_a, env_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="nc" id="L382">		return false;</span>
	}

	// Computes the necessary 9 intersection relationships of boundary,
	// interior, and exterior of point_a vs envelope_b for the given relation.
	private static boolean relate(Point point_a, Envelope envelope_b,
			SpatialReference sr, int relation, ProgressTracker progress_tracker) {
<span class="pc bpc" id="L389" title="2 of 4 branches missed.">		if (point_a.isEmpty() || envelope_b.isEmpty()) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">			if (relation == Relation.disjoint)</span>
<span class="nc" id="L391">				return true; // Always true</span>

<span class="nc" id="L393">			return false; // Always false</span>
		}

<span class="fc" id="L396">		Point2D pt_a = point_a.getXY();</span>
<span class="fc" id="L397">		Envelope2D env_b = new Envelope2D(), env_merged = new Envelope2D();</span>
<span class="fc" id="L398">		envelope_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L399">		env_merged.setCoords(pt_a);</span>
<span class="fc" id="L400">		env_merged.merge(env_b);</span>

<span class="fc" id="L402">		double tolerance = InternalUtils.calculateToleranceFromGeometry(sr,</span>
				env_merged, false);

<span class="fc bfc" id="L405" title="All 6 branches covered.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L407">			return pointDisjointEnvelope_(pt_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.within:
<span class="fc" id="L411">			return pointWithinEnvelope_(pt_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L415">			return pointContainsEnvelope_(pt_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.equals:
<span class="fc" id="L419">			return pointEqualsEnvelope_(pt_a, env_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L423">			return pointTouchesEnvelope_(pt_a, env_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="fc" id="L430">		return false;</span>
	}

	// Computes the necessary 9 intersection relationships of boundary,
	// interior, and exterior of point_a vs point_b for the given relation.
	private static boolean relate(Point point_a, Point point_b,
			SpatialReference sr, int relation, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L437" title="All 4 branches covered.">		if (point_a.isEmpty() || point_b.isEmpty()) {</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">			if (relation == Relation.disjoint)</span>
<span class="fc" id="L439">				return true; // Always true</span>

<span class="fc" id="L441">			return false; // Always false</span>
		}

<span class="fc" id="L444">		Point2D pt_a = point_a.getXY();</span>
<span class="fc" id="L445">		Point2D pt_b = point_b.getXY();</span>
<span class="fc" id="L446">		Envelope2D env_merged = new Envelope2D();</span>
<span class="fc" id="L447">		env_merged.setCoords(pt_a);</span>
<span class="fc" id="L448">		env_merged.merge(pt_b);</span>

<span class="fc" id="L450">		double tolerance = InternalUtils.calculateToleranceFromGeometry(sr,</span>
				env_merged, false);

<span class="pc bpc" id="L453" title="1 of 5 branches missed.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L455">			return pointDisjointPoint_(pt_a, pt_b, tolerance, progress_tracker);</span>

		case Relation.within:
<span class="fc" id="L458">			return pointContainsPoint_(pt_b, pt_a, tolerance, progress_tracker);</span>

		case Relation.contains:
<span class="fc" id="L461">			return pointContainsPoint_(pt_a, pt_b, tolerance, progress_tracker);</span>

		case Relation.equals:
<span class="fc" id="L464">			return pointEqualsPoint_(pt_a, pt_b, tolerance, progress_tracker);</span>

		default:
			break; // warning fix
		}

<span class="nc" id="L470">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean polygonRelatePolygon_(Polygon polygon_a,
			Polygon polygon_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L477" title="All 7 branches covered.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L479">			return polygonDisjointPolygon_(polygon_a, polygon_b, tolerance,</span>
					progress_tracker);

		case Relation.within:
<span class="fc" id="L483">			return polygonContainsPolygon_(polygon_b, polygon_a, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L487">			return polygonContainsPolygon_(polygon_a, polygon_b, tolerance,</span>
					progress_tracker);

		case Relation.equals:
<span class="fc" id="L491">			return polygonEqualsPolygon_(polygon_a, polygon_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L495">			return polygonTouchesPolygon_(polygon_a, polygon_b, tolerance,</span>
					progress_tracker);

		case Relation.overlaps:
<span class="fc" id="L499">			return polygonOverlapsPolygon_(polygon_a, polygon_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="fc" id="L506">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean polygonRelatePolyline_(Polygon polygon_a,
			Polyline polyline_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L513" title="All 5 branches covered.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L515">			return polygonDisjointPolyline_(polygon_a, polyline_b, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L519">			return polygonContainsPolyline_(polygon_a, polyline_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L523">			return polygonTouchesPolyline_(polygon_a, polyline_b, tolerance,</span>
					progress_tracker);

		case Relation.crosses:
<span class="fc" id="L527">			return polygonCrossesPolyline_(polygon_a, polyline_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="fc" id="L534">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean polygonRelatePoint_(Polygon polygon_a,
			Point point_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L541" title="All 4 branches covered.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L543">			return polygonDisjointPoint_(polygon_a, point_b, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L547">			return polygonContainsPoint_(polygon_a, point_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L551">			return polygonTouchesPoint_(polygon_a, point_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="fc" id="L558">		return false;</span>
	}

	// Returns true if the relation holds
	private static boolean polygonRelateMultiPoint_(Polygon polygon_a,
			MultiPoint multipoint_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="pc bpc" id="L565" title="1 of 5 branches missed.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L567">			return polygonDisjointMultiPoint_(polygon_a, multipoint_b,</span>
					tolerance, true, progress_tracker);

		case Relation.contains:
<span class="fc" id="L571">			return polygonContainsMultiPoint_(polygon_a, multipoint_b,</span>
					tolerance, progress_tracker);

		case Relation.touches:
<span class="fc" id="L575">			return polygonTouchesMultiPoint_(polygon_a, multipoint_b,</span>
					tolerance, progress_tracker);

		case Relation.crosses:
<span class="nc" id="L579">			return polygonCrossesMultiPoint_(polygon_a, multipoint_b,</span>
					tolerance, progress_tracker);

		default:
			break; // warning fix
		}

<span class="fc" id="L586">		return false;</span>
	}

	// Returns true if the relation holds
	private static boolean polygonRelateEnvelope_(Polygon polygon_a,
			Envelope envelope_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L593" title="All 2 branches covered.">		if (polygonDisjointEnvelope_(polygon_a, envelope_b, tolerance,</span>
				progress_tracker)) {
<span class="fc bfc" id="L595" title="All 2 branches covered.">			if (relation == Relation.disjoint)</span>
<span class="fc" id="L596">				return true;</span>

<span class="fc" id="L598">			return false;</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">		} else if (relation == Relation.disjoint) {</span>
<span class="fc" id="L600">			return false;</span>
		}

<span class="pc bpc" id="L603" title="2 of 7 branches missed.">		switch (relation) {</span>
		case Relation.within:
<span class="nc" id="L605">			return polygonWithinEnvelope_(polygon_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L609">			return polygonContainsEnvelope_(polygon_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.equals:
<span class="fc" id="L613">			return polygonEqualsEnvelope_(polygon_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L617">			return polygonTouchesEnvelope_(polygon_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.overlaps:
<span class="fc" id="L621">			return polygonOverlapsEnvelope_(polygon_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.crosses:
<span class="fc" id="L625">			return polygonCrossesEnvelope_(polygon_a, envelope_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="nc" id="L632">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean polylineRelatePolyline_(Polyline polyline_a,
			Polyline polyline_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="pc bpc" id="L639" title="1 of 8 branches missed.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L641">			return polylineDisjointPolyline_(polyline_a, polyline_b, tolerance,</span>
					progress_tracker);

		case Relation.within:
<span class="fc" id="L645">			return polylineContainsPolyline_(polyline_b, polyline_a, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L649">			return polylineContainsPolyline_(polyline_a, polyline_b, tolerance,</span>
					progress_tracker);

		case Relation.equals:
<span class="fc" id="L653">			return polylineEqualsPolyline_(polyline_a, polyline_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L657">			return polylineTouchesPolyline_(polyline_a, polyline_b, tolerance,</span>
					progress_tracker);

		case Relation.overlaps:
<span class="fc" id="L661">			return polylineOverlapsPolyline_(polyline_a, polyline_b, tolerance,</span>
					progress_tracker);

		case Relation.crosses:
<span class="fc" id="L665">			return polylineCrossesPolyline_(polyline_a, polyline_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="nc" id="L672">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean polylineRelatePoint_(Polyline polyline_a,
			Point point_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L679" title="All 4 branches covered.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L681">			return polylineDisjointPoint_(polyline_a, point_b, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L685">			return polylineContainsPoint_(polyline_a, point_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L689">			return polylineTouchesPoint_(polyline_a, point_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="fc" id="L696">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean polylineRelateMultiPoint_(Polyline polyline_a,
			MultiPoint multipoint_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L703" title="All 5 branches covered.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L705">			return polylineDisjointMultiPoint_(polyline_a, multipoint_b,</span>
					tolerance, progress_tracker);

		case Relation.contains:
<span class="fc" id="L709">			return polylineContainsMultiPoint_(polyline_a, multipoint_b,</span>
					tolerance, progress_tracker);

		case Relation.touches:
<span class="fc" id="L713">			return polylineTouchesMultiPoint_(polyline_a, multipoint_b,</span>
					tolerance, progress_tracker);

		case Relation.crosses:
<span class="fc" id="L717">			return polylineCrossesMultiPoint_(polyline_a, multipoint_b,</span>
					tolerance, progress_tracker);

		default:
			break; // warning fix
		}

<span class="fc" id="L724">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean polylineRelateEnvelope_(Polyline polyline_a,
			Envelope envelope_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L731" title="All 2 branches covered.">		if (polylineDisjointEnvelope_(polyline_a, envelope_b, tolerance,</span>
				progress_tracker)) {
<span class="fc bfc" id="L733" title="All 2 branches covered.">			if (relation == Relation.disjoint)</span>
<span class="fc" id="L734">				return true;</span>

<span class="fc" id="L736">			return false;</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">		} else if (relation == Relation.disjoint) {</span>
<span class="fc" id="L738">			return false;</span>
		}

<span class="pc bpc" id="L741" title="1 of 7 branches missed.">		switch (relation) {</span>
		case Relation.within:
<span class="fc" id="L743">			return polylineWithinEnvelope_(polyline_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L747">			return polylineContainsEnvelope_(polyline_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.equals:
<span class="fc" id="L751">			return polylineEqualsEnvelope_(polyline_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.touches:
<span class="fc" id="L755">			return polylineTouchesEnvelope_(polyline_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.overlaps:
<span class="fc" id="L759">			return polylineOverlapsEnvelope_(polyline_a, envelope_b, tolerance,</span>
					progress_tracker);

		case Relation.crosses:
<span class="fc" id="L763">			return polylineCrossesEnvelope_(polyline_a, envelope_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="nc" id="L770">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,
			MultiPoint multipoint_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="pc bpc" id="L777" title="1 of 6 branches missed.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L779">			return multiPointDisjointMultiPoint_(multipoint_a, multipoint_b,</span>
					tolerance, progress_tracker);

		case Relation.within:
<span class="fc" id="L783">			return multiPointContainsMultiPoint_(multipoint_b, multipoint_a,</span>
					tolerance, progress_tracker);

		case Relation.contains:
<span class="fc" id="L787">			return multiPointContainsMultiPoint_(multipoint_a, multipoint_b,</span>
					tolerance, progress_tracker);

		case Relation.equals:
<span class="fc" id="L791">			return multiPointEqualsMultiPoint_(multipoint_a, multipoint_b,</span>
					tolerance, progress_tracker);

		case Relation.overlaps:
<span class="fc" id="L795">			return multiPointOverlapsMultiPoint_(multipoint_a, multipoint_b,</span>
					tolerance, progress_tracker);

		default:
			break; // warning fix
		}

<span class="nc" id="L802">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean multiPointRelatePoint_(MultiPoint multipoint_a,
			Point point_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="pc bpc" id="L809" title="1 of 5 branches missed.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L811">			return multiPointDisjointPoint_(multipoint_a, point_b, tolerance,</span>
					progress_tracker);

		case Relation.within:
<span class="fc" id="L815">			return multiPointWithinPoint_(multipoint_a, point_b, tolerance,</span>
					progress_tracker);

		case Relation.contains:
<span class="fc" id="L819">			return multiPointContainsPoint_(multipoint_a, point_b, tolerance,</span>
					progress_tracker);

		case Relation.equals:
<span class="fc" id="L823">			return multiPointEqualsPoint_(multipoint_a, point_b, tolerance,</span>
					progress_tracker);

		default:
			break; // warning fix
		}

<span class="nc" id="L830">		return false;</span>
	}

	// Returns true if the relation holds.
	private static boolean multiPointRelateEnvelope_(MultiPoint multipoint_a,
			Envelope envelope_b, double tolerance, int relation,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L837" title="All 7 branches covered.">		switch (relation) {</span>
		case Relation.disjoint:
<span class="fc" id="L839">			return multiPointDisjointEnvelope_(multipoint_a, envelope_b,</span>
					tolerance, progress_tracker);

		case Relation.within:
<span class="fc" id="L843">			return multiPointWithinEnvelope_(multipoint_a, envelope_b,</span>
					tolerance, progress_tracker);

		case Relation.contains:
<span class="fc" id="L847">			return multiPointContainsEnvelope_(multipoint_a, envelope_b,</span>
					tolerance, progress_tracker);

		case Relation.equals:
<span class="fc" id="L851">			return multiPointEqualsEnvelope_(multipoint_a, envelope_b,</span>
					tolerance, progress_tracker);

		case Relation.touches:
<span class="fc" id="L855">			return multiPointTouchesEnvelope_(multipoint_a, envelope_b,</span>
					tolerance, progress_tracker);

		case Relation.crosses:
<span class="fc" id="L859">			return multiPointCrossesEnvelope_(multipoint_a, envelope_b,</span>
					tolerance, progress_tracker);

		default:
			break; // warning fix
		}

<span class="fc" id="L866">		return false;</span>
	}

	// Returns true if polygon_a equals polygon_b.
	private static boolean polygonEqualsPolygon_(Polygon polygon_a,
			Polygon polygon_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L873">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L874">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L875">		polygon_b.queryEnvelope2D(env_b);</span>

		// Quick envelope rejection test for false equality.
<span class="fc bfc" id="L878" title="All 2 branches covered.">		if (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))</span>
<span class="fc" id="L879">			return false;</span>

		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L883">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</span>
				tolerance, false);

<span class="pc bpc" id="L886" title="3 of 6 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains</span>
				|| relation == Relation.within)
<span class="nc" id="L888">			return false;</span>

		// Quick point equality check for true equality. This just checks if all
		// the points in each ring are the same (within a tolerance) and in the
		// same order
<span class="fc bfc" id="L893" title="All 2 branches covered.">		if (multiPathExactlyEqualsMultiPath_(polygon_a, polygon_b, tolerance,</span>
				progress_tracker))
<span class="fc" id="L895">			return true;</span>

<span class="fc" id="L897">		double length_a = polygon_a.calculateLength2D();</span>
<span class="fc" id="L898">		double length_b = polygon_b.calculateLength2D();</span>
<span class="fc" id="L899">		int max_vertices = Math.max(polygon_a.getPointCount(),</span>
<span class="fc" id="L900">				polygon_b.getPointCount());</span>

<span class="fc bfc" id="L902" title="All 2 branches covered.">		if (Math.abs(length_a - length_b) &gt; max_vertices * 4.0 * tolerance)</span>
<span class="fc" id="L903">			return false;</span>

<span class="fc" id="L905">		return linearPathEqualsLinearPath_(polygon_a, polygon_b, tolerance, true);</span>
	}

	// Returns true if polygon_a is disjoint from polygon_b.
	private static boolean polygonDisjointPolygon_(Polygon polygon_a,
			Polygon polygon_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L914">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</span>
				tolerance, true);

<span class="fc bfc" id="L917" title="All 2 branches covered.">		if (relation == Relation.disjoint)</span>
<span class="fc" id="L918">			return true;</span>

<span class="pc bpc" id="L920" title="2 of 6 branches missed.">		if (relation == Relation.contains || relation == Relation.within</span>
				|| relation == Relation.intersects)
<span class="fc" id="L922">			return false;</span>

<span class="fc" id="L924">		return polygonDisjointMultiPath_(polygon_a, polygon_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a touches polygon_b.
	private static boolean polygonTouchesPolygon_(Polygon polygon_a,
			Polygon polygon_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L934">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</span>
				tolerance, false);

<span class="pc bpc" id="L937" title="3 of 6 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains</span>
				|| relation == Relation.within)
<span class="nc" id="L939">			return false;</span>

<span class="fc" id="L941">		return polygonTouchesPolygonImpl_(polygon_a, polygon_b, tolerance, null);</span>
	}

	// Returns true if polygon_a overlaps polygon_b.
	private static boolean polygonOverlapsPolygon_(Polygon polygon_a,
			Polygon polygon_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L950">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</span>
				tolerance, false);

<span class="pc bpc" id="L953" title="3 of 6 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains</span>
				|| relation == Relation.within)
<span class="nc" id="L955">			return false;</span>

<span class="fc" id="L957">		return polygonOverlapsPolygonImpl_(polygon_a, polygon_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a contains polygon_b.
	private static boolean polygonContainsPolygon_(Polygon polygon_a,
			Polygon polygon_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L965">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L966">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L967">		polygon_b.queryEnvelope2D(env_b);</span>

		// Quick envelope rejection test for false equality.
<span class="fc bfc" id="L970" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="fc" id="L971">			return false;</span>

		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L975">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</span>
				tolerance, false);

<span class="pc bpc" id="L978" title="2 of 4 branches missed.">		if (relation == Relation.disjoint || relation == Relation.within)</span>
<span class="nc" id="L979">			return false;</span>

<span class="pc bpc" id="L981" title="1 of 2 branches missed.">		if (relation == Relation.contains)</span>
<span class="nc" id="L982">			return true;</span>

<span class="fc" id="L984">		return polygonContainsPolygonImpl_(polygon_a, polygon_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a is disjoint from polyline_b.
	private static boolean polygonDisjointPolyline_(Polygon polygon_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L994">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,</span>
				tolerance, true);

<span class="pc bpc" id="L997" title="1 of 2 branches missed.">		if (relation == Relation.disjoint)</span>
<span class="nc" id="L998">			return true;</span>

<span class="pc bpc" id="L1000" title="2 of 4 branches missed.">		if (relation == Relation.contains || relation == Relation.intersects)</span>
<span class="nc" id="L1001">			return false;</span>

<span class="fc" id="L1003">		return polygonDisjointMultiPath_(polygon_a, polyline_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a touches polyline_b.
	private static boolean polygonTouchesPolyline_(Polygon polygon_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1013">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,</span>
				tolerance, false);

<span class="pc bpc" id="L1016" title="2 of 4 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains)</span>
<span class="nc" id="L1017">			return false;</span>

<span class="fc" id="L1019">		return polygonTouchesPolylineImpl_(polygon_a, polyline_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a crosses polyline_b.
	private static boolean polygonCrossesPolyline_(Polygon polygon_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1029">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,</span>
				tolerance, false);

<span class="pc bpc" id="L1032" title="2 of 4 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains)</span>
<span class="nc" id="L1033">			return false;</span>

<span class="fc" id="L1035">		return polygonCrossesPolylineImpl_(polygon_a, polyline_b, tolerance,</span>
				null);
	}

	// Returns true if polygon_a contains polyline_b.
	private static boolean polygonContainsPolyline_(Polygon polygon_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L1043">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1044">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1045">		polyline_b.queryEnvelope2D(env_b);</span>

		// Quick envelope rejection test for false equality.
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="nc" id="L1049">			return false;</span>

		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1053">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,</span>
				tolerance, false);

<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">		if (relation == Relation.disjoint)</span>
<span class="nc" id="L1057">			return false;</span>

<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">		if (relation == Relation.contains)</span>
<span class="nc" id="L1060">			return true;</span>

<span class="fc" id="L1062">		return polygonContainsPolylineImpl_(polygon_a, polyline_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a is disjoint from point_b.
	private static boolean polygonDisjointPoint_(Polygon polygon_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L1069">		PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(</span>
				polygon_a, point_b, tolerance);

<span class="fc bfc" id="L1072" title="All 2 branches covered.">		if (result == PolygonUtils.PiPResult.PiPOutside)</span>
<span class="fc" id="L1073">			return true;</span>

<span class="fc" id="L1075">		return false;</span>
	}

	// Returns true of polygon_a touches point_b.
	private static boolean polygonTouchesPoint_(Polygon polygon_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L1081">		Point2D pt_b = point_b.getXY();</span>
<span class="fc" id="L1082">		return polygonTouchesPointImpl_(polygon_a, pt_b, tolerance, null);</span>
	}

	// Returns true if polygon_a contains point_b.
	private static boolean polygonContainsPoint_(Polygon polygon_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L1088">		Point2D pt_b = point_b.getXY();</span>
<span class="fc" id="L1089">		return polygonContainsPointImpl_(polygon_a, pt_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a is disjoint from multipoint_b.
	private static boolean polygonDisjointMultiPoint_(Polygon polygon_a,
			MultiPoint multipoint_b, double tolerance,
			boolean bIncludeBoundaryA, ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1099">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,</span>
				multipoint_b, tolerance, false);

<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">		if (relation == Relation.disjoint)</span>
<span class="nc" id="L1103">			return true;</span>

<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">		if (relation == Relation.contains)</span>
<span class="nc" id="L1106">			return false;</span>

<span class="fc" id="L1108">		Envelope2D env_a_inflated = new Envelope2D();</span>
<span class="fc" id="L1109">		polygon_a.queryEnvelope2D(env_a_inflated);</span>
<span class="fc" id="L1110">		env_a_inflated.inflate(tolerance, tolerance);</span>
<span class="fc" id="L1111">		Point2D ptB = new Point2D();</span>

<span class="fc bfc" id="L1113" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc" id="L1114">			multipoint_b.getXY(i, ptB);</span>

<span class="fc bfc" id="L1116" title="All 2 branches covered.">			if (!env_a_inflated.contains(ptB))</span>
<span class="fc" id="L1117">				continue;</span>

<span class="fc" id="L1119">			PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(</span>
					polygon_a, ptB, tolerance);

<span class="pc bpc" id="L1122" title="1 of 6 branches missed.">			if (result == PolygonUtils.PiPResult.PiPInside</span>
					|| (bIncludeBoundaryA &amp;&amp; result == PolygonUtils.PiPResult.PiPBoundary))
<span class="fc" id="L1124">				return false;</span>
		}

<span class="fc" id="L1127">		return true;</span>
	}

	// Returns true if polygon_a touches multipoint_b.
	private static boolean polygonTouchesMultiPoint_(Polygon polygon_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1136">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,</span>
				multipoint_b, tolerance, false);

<span class="pc bpc" id="L1139" title="2 of 4 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains)</span>
<span class="nc" id="L1140">			return false;</span>

<span class="fc" id="L1142">        Envelope2D env_a_inflated = new Envelope2D();</span>
<span class="fc" id="L1143">        polygon_a.queryEnvelope2D(env_a_inflated);</span>
<span class="fc" id="L1144">        env_a_inflated.inflate(tolerance, tolerance);</span>

        Point2D ptB;
<span class="fc" id="L1147">        boolean b_boundary = false;</span>

<span class="fc" id="L1149">        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();</span>

<span class="fc" id="L1151">        Polygon pa = null;</span>
<span class="fc" id="L1152">        Polygon p_polygon_a = polygon_a;</span>

<span class="fc" id="L1154">        boolean b_checked_polygon_a_quad_tree = false;</span>

<span class="fc bfc" id="L1156" title="All 2 branches covered.">        for (int i = 0; i &lt; multipoint_b.getPointCount(); i++)</span>
        {
<span class="fc" id="L1158">            ptB = multipoint_b.getXY(i);</span>

<span class="fc bfc" id="L1160" title="All 2 branches covered.">            if (env_a_inflated.contains(ptB)) {</span>

<span class="fc" id="L1162">                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);</span>

<span class="fc bfc" id="L1164" title="All 2 branches covered.">                if (result == PolygonUtils.PiPResult.PiPBoundary)</span>
<span class="fc" id="L1165">                    b_boundary = true;</span>
<span class="pc bpc" id="L1166" title="1 of 2 branches missed.">                else if (result == PolygonUtils.PiPResult.PiPInside)</span>
<span class="fc" id="L1167">                    return false;</span>
            }

<span class="fc bfc" id="L1170" title="All 2 branches covered.">            if (!b_checked_polygon_a_quad_tree) {</span>
<span class="pc bpc" id="L1171" title="5 of 6 branches missed.">                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) &amp;&amp; (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {</span>
<span class="nc" id="L1172">                    pa = new Polygon();</span>
<span class="nc" id="L1173">                    polygon_a.copyTo(pa);</span>
<span class="nc" id="L1174">                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</span>
<span class="nc" id="L1175">                    p_polygon_a = pa;</span>
                } else {
<span class="fc" id="L1177">                    p_polygon_a = polygon_a;</span>
                }

<span class="fc" id="L1180">                b_checked_polygon_a_quad_tree = true;</span>
            }
        }

<span class="fc bfc" id="L1184" title="All 2 branches covered.">        if (b_boundary)</span>
<span class="fc" id="L1185">            return true;</span>

<span class="fc" id="L1187">        return false;</span>
	}

	// Returns true if polygon_a crosses multipoint_b.
	private static boolean polygonCrossesMultiPoint_(Polygon polygon_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="nc" id="L1196">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,</span>
				multipoint_b, tolerance, false);

<span class="nc bnc" id="L1199" title="All 4 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains)</span>
<span class="nc" id="L1200">			return false;</span>

<span class="nc" id="L1202">        Envelope2D env_a = new Envelope2D(), env_a_inflated = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="nc" id="L1203">        polygon_a.queryEnvelope2D(env_a);</span>
<span class="nc" id="L1204">        multipoint_b.queryEnvelope2D(env_b);</span>
<span class="nc" id="L1205">        env_a_inflated.setCoords(env_a);</span>
<span class="nc" id="L1206">        env_a_inflated.inflate(tolerance, tolerance);</span>

<span class="nc" id="L1208">        boolean b_interior = false, b_exterior = false;</span>

        Point2D pt_b;

<span class="nc" id="L1212">        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();</span>

<span class="nc" id="L1214">        Polygon pa = null;</span>
<span class="nc" id="L1215">        Polygon p_polygon_a = polygon_a;</span>

<span class="nc" id="L1217">        boolean b_checked_polygon_a_quad_tree = false;</span>

<span class="nc bnc" id="L1219" title="All 2 branches missed.">        for (int i = 0; i &lt; multipoint_b.getPointCount(); i++)</span>
        {
<span class="nc" id="L1221">            pt_b = multipoint_b.getXY(i);</span>

<span class="nc bnc" id="L1223" title="All 2 branches missed.">            if (!env_a_inflated.contains(pt_b))</span>
            {
<span class="nc" id="L1225">                b_exterior = true;</span>
            }
            else
            {
<span class="nc" id="L1229">                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, pt_b, tolerance);</span>

<span class="nc bnc" id="L1231" title="All 2 branches missed.">                if (result == PolygonUtils.PiPResult.PiPOutside)</span>
<span class="nc" id="L1232">                    b_exterior = true;</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">                else if (result == PolygonUtils.PiPResult.PiPInside)</span>
<span class="nc" id="L1234">                    b_interior = true;</span>
            }

<span class="nc bnc" id="L1237" title="All 4 branches missed.">            if (b_interior &amp;&amp; b_exterior)</span>
<span class="nc" id="L1238">                return true;</span>

<span class="nc bnc" id="L1240" title="All 2 branches missed.">            if (!b_checked_polygon_a_quad_tree) {</span>
<span class="nc bnc" id="L1241" title="All 6 branches missed.">                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) &amp;&amp; (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {</span>
<span class="nc" id="L1242">                    pa = new Polygon();</span>
<span class="nc" id="L1243">                    polygon_a.copyTo(pa);</span>
<span class="nc" id="L1244">                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</span>
<span class="nc" id="L1245">                    p_polygon_a = pa;</span>
                } else {
<span class="nc" id="L1247">                    p_polygon_a = polygon_a;</span>
                }

<span class="nc" id="L1250">                b_checked_polygon_a_quad_tree = true;</span>
            }
        }

<span class="nc" id="L1254">        return false;</span>
	}

	// Returns true if polygon_a contains multipoint_b.
	private static boolean polygonContainsMultiPoint_(Polygon polygon_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L1261">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1262">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1263">		multipoint_b.queryEnvelope2D(env_b);</span>

		// Quick envelope rejection test for false equality.
<span class="fc bfc" id="L1266" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="fc" id="L1267">			return false;</span>

		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1271">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,</span>
				multipoint_b, tolerance, false);

<span class="pc bpc" id="L1274" title="1 of 2 branches missed.">		if (relation == Relation.disjoint)</span>
<span class="nc" id="L1275">			return false;</span>

<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">		if (relation == Relation.contains)</span>
<span class="nc" id="L1278">			return true;</span>

<span class="fc" id="L1280">        boolean b_interior = false;</span>
        Point2D ptB;

<span class="fc" id="L1283">        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();</span>

<span class="fc" id="L1285">        Polygon pa = null;</span>
<span class="fc" id="L1286">        Polygon p_polygon_a = polygon_a;</span>

<span class="fc" id="L1288">        boolean b_checked_polygon_a_quad_tree = false;</span>

<span class="fc bfc" id="L1290" title="All 2 branches covered.">        for (int i = 0; i &lt; multipoint_b.getPointCount(); i++)</span>
        {
<span class="fc" id="L1292">            ptB = multipoint_b.getXY(i);</span>

<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">            if (!env_a.contains(ptB))</span>
<span class="nc" id="L1295">                return false;</span>

<span class="fc" id="L1297">            PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);</span>

<span class="fc bfc" id="L1299" title="All 2 branches covered.">            if (result == PolygonUtils.PiPResult.PiPInside)</span>
<span class="fc" id="L1300">                b_interior = true;</span>
<span class="pc bpc" id="L1301" title="1 of 2 branches missed.">            else if (result == PolygonUtils.PiPResult.PiPOutside)</span>
<span class="nc" id="L1302">                return false;</span>

<span class="fc bfc" id="L1304" title="All 2 branches covered.">            if (!b_checked_polygon_a_quad_tree) {</span>
<span class="pc bpc" id="L1305" title="5 of 6 branches missed.">                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) &amp;&amp; (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {</span>
<span class="nc" id="L1306">                    pa = new Polygon();</span>
<span class="nc" id="L1307">                    polygon_a.copyTo(pa);</span>
<span class="nc" id="L1308">                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</span>
<span class="nc" id="L1309">                    p_polygon_a = pa;</span>
                } else {
<span class="fc" id="L1311">                    p_polygon_a = polygon_a;</span>
                }

<span class="fc" id="L1314">                b_checked_polygon_a_quad_tree = true;</span>
            }
        }

<span class="fc" id="L1318">        return b_interior;</span>
	}

	// Returns true if polygon_a equals envelope_b.
	private static boolean polygonEqualsEnvelope_(Polygon polygon_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L1325">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1326">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1327">		envelope_b.queryEnvelope2D(env_b);</span>

		// Quick envelope rejection test for false equality.
		// This check will correctly handle degenerate envelope cases (i.e.
		// degenerate to point or line)
<span class="fc bfc" id="L1332" title="All 2 branches covered.">		if (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))</span>
<span class="fc" id="L1333">			return false;</span>

<span class="fc" id="L1335">		Polygon polygon_b = new Polygon();</span>
<span class="fc" id="L1336">		polygon_b.addEnvelope(envelope_b, false);</span>

<span class="fc" id="L1338">		return linearPathEqualsLinearPath_(polygon_a, polygon_b, tolerance, true);</span>
	}

	// Returns true if polygon_a is disjoint from envelope_b.
	private static boolean polygonDisjointEnvelope_(Polygon polygon_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1347">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,</span>
				tolerance, false);

<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">		if (relation == Relation.disjoint)</span>
<span class="nc" id="L1351">			return true;</span>

<span class="pc bpc" id="L1353" title="2 of 4 branches missed.">		if (relation == Relation.contains || relation == Relation.within)</span>
<span class="nc" id="L1354">			return false;</span>

<span class="fc" id="L1356">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1357">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1358">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L1360" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L1361">			return false;</span>

		PolygonUtils.PiPResult pipres;
<span class="fc" id="L1364">		Point2D pt_b = new Point2D();</span>
<span class="fc" id="L1365">		env_b.queryLowerLeft(pt_b);</span>
<span class="fc" id="L1366">		pipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);</span>
<span class="fc bfc" id="L1367" title="All 2 branches covered.">		if (pipres != PolygonUtils.PiPResult.PiPOutside)</span>
<span class="fc" id="L1368">			return false;</span>

<span class="fc" id="L1370">		env_b.queryLowerRight(pt_b);</span>
<span class="fc" id="L1371">		pipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);</span>
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">		if (pipres != PolygonUtils.PiPResult.PiPOutside)</span>
<span class="nc" id="L1373">			return false;</span>

<span class="fc" id="L1375">		env_b.queryUpperRight(pt_b);</span>
<span class="fc" id="L1376">		pipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);</span>
<span class="pc bpc" id="L1377" title="1 of 2 branches missed.">		if (pipres != PolygonUtils.PiPResult.PiPOutside)</span>
<span class="nc" id="L1378">			return false;</span>

<span class="fc" id="L1380">		env_b.queryUpperLeft(pt_b);</span>
<span class="fc" id="L1381">		pipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);</span>
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">		if (pipres != PolygonUtils.PiPResult.PiPOutside)</span>
<span class="nc" id="L1383">			return false;</span>

<span class="fc" id="L1385">		MultiPathImpl mimpl_a = (MultiPathImpl) polygon_a._getImpl();</span>
<span class="fc" id="L1386">		AttributeStreamOfDbl pos = (AttributeStreamOfDbl) (mimpl_a</span>
<span class="fc" id="L1387">				.getAttributeStreamRef(VertexDescription.Semantics.POSITION));</span>

<span class="fc" id="L1389">		Envelope2D env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L1390">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L1391">		env_b_inflated.inflate(tolerance, tolerance);</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">		for (int ptIndex = 0, n = mimpl_a.getPointCount(); ptIndex &lt; n; ptIndex++) {</span>
<span class="fc" id="L1393">			double x = pos.read(2 * ptIndex);</span>
<span class="fc" id="L1394">			double y = pos.read(2 * ptIndex + 1);</span>
<span class="pc bpc" id="L1395" title="1 of 2 branches missed.">			if (env_b_inflated.contains(x, y))</span>
<span class="nc" id="L1396">				return false;</span>
		}

<span class="fc bfc" id="L1399" title="All 2 branches covered.">		return !linearPathIntersectsEnvelope_(polygon_a, env_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a touches envelope_b.
	private static boolean polygonTouchesEnvelope_(Polygon polygon_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1409">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,</span>
				tolerance, false);

<span class="pc bpc" id="L1412" title="3 of 6 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains</span>
				|| relation == Relation.within)
<span class="nc" id="L1414">			return false;</span>

<span class="fc" id="L1416">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1417">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1418">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L1420" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L1421">			return false;</span>

<span class="pc bpc" id="L1423" title="1 of 4 branches missed.">		if (env_b.getWidth() &lt;= tolerance &amp;&amp; env_b.getHeight() &lt;= tolerance) {// treat</span>
																				// as
																				// point
<span class="fc" id="L1426">			Point2D pt_b = envelope_b.getCenterXY();</span>
<span class="fc" id="L1427">			return polygonTouchesPointImpl_(polygon_a, pt_b, tolerance,</span>
					progress_tracker);
		}

<span class="pc bpc" id="L1431" title="1 of 4 branches missed.">		if (env_b.getWidth() &lt;= tolerance || env_b.getHeight() &lt;= tolerance) {// treat</span>
																				// as
																				// polyline
<span class="fc" id="L1434">			Polyline polyline_b = new Polyline();</span>
<span class="fc" id="L1435">			Point p = new Point();</span>
<span class="fc" id="L1436">			envelope_b.queryCornerByVal(0, p);</span>
<span class="fc" id="L1437">			polyline_b.startPath(p);</span>
<span class="fc" id="L1438">			envelope_b.queryCornerByVal(2, p);</span>
<span class="fc" id="L1439">			polyline_b.lineTo(p);</span>
<span class="fc" id="L1440">			return polygonTouchesPolylineImpl_(polygon_a, polyline_b,</span>
					tolerance, progress_tracker);
		}

		// treat as polygon
<span class="fc" id="L1445">		Polygon polygon_b = new Polygon();</span>
<span class="fc" id="L1446">		polygon_b.addEnvelope(envelope_b, false);</span>
<span class="fc" id="L1447">		return polygonTouchesPolygonImpl_(polygon_a, polygon_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a overlaps envelope_b.
	private static boolean polygonOverlapsEnvelope_(Polygon polygon_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1457">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,</span>
				tolerance, false);

<span class="pc bpc" id="L1460" title="3 of 6 branches missed.">		if (relation == Relation.disjoint || relation == Relation.contains</span>
				|| relation == Relation.within)
<span class="nc" id="L1462">			return false;</span>

<span class="fc" id="L1464">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1465">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1466">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L1468" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L1469">			return false;</span>

<span class="fc bfc" id="L1471" title="All 4 branches covered.">		if (env_b.getWidth() &lt;= tolerance || env_b.getHeight() &lt;= tolerance)</span>
<span class="fc" id="L1472">			return false; // has no interior</span>

<span class="fc" id="L1474">		Polygon polygon_b = new Polygon();</span>
<span class="fc" id="L1475">		polygon_b.addEnvelope(envelope_b, false);</span>
<span class="fc" id="L1476">		return polygonOverlapsPolygonImpl_(polygon_a, polygon_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polygon_a is within envelope_b
	private static boolean polygonWithinEnvelope_(Polygon polygon_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="nc" id="L1484">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="nc" id="L1485">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="nc" id="L1486">		envelope_b.queryEnvelope2D(env_b);</span>
<span class="nc" id="L1487">		return envelopeInfContainsEnvelope_(env_b, env_a, tolerance);</span>
	}

	// Returns true if polygon_a contains envelope_b.
	private static boolean polygonContainsEnvelope_(Polygon polygon_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick envelope rejection test

<span class="fc" id="L1496">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1497">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1498">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L1500" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="fc" id="L1501">			return false;</span>

		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
<span class="fc" id="L1505">		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,</span>
				tolerance, false);

<span class="pc bpc" id="L1508" title="2 of 4 branches missed.">		if (relation == Relation.disjoint || relation == Relation.within)</span>
<span class="nc" id="L1509">			return false;</span>

<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">		if (relation == Relation.contains)</span>
<span class="nc" id="L1512">			return true;</span>

<span class="pc bpc" id="L1514" title="1 of 4 branches missed.">		if (env_b.getWidth() &lt;= tolerance &amp;&amp; env_b.getHeight() &lt;= tolerance) {// treat</span>
																				// as
																				// point
<span class="fc" id="L1517">			Point2D pt_b = envelope_b.getCenterXY();</span>
<span class="fc" id="L1518">			return polygonContainsPointImpl_(polygon_a, pt_b, tolerance,</span>
					progress_tracker);
		}

<span class="pc bpc" id="L1522" title="1 of 4 branches missed.">		if (env_b.getWidth() &lt;= tolerance || env_b.getHeight() &lt;= tolerance) {// treat</span>
																				// as
																				// polyline
<span class="fc" id="L1525">			Polyline polyline_b = new Polyline();</span>
<span class="fc" id="L1526">			Point p = new Point();</span>
<span class="fc" id="L1527">			envelope_b.queryCornerByVal(0, p);</span>
<span class="fc" id="L1528">			polyline_b.startPath(p);</span>
<span class="fc" id="L1529">			envelope_b.queryCornerByVal(2, p);</span>
<span class="fc" id="L1530">			polyline_b.lineTo(p);</span>
<span class="fc" id="L1531">			return polygonContainsPolylineImpl_(polygon_a, polyline_b,</span>
					tolerance, null);
		}

		// treat as polygon
<span class="fc" id="L1536">		Polygon polygon_b = new Polygon();</span>
<span class="fc" id="L1537">		polygon_b.addEnvelope(envelope_b, false);</span>
<span class="fc" id="L1538">		return polygonContainsPolygonImpl_(polygon_a, polygon_b, tolerance,</span>
				null);
	}

	// Returns true if polygon_a crosses envelope_b.
	private static boolean polygonCrossesEnvelope_(Polygon polygon_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L1546">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1547">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1548">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L1550" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L1551">			return false;</span>

<span class="pc bpc" id="L1553" title="1 of 4 branches missed.">		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</span>
<span class="fc" id="L1554">			return false; // when treated as an area, areas cannot cross areas.</span>

<span class="pc bpc" id="L1556" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L1557">			return false; // when treated as a point, areas cannot cross points.</span>

		// Treat as polyline
<span class="fc" id="L1560">		Polyline polyline_b = new Polyline();</span>
<span class="fc" id="L1561">		Point p = new Point();</span>
<span class="fc" id="L1562">		envelope_b.queryCornerByVal(0, p);</span>
<span class="fc" id="L1563">		polyline_b.startPath(p);</span>
<span class="fc" id="L1564">		envelope_b.queryCornerByVal(2, p);</span>
<span class="fc" id="L1565">		polyline_b.lineTo(p);</span>
<span class="fc" id="L1566">		return polygonCrossesPolylineImpl_(polygon_a, polyline_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polyline_a equals polyline_b.
	private static boolean polylineEqualsPolyline_(Polyline polyline_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L1574">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1575">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1576">		polyline_b.queryEnvelope2D(env_b);</span>

		// Quick envelope rejection test for false equality.
<span class="fc bfc" id="L1579" title="All 2 branches covered.">		if (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))</span>
<span class="fc" id="L1580">			return false;</span>

		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1585">			return false;</span>

		// Quick point equality check for true equality. This just checks if all
		// the points in each ring are the same (within a tolerance) and in the
		// same order
<span class="fc bfc" id="L1590" title="All 2 branches covered.">		if (multiPathExactlyEqualsMultiPath_(polyline_a, polyline_b, tolerance,</span>
				progress_tracker))
<span class="fc" id="L1592">			return true;</span>

<span class="fc" id="L1594">		return linearPathEqualsLinearPath_(polyline_a, polyline_b, tolerance, false);</span>
	}

	// Returns true if polyline_a is disjoint from polyline_b.
	private static boolean polylineDisjointPolyline_(Polyline polyline_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1604">			return true;</span>

<span class="fc" id="L1606">        MultiPathImpl multi_path_impl_a = (MultiPathImpl)polyline_a._getImpl();</span>
<span class="fc" id="L1607">        MultiPathImpl multi_path_impl_b = (MultiPathImpl)polyline_b._getImpl();</span>

<span class="fc" id="L1609">        PairwiseIntersectorImpl intersector_paths = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, true);</span>

<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">        if (!intersector_paths.next())</span>
<span class="nc" id="L1612">            return false;</span>

<span class="fc bfc" id="L1614" title="All 2 branches covered.">		return !linearPathIntersectsLinearPath_(polyline_a, polyline_b,</span>
				tolerance);
	}

	// Returns true if polyline_a touches polyline_b.
	private static boolean polylineTouchesPolyline_(Polyline polyline_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1623" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1625">			return false;</span>

<span class="fc" id="L1627">		AttributeStreamOfDbl intersections = new AttributeStreamOfDbl(0);</span>

<span class="fc" id="L1629">		int dim = linearPathIntersectsLinearPathMaxDim_(polyline_a, polyline_b,</span>
				tolerance, intersections);

<span class="fc bfc" id="L1632" title="All 2 branches covered.">		if (dim != 0)</span>
<span class="fc" id="L1633">			return false;</span>

<span class="fc" id="L1635">		MultiPoint intersection = new MultiPoint();</span>

<span class="fc bfc" id="L1637" title="All 2 branches covered.">		for (int i = 0; i &lt; intersections.size(); i += 2) {</span>
<span class="fc" id="L1638">			double x = intersections.read(i);</span>
<span class="fc" id="L1639">			double y = intersections.read(i + 1);</span>
<span class="fc" id="L1640">			intersection.add(x, y);</span>
		}

<span class="fc" id="L1643">		MultiPoint boundary_a_b = (MultiPoint) (polyline_a.getBoundary());</span>
<span class="fc" id="L1644">		MultiPoint boundary_b = (MultiPoint) (polyline_b.getBoundary());</span>

<span class="fc" id="L1646">		boundary_a_b.add(boundary_b, 0, boundary_b.getPointCount());</span>

<span class="fc" id="L1648">		return multiPointContainsMultiPointBrute_(boundary_a_b, intersection,</span>
				tolerance);
	}

	// Returns true if polyline_a crosses polyline_b.
	private static boolean polylineCrossesPolyline_(Polyline polyline_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1657" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1659">			return false;</span>

<span class="fc" id="L1661">		AttributeStreamOfDbl intersections = new AttributeStreamOfDbl(0);</span>

<span class="fc" id="L1663">		int dim = linearPathIntersectsLinearPathMaxDim_(polyline_a, polyline_b,</span>
				tolerance, intersections);

<span class="fc bfc" id="L1666" title="All 2 branches covered.">		if (dim != 0)</span>
<span class="fc" id="L1667">			return false;</span>

<span class="fc" id="L1669">		MultiPoint intersection = new MultiPoint();</span>

<span class="fc bfc" id="L1671" title="All 2 branches covered.">		for (int i = 0; i &lt; intersections.size(); i += 2) {</span>
<span class="fc" id="L1672">			double x = intersections.read(i);</span>
<span class="fc" id="L1673">			double y = intersections.read(i + 1);</span>
<span class="fc" id="L1674">			intersection.add(x, y);</span>
		}

<span class="fc" id="L1677">		MultiPoint boundary_a_b = (MultiPoint) (polyline_a.getBoundary());</span>
<span class="fc" id="L1678">		MultiPoint boundary_b = (MultiPoint) (polyline_b.getBoundary());</span>

<span class="fc" id="L1680">		boundary_a_b.add(boundary_b, 0, boundary_b.getPointCount());</span>

<span class="fc bfc" id="L1682" title="All 2 branches covered.">		return !multiPointContainsMultiPointBrute_(boundary_a_b, intersection,</span>
				tolerance);
	}

	// Returns true if polyline_a overlaps polyline_b.
	private static boolean polylineOverlapsPolyline_(Polyline polyline_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1693">			return false;</span>

<span class="fc" id="L1695">		return linearPathOverlapsLinearPath_(polyline_a, polyline_b, tolerance);</span>
	}

	// Returns true if polyline_a contains polyline_b.
	private static boolean polylineContainsPolyline_(Polyline polyline_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L1702">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L1703">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1704">		polyline_b.queryEnvelope2D(env_b);</span>

		// Quick envelope rejection test for false equality.
<span class="fc bfc" id="L1707" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="fc" id="L1708">			return false;</span>

		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1711" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1713">			return false;</span>

<span class="fc" id="L1715">		return linearPathWithinLinearPath_(polyline_b, polyline_a, tolerance, false);</span>
	}

	// Returns true if polyline_a is disjoint from point_b.
	private static boolean polylineDisjointPoint_(Polyline polyline_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1722" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1724">			return true;</span>

<span class="fc" id="L1726">		Point2D pt_b = point_b.getXY();</span>
<span class="fc bfc" id="L1727" title="All 2 branches covered.">		return !linearPathIntersectsPoint_(polyline_a, pt_b, tolerance);</span>
	}

	// Returns true if polyline_a touches point_b.
	private static boolean polylineTouchesPoint_(Polyline polyline_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1734" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1736">			return false;</span>

<span class="fc" id="L1738">		Point2D pt_b = point_b.getXY();</span>
<span class="fc" id="L1739">		return linearPathTouchesPointImpl_(polyline_a, pt_b, tolerance);</span>
	}

	// Returns true of polyline_a contains point_b.
	private static boolean polylineContainsPoint_(Polyline polyline_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1746" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,</span>
				false) == Relation.disjoint)
<span class="nc" id="L1748">			return false;</span>

<span class="fc" id="L1750">		Point2D pt_b = point_b.getXY();</span>
<span class="fc" id="L1751">		return linearPathContainsPoint_(polyline_a, pt_b, tolerance);</span>
	}

	// Returns true if polyline_a is disjoint from multipoint_b.
	private static boolean polylineDisjointMultiPoint_(Polyline polyline_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,</span>
				tolerance, false) == Relation.disjoint)
<span class="nc" id="L1761">			return true;</span>

<span class="fc bfc" id="L1763" title="All 2 branches covered.">		return !linearPathIntersectsMultiPoint_(polyline_a, multipoint_b,</span>
				tolerance, false);
	}

	// Returns true if polyline_a touches multipoint_b.
	private static boolean polylineTouchesMultiPoint_(Polyline polyline_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,</span>
				tolerance, false) == Relation.disjoint) {
<span class="nc" id="L1774">			return false;</span>
		}

<span class="fc" id="L1777">		SegmentIteratorImpl segIterA = ((MultiPathImpl) polyline_a._getImpl())</span>
<span class="fc" id="L1778">				.querySegmentIterator();</span>

<span class="fc" id="L1780">		Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L1781">		Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L1782">		Envelope2D envInter = new Envelope2D();</span>
<span class="fc" id="L1783">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1784">		multipoint_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L1785">		env_a.inflate(tolerance, tolerance);</span>
<span class="fc" id="L1786">		env_b.inflate(tolerance, tolerance);</span>
<span class="fc" id="L1787">		envInter.setCoords(env_a);</span>
<span class="fc" id="L1788">		envInter.intersect(env_b);</span>

<span class="fc" id="L1790">		QuadTreeImpl qtA = null;</span>
<span class="fc" id="L1791">		QuadTreeImpl quadTreeA = null;</span>
<span class="fc" id="L1792">        QuadTreeImpl quadTreePathsA = null;</span>

<span class="fc" id="L1794">		GeometryAccelerators accel = ((MultiPathImpl) (polyline_a._getImpl()))</span>
<span class="fc" id="L1795">				._getAccelerators();</span>

<span class="fc bfc" id="L1797" title="All 2 branches covered.">		if (accel != null) {</span>
<span class="fc" id="L1798">			quadTreeA = accel.getQuadTree();</span>
<span class="fc" id="L1799">            quadTreePathsA = accel.getQuadTreeForPaths();</span>
<span class="pc bpc" id="L1800" title="1 of 2 branches missed.">			if (quadTreeA == null) {</span>
<span class="fc" id="L1801">				qtA = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L1802">						(MultiPathImpl) polyline_a._getImpl(), envInter);</span>
<span class="fc" id="L1803">				quadTreeA = qtA;</span>
			}
		} else {
<span class="fc" id="L1806">			qtA = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L1807">					(MultiPathImpl) polyline_a._getImpl(), envInter);</span>
<span class="fc" id="L1808">			quadTreeA = qtA;</span>
		}

<span class="fc" id="L1811">		QuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();</span>

<span class="fc" id="L1813">        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;</span>
<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">        if (quadTreePathsA != null)</span>
<span class="nc" id="L1815">            qtIterPathsA = quadTreePathsA.getIterator();</span>

<span class="fc" id="L1817">		Point2D ptB = new Point2D(), closest = new Point2D();</span>
<span class="fc" id="L1818">		boolean b_intersects = false;</span>
<span class="fc" id="L1819">		double toleranceSq = tolerance * tolerance;</span>

<span class="fc" id="L1821">		AttributeStreamOfInt8 intersects = new AttributeStreamOfInt8(</span>
<span class="fc" id="L1822">				multipoint_b.getPointCount());</span>
<span class="fc bfc" id="L1823" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc" id="L1824">			intersects.write(i, (byte) 0);</span>
		}

<span class="fc bfc" id="L1827" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc" id="L1828">			multipoint_b.getXY(i, ptB);</span>

<span class="pc bpc" id="L1830" title="1 of 2 branches missed.">			if (!envInter.contains(ptB)) {</span>
<span class="nc" id="L1831">				continue;</span>
			}

<span class="fc" id="L1834">			env_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);</span>

<span class="pc bpc" id="L1836" title="1 of 2 branches missed.">            if (qtIterPathsA != null) {</span>
<span class="nc" id="L1837">                qtIterPathsA.resetIterator(env_b, tolerance);</span>

<span class="nc bnc" id="L1839" title="All 2 branches missed.">                if (qtIterPathsA.next() == -1)</span>
<span class="nc" id="L1840">                    continue;</span>
            }

<span class="fc" id="L1843">			qtIterA.resetIterator(env_b, tolerance);</span>

<span class="fc bfc" id="L1845" title="All 2 branches covered.">			for (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA</span>
<span class="fc" id="L1846">					.next()) {</span>
<span class="fc" id="L1847">				int vertex_a = quadTreeA.getElement(elementHandleA);</span>
<span class="fc" id="L1848">				segIterA.resetToVertex(vertex_a);</span>

<span class="fc" id="L1850">				Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L1851">				double t = segmentA.getClosestCoordinate(ptB, false);</span>
<span class="fc" id="L1852">				segmentA.getCoord2D(t, closest);</span>

<span class="fc bfc" id="L1854" title="All 2 branches covered.">				if (Point2D.sqrDistance(ptB, closest) &lt;= toleranceSq) {</span>
<span class="fc" id="L1855">					intersects.write(i, (byte) 1);</span>
<span class="fc" id="L1856">					b_intersects = true;</span>
<span class="fc" id="L1857">					break;</span>
				}
			}
		}

<span class="fc bfc" id="L1862" title="All 2 branches covered.">		if (!b_intersects) {</span>
<span class="fc" id="L1863">			return false;</span>
		}

<span class="fc" id="L1866">		MultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());</span>
<span class="fc" id="L1867">		MultiPoint multipoint_b_inter = new MultiPoint();</span>
<span class="fc" id="L1868">		Point2D pt = new Point2D();</span>

<span class="fc bfc" id="L1870" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">			if (intersects.read(i) == 0) {</span>
<span class="fc" id="L1872">				continue;</span>
			}

<span class="fc" id="L1875">			multipoint_b.getXY(i, pt);</span>
<span class="fc" id="L1876">			multipoint_b_inter.add(pt.x, pt.y);</span>
		}

<span class="fc" id="L1879">		return multiPointContainsMultiPointBrute_(boundary_a,</span>
				multipoint_b_inter, tolerance);
	}

	// Returns true if polyline_a crosses multipoint_b.
	private static boolean polylineCrossesMultiPoint_(Polyline polyline_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L1888" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,</span>
				tolerance, false) == Relation.disjoint) {
<span class="nc" id="L1890">			return false;</span>
		}

<span class="fc" id="L1893">		SegmentIteratorImpl segIterA = ((MultiPathImpl) polyline_a._getImpl())</span>
<span class="fc" id="L1894">				.querySegmentIterator();</span>

<span class="fc" id="L1896">		Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L1897">		Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L1898">		Envelope2D envInter = new Envelope2D();</span>
<span class="fc" id="L1899">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L1900">		multipoint_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L1901">		env_a.inflate(tolerance, tolerance);</span>
<span class="fc" id="L1902">		env_b.inflate(tolerance, tolerance);</span>
<span class="fc" id="L1903">		envInter.setCoords(env_a);</span>
<span class="fc" id="L1904">		envInter.intersect(env_b);</span>

<span class="fc" id="L1906">		QuadTreeImpl qtA = null;</span>
<span class="fc" id="L1907">		QuadTreeImpl quadTreeA = null;</span>
<span class="fc" id="L1908">        QuadTreeImpl quadTreePathsA = null;</span>

<span class="fc" id="L1910">		GeometryAccelerators accel = ((MultiPathImpl) (polyline_a._getImpl()))</span>
<span class="fc" id="L1911">				._getAccelerators();</span>

<span class="fc bfc" id="L1913" title="All 2 branches covered.">		if (accel != null) {</span>
<span class="fc" id="L1914">			quadTreeA = accel.getQuadTree();</span>
<span class="fc" id="L1915">            quadTreePathsA = accel.getQuadTreeForPaths();</span>
<span class="pc bpc" id="L1916" title="1 of 2 branches missed.">			if (quadTreeA == null) {</span>
<span class="fc" id="L1917">				qtA = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L1918">						(MultiPathImpl) polyline_a._getImpl(), envInter);</span>
<span class="fc" id="L1919">				quadTreeA = qtA;</span>
			}
		} else {
<span class="fc" id="L1922">			qtA = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L1923">					(MultiPathImpl) polyline_a._getImpl(), envInter);</span>
<span class="fc" id="L1924">			quadTreeA = qtA;</span>
		}

<span class="fc" id="L1927">		QuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();</span>

<span class="fc" id="L1929">        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;</span>
<span class="pc bpc" id="L1930" title="1 of 2 branches missed.">        if (quadTreePathsA != null)</span>
<span class="nc" id="L1931">            qtIterPathsA = quadTreePathsA.getIterator();</span>

<span class="fc" id="L1933">        Point2D ptB = new Point2D(), closest = new Point2D();</span>
<span class="fc" id="L1934">		boolean b_intersects = false;</span>
<span class="fc" id="L1935">		boolean b_exterior_found = false;</span>
<span class="fc" id="L1936">		double toleranceSq = tolerance * tolerance;</span>

<span class="fc" id="L1938">		AttributeStreamOfInt8 intersects = new AttributeStreamOfInt8(</span>
<span class="fc" id="L1939">				multipoint_b.getPointCount());</span>
<span class="fc bfc" id="L1940" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc" id="L1941">			intersects.write(i, (byte) 0);</span>
		}

<span class="fc bfc" id="L1944" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc" id="L1945">			multipoint_b.getXY(i, ptB);</span>

<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">			if (!envInter.contains(ptB)) {</span>
<span class="nc" id="L1948">				b_exterior_found = true;</span>
<span class="nc" id="L1949">				continue;</span>
			}

<span class="fc" id="L1952">			env_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);</span>

<span class="pc bpc" id="L1954" title="1 of 2 branches missed.">            if (qtIterPathsA != null) {</span>
<span class="nc" id="L1955">                qtIterPathsA.resetIterator(env_b, tolerance);</span>

<span class="nc bnc" id="L1957" title="All 2 branches missed.">                if (qtIterPathsA.next() == -1) {</span>
<span class="nc" id="L1958">                    b_exterior_found = true;</span>
<span class="nc" id="L1959">                    continue;</span>
                }
            }

<span class="fc" id="L1963">			qtIterA.resetIterator(env_b, tolerance);</span>

<span class="fc" id="L1965">			boolean b_covered = false;</span>

<span class="fc bfc" id="L1967" title="All 2 branches covered.">			for (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA</span>
<span class="fc" id="L1968">					.next()) {</span>
<span class="fc" id="L1969">				int vertex_a = quadTreeA.getElement(elementHandleA);</span>
<span class="fc" id="L1970">				segIterA.resetToVertex(vertex_a);</span>

<span class="fc" id="L1972">				Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L1973">				double t = segmentA.getClosestCoordinate(ptB, false);</span>
<span class="fc" id="L1974">				segmentA.getCoord2D(t, closest);</span>

<span class="fc bfc" id="L1976" title="All 2 branches covered.">				if (Point2D.sqrDistance(ptB, closest) &lt;= toleranceSq) {</span>
<span class="fc" id="L1977">					intersects.write(i, (byte) 1);</span>
<span class="fc" id="L1978">					b_intersects = true;</span>
<span class="fc" id="L1979">					b_covered = true;</span>
<span class="fc" id="L1980">					break;</span>
				}
			}

<span class="fc bfc" id="L1984" title="All 2 branches covered.">			if (!b_covered) {</span>
<span class="fc" id="L1985">				b_exterior_found = true;</span>
			}
		}

<span class="pc bpc" id="L1989" title="2 of 4 branches missed.">		if (!b_intersects || !b_exterior_found) {</span>
<span class="nc" id="L1990">			return false;</span>
		}

<span class="fc" id="L1993">		MultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());</span>
<span class="fc" id="L1994">		MultiPoint multipoint_b_inter = new MultiPoint();</span>
<span class="fc" id="L1995">		Point2D pt = new Point2D();</span>

<span class="fc bfc" id="L1997" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc bfc" id="L1998" title="All 2 branches covered.">			if (intersects.read(i) == 0) {</span>
<span class="fc" id="L1999">				continue;</span>
			}

<span class="fc" id="L2002">			multipoint_b.getXY(i, pt);</span>
<span class="fc" id="L2003">			multipoint_b_inter.add(pt.x, pt.y);</span>
		}

<span class="fc bfc" id="L2006" title="All 2 branches covered.">		return !multiPointContainsMultiPointBrute_(boundary_a,</span>
				multipoint_b_inter, tolerance);
	}

	// Returns true if polyline_a contains multipoint_b.
	private static boolean polylineContainsMultiPoint_(Polyline polyline_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2014">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2015">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2016">		multipoint_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2018" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="fc" id="L2019">			return false;</span>

		// Quick rasterize test to see whether the the geometries are disjoint.
<span class="pc bpc" id="L2022" title="1 of 2 branches missed.">		if (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,</span>
				tolerance, false) == Relation.disjoint)
<span class="nc" id="L2024">			return false;</span>

<span class="fc bfc" id="L2026" title="All 2 branches covered.">		if (!linearPathIntersectsMultiPoint_(polyline_a, multipoint_b,</span>
				tolerance, true))
<span class="fc" id="L2028">			return false;</span>

<span class="fc" id="L2030">		MultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());</span>
<span class="pc bpc" id="L2031" title="1 of 2 branches missed.">		return !multiPointIntersectsMultiPoint_(boundary_a, multipoint_b,</span>
				tolerance, progress_tracker);
	}

	// Returns true if polyline_a equals envelope_b.
	private static boolean polylineEqualsEnvelope_(Polyline polyline_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2039">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2040">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2041">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2043" title="All 4 branches covered.">		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</span>
<span class="fc" id="L2044">			return false; // area cannot equal a line</span>

<span class="fc" id="L2046">		return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polyline_a is disjoint from envelope_b.
	private static boolean polylineDisjointEnvelope_(Polyline polyline_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2054">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2055">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2056">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2058" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L2059">			return false;</span>

<span class="fc bfc" id="L2061" title="All 2 branches covered.">		return !linearPathIntersectsEnvelope_(polyline_a, env_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if polyline_a touches envelope_b.
	private static boolean polylineTouchesEnvelope_(Polyline polyline_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2069">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2070">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2071">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2073" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {// Treat</span>
																				// as
																				// point
<span class="fc" id="L2076">			Point2D pt_b = envelope_b.getCenterXY();</span>
<span class="fc" id="L2077">			return linearPathTouchesPointImpl_(polyline_a, pt_b, tolerance);</span>
		}

<span class="fc bfc" id="L2080" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// Treat</span>
																				// as
																				// polyline
<span class="fc" id="L2083">			Polyline polyline_b = new Polyline();</span>
<span class="fc" id="L2084">			Point p = new Point();</span>
<span class="fc" id="L2085">			envelope_b.queryCornerByVal(0, p);</span>
<span class="fc" id="L2086">			polyline_b.startPath(p);</span>
<span class="fc" id="L2087">			envelope_b.queryCornerByVal(2, p);</span>
<span class="fc" id="L2088">			polyline_b.lineTo(p);</span>
<span class="fc" id="L2089">			return polylineTouchesPolyline_(polyline_a, polyline_b, tolerance,</span>
					progress_tracker);
		}

		// Treat env_b as area

<span class="fc" id="L2095">		SegmentIterator seg_iter_a = polyline_a.querySegmentIterator();</span>
<span class="fc" id="L2096">		Envelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L2097">		env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2098">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2099">		env_b_deflated.inflate(-tolerance, -tolerance);</span>
<span class="fc" id="L2100">		env_b_inflated.inflate(tolerance, tolerance);</span>

<span class="fc" id="L2102">		boolean b_boundary = false;</span>
<span class="fc" id="L2103">		Envelope2D env_segment_a = new Envelope2D();</span>
<span class="fc" id="L2104">		Envelope2D env_inter = new Envelope2D();</span>

<span class="fc bfc" id="L2106" title="All 2 branches covered.">		while (seg_iter_a.nextPath()) {</span>
<span class="fc bfc" id="L2107" title="All 2 branches covered.">			while (seg_iter_a.hasNextSegment()) {</span>
<span class="fc" id="L2108">				Segment segment_a = seg_iter_a.nextSegment();</span>
<span class="fc" id="L2109">				segment_a.queryEnvelope2D(env_segment_a);</span>

<span class="fc" id="L2111">				env_inter.setCoords(env_b_deflated);</span>
<span class="fc" id="L2112">				env_inter.intersect(env_segment_a);</span>

<span class="fc bfc" id="L2114" title="All 2 branches covered.">				if (!env_inter.isEmpty()</span>
<span class="fc bfc" id="L2115" title="All 2 branches covered.">						&amp;&amp; (env_inter.getHeight() &gt; tolerance || env_inter</span>
<span class="pc bpc" id="L2116" title="1 of 2 branches missed.">								.getWidth() &gt; tolerance))</span>
<span class="fc" id="L2117">					return false; // consider segment within</span>

<span class="fc" id="L2119">				env_inter.setCoords(env_b_inflated);</span>
<span class="fc" id="L2120">				env_inter.intersect(env_segment_a);</span>

<span class="fc bfc" id="L2122" title="All 2 branches covered.">				if (!env_inter.isEmpty())</span>
<span class="fc" id="L2123">					b_boundary = true;</span>
<span class="fc" id="L2124">			}</span>
		}

<span class="fc" id="L2127">		return b_boundary;</span>
	}

	// Returns true if polyline_a overlaps envelope_b.
	private static boolean polylineOverlapsEnvelope_(Polyline polyline_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2134">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2135">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2136">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2138" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">				|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L2140">			return false;</span>

<span class="pc bpc" id="L2142" title="1 of 2 branches missed.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="nc" id="L2143">			return false;</span>

<span class="fc bfc" id="L2145" title="All 4 branches covered.">		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</span>
<span class="fc" id="L2146">			return false; // lines cannot overlap areas</span>

<span class="pc bpc" id="L2148" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="nc" id="L2149">			return false; // lines cannot overlap points</span>

		// Treat as polyline
<span class="fc" id="L2152">		Polyline polyline_b = new Polyline();</span>
<span class="fc" id="L2153">		Point p = new Point();</span>
<span class="fc" id="L2154">		envelope_b.queryCornerByVal(0, p);</span>
<span class="fc" id="L2155">		polyline_b.startPath(p);</span>
<span class="fc" id="L2156">		envelope_b.queryCornerByVal(2, p);</span>
<span class="fc" id="L2157">		polyline_b.lineTo(p);</span>
<span class="fc" id="L2158">		return linearPathOverlapsLinearPath_(polyline_a, polyline_b, tolerance);</span>
	}

	// Returns true if polyline_a is within envelope_b.
	private static boolean polylineWithinEnvelope_(Polyline polyline_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2165">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2166">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2167">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2169" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L2170">			return false;</span>

<span class="pc bpc" id="L2172" title="3 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="nc" id="L2173">			return false;</span>

<span class="pc bpc" id="L2175" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L2176">			return envelopeInfContainsEnvelope_(env_b, env_a, tolerance);</span>

<span class="fc" id="L2178">		SegmentIterator seg_iter_a = polyline_a.querySegmentIterator();</span>
<span class="fc" id="L2179">		Envelope2D env_b_deflated = new Envelope2D();</span>
<span class="fc" id="L2180">		env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2181">		env_b_deflated.inflate(-tolerance, -tolerance);</span>

<span class="fc" id="L2183">		boolean b_interior = false;</span>
<span class="fc" id="L2184">		Envelope2D env_segment_a = new Envelope2D();</span>
<span class="fc" id="L2185">		Envelope2D env_inter = new Envelope2D();</span>

<span class="fc bfc" id="L2187" title="All 2 branches covered.">		while (seg_iter_a.nextPath()) {</span>
<span class="fc bfc" id="L2188" title="All 2 branches covered.">			while (seg_iter_a.hasNextSegment()) {</span>
<span class="fc" id="L2189">				Segment segment_a = seg_iter_a.nextSegment();</span>
<span class="fc" id="L2190">				segment_a.queryEnvelope2D(env_segment_a);</span>

<span class="fc bfc" id="L2192" title="All 2 branches covered.">				if (env_b_deflated.containsExclusive(env_segment_a)) {</span>
<span class="fc" id="L2193">					b_interior = true;</span>
<span class="fc" id="L2194">					continue;</span>
				}

<span class="fc" id="L2197">				env_inter.setCoords(env_b_deflated);</span>
<span class="fc" id="L2198">				env_inter.intersect(env_segment_a);</span>

<span class="fc bfc" id="L2200" title="All 2 branches covered.">				if (!env_inter.isEmpty()</span>
<span class="pc bpc" id="L2201" title="1 of 2 branches missed.">						&amp;&amp; (env_inter.getHeight() &gt; tolerance || env_inter</span>
<span class="nc bnc" id="L2202" title="All 2 branches missed.">								.getWidth() &gt; tolerance))</span>
<span class="fc" id="L2203">					b_interior = true;</span>
<span class="fc" id="L2204">			}</span>
		}

<span class="fc" id="L2207">		return b_interior;</span>
	}

	// Returns true if polyline_a contains envelope_b.
	private static boolean polylineContainsEnvelope_(Polyline polyline_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2214">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2215">		envelope_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L2216">		polyline_a.queryEnvelope2D(env_a);</span>

<span class="fc bfc" id="L2218" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="fc" id="L2219">			return false;</span>

<span class="pc bpc" id="L2221" title="1 of 4 branches missed.">		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</span>
<span class="fc" id="L2222">			return false; // when treated as an area, lines cannot contain</span>
							// areas.

<span class="pc bpc" id="L2225" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {// Treat</span>
																				// as
																				// point
<span class="fc" id="L2228">			Point2D pt_b = envelope_b.getCenterXY();</span>
<span class="fc" id="L2229">			return linearPathContainsPoint_(polyline_a, pt_b, tolerance);</span>
		}

		// Treat as polyline
<span class="fc" id="L2233">		Polyline polyline_b = new Polyline();</span>
<span class="fc" id="L2234">		Point p = new Point();</span>
<span class="fc" id="L2235">		envelope_b.queryCornerByVal(0, p);</span>
<span class="fc" id="L2236">		polyline_b.startPath(p);</span>
<span class="fc" id="L2237">		envelope_b.queryCornerByVal(2, p);</span>
<span class="fc" id="L2238">		polyline_b.lineTo(p);</span>
<span class="fc" id="L2239">		return linearPathWithinLinearPath_(polyline_b, polyline_a, tolerance, false);</span>
	}

	// Returns true if polyline_a crosses envelope_b.
	private static boolean polylineCrossesEnvelope_(Polyline polyline_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2246">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2247">		polyline_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2248">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2250" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L2251">			return false;</span>

<span class="fc bfc" id="L2253" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L2254">			return false; // when treated as a point, lines cannot cross points.</span>

<span class="fc bfc" id="L2256" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// Treat</span>
																				// as
																				// polyline
<span class="fc" id="L2259">			Polyline polyline_b = new Polyline();</span>
<span class="fc" id="L2260">			Point p = new Point();</span>
<span class="fc" id="L2261">			envelope_b.queryCornerByVal(0, p);</span>
<span class="fc" id="L2262">			polyline_b.startPath(p);</span>
<span class="fc" id="L2263">			envelope_b.queryCornerByVal(2, p);</span>
<span class="fc" id="L2264">			polyline_b.lineTo(p);</span>
<span class="fc" id="L2265">			return polylineCrossesPolyline_(polyline_a, polyline_b, tolerance,</span>
					progress_tracker);
		}

		// Treat env_b as area

<span class="fc" id="L2271">		SegmentIterator seg_iter_a = polyline_a.querySegmentIterator();</span>
<span class="fc" id="L2272">		Envelope2D env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();</span>
<span class="fc" id="L2273">		env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2274">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2275">		env_b_deflated.inflate(-tolerance, -tolerance);</span>
<span class="fc" id="L2276">		env_b_inflated.inflate(tolerance, tolerance);</span>

<span class="fc" id="L2278">		boolean b_interior = false, b_exterior = false;</span>
<span class="fc" id="L2279">		Envelope2D env_segment_a = new Envelope2D();</span>
<span class="fc" id="L2280">		Envelope2D env_inter = new Envelope2D();</span>

<span class="fc bfc" id="L2282" title="All 2 branches covered.">		while (seg_iter_a.nextPath()) {</span>
<span class="fc bfc" id="L2283" title="All 2 branches covered.">			while (seg_iter_a.hasNextSegment()) {</span>
<span class="fc" id="L2284">				Segment segment_a = seg_iter_a.nextSegment();</span>
<span class="fc" id="L2285">				segment_a.queryEnvelope2D(env_segment_a);</span>

<span class="fc bfc" id="L2287" title="All 2 branches covered.">				if (!b_exterior) {</span>
<span class="fc bfc" id="L2288" title="All 2 branches covered.">					if (!env_b_inflated.contains(env_segment_a))</span>
<span class="fc" id="L2289">						b_exterior = true;</span>
				}

<span class="fc bfc" id="L2292" title="All 2 branches covered.">				if (!b_interior) {</span>
<span class="fc" id="L2293">					env_inter.setCoords(env_b_deflated);</span>
<span class="fc" id="L2294">					env_inter.intersect(env_segment_a);</span>

<span class="fc bfc" id="L2296" title="All 2 branches covered.">					if (!env_inter.isEmpty()</span>
<span class="fc bfc" id="L2297" title="All 2 branches covered.">							&amp;&amp; (env_inter.getHeight() &gt; tolerance || env_inter</span>
<span class="pc bpc" id="L2298" title="1 of 2 branches missed.">									.getWidth() &gt; tolerance))</span>
<span class="fc" id="L2299">						b_interior = true;</span>
				}

<span class="fc bfc" id="L2302" title="All 4 branches covered.">				if (b_interior &amp;&amp; b_exterior)</span>
<span class="fc" id="L2303">					return true;</span>
<span class="fc" id="L2304">			}</span>
		}

<span class="fc" id="L2307">		return false;</span>
	}

	// Returns true if multipoint_a equals multipoint_b.
	private static boolean multiPointEqualsMultiPoint_(MultiPoint multipoint_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2314">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2315">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2316">		multipoint_b.queryEnvelope2D(env_b);</span>

<span class="pc bpc" id="L2318" title="1 of 2 branches missed.">		if (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))</span>
<span class="nc" id="L2319">			return false;</span>

<span class="fc bfc" id="L2321" title="All 2 branches covered.">		if (multiPointExactlyEqualsMultiPoint_(multipoint_a, multipoint_b,</span>
				tolerance, progress_tracker))
<span class="fc" id="L2323">			return true;</span>

<span class="fc" id="L2325">		return multiPointCoverageMultiPoint_(multipoint_a, multipoint_b,</span>
				tolerance, false, true, false, progress_tracker);
	}

	// Returns true if multipoint_a is disjoint from multipoint_b.
	private static boolean multiPointDisjointMultiPoint_(
			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2333" title="All 2 branches covered.">		return !multiPointIntersectsMultiPoint_(multipoint_a, multipoint_b,</span>
				tolerance, progress_tracker);
	}

	// Returns true if multipoint_a overlaps multipoint_b.
	private static boolean multiPointOverlapsMultiPoint_(
			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2341">		return multiPointCoverageMultiPoint_(multipoint_a, multipoint_b,</span>
				tolerance, false, false, true, progress_tracker);
	}

	// Returns true if multipoint_a contains multipoint_b.
	private static boolean multiPointContainsMultiPoint_(
			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2349">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2350">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2351">		multipoint_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2353" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="fc" id="L2354">			return false;</span>

<span class="fc" id="L2356">		return multiPointCoverageMultiPoint_(multipoint_b, multipoint_a,</span>
				tolerance, true, false, false, progress_tracker);
	}

	private static boolean multiPointContainsMultiPointBrute_(
			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance) {
<span class="fc" id="L2362">		double tolerance_sq = tolerance * tolerance;</span>
<span class="fc" id="L2363">		Point2D pt_a = new Point2D();</span>
<span class="fc" id="L2364">		Point2D pt_b = new Point2D();</span>

<span class="fc bfc" id="L2366" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc" id="L2367">			multipoint_b.getXY(i, pt_b);</span>
<span class="fc" id="L2368">			boolean b_contained = false;</span>

<span class="fc bfc" id="L2370" title="All 2 branches covered.">			for (int j = 0; j &lt; multipoint_a.getPointCount(); j++) {</span>
<span class="fc" id="L2371">				multipoint_a.getXY(j, pt_a);</span>

<span class="fc bfc" id="L2373" title="All 2 branches covered.">				if (Point2D.sqrDistance(pt_a, pt_b) &lt;= tolerance_sq) {</span>
<span class="fc" id="L2374">					b_contained = true;</span>
<span class="fc" id="L2375">					break;</span>
				}
			}

<span class="fc bfc" id="L2379" title="All 2 branches covered.">			if (!b_contained)</span>
<span class="fc" id="L2380">				return false;</span>
		}

<span class="fc" id="L2383">		return true;</span>
	}

	// Returns true if multipoint_a equals point_b.
	static boolean multiPointEqualsPoint_(MultiPoint multipoint_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L2389">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2390">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2391">		point_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L2392">		return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if multipoint_a is disjoint from point_b.
	private static boolean multiPointDisjointPoint_(MultiPoint multipoint_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L2399">		Point2D pt_b = point_b.getXY();</span>
<span class="fc" id="L2400">		return multiPointDisjointPointImpl_(multipoint_a, pt_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if multipoint_a is within point_b.
	private static boolean multiPointWithinPoint_(MultiPoint multipoint_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L2407">		return multiPointEqualsPoint_(multipoint_a, point_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if multipoint_a contains point_b.
	private static boolean multiPointContainsPoint_(MultiPoint multipoint_a,
			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2414" title="All 2 branches covered.">		return !multiPointDisjointPoint_(multipoint_a, point_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if multipoint_a equals envelope_b.
	private static boolean multiPointEqualsEnvelope_(MultiPoint multipoint_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2422">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2423">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2424">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2426" title="All 4 branches covered.">		if (env_b.getHeight() &gt; tolerance || env_b.getWidth() &gt; tolerance)</span>
<span class="fc" id="L2427">			return false;</span>

		// only true if all the points of the multi_point degenerate to a point
		// equal to the envelope
<span class="fc" id="L2431">		return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if multipoint_a is disjoint from envelope_b.
	private static boolean multiPointDisjointEnvelope_(MultiPoint multipoint_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2439">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2440">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2441">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2443" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L2444">			return false;</span>

<span class="fc" id="L2446">		Envelope2D env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L2447">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2448">		env_b_inflated.inflate(tolerance, tolerance);</span>
<span class="fc" id="L2449">		Point2D pt_a = new Point2D();</span>

<span class="fc bfc" id="L2451" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L2452">			multipoint_a.getXY(i, pt_a);</span>

<span class="fc bfc" id="L2454" title="All 2 branches covered.">			if (!env_b_inflated.contains(pt_a))</span>
<span class="fc" id="L2455">				continue;</span>

<span class="fc" id="L2457">			return false;</span>
		}

<span class="fc" id="L2460">		return true;</span>
	}

	// Returns true if multipoint_a touches envelope_b.
	private static boolean multiPointTouchesEnvelope_(MultiPoint multipoint_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2467">		Envelope2D env_b = new Envelope2D(), env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();</span>
<span class="fc" id="L2468">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2470" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L2471">			return false; // there are no boundaries to intersect</span>

<span class="pc bpc" id="L2473" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</span>
																				// as
																				// line

<span class="fc" id="L2477">			Point2D pt_a = new Point2D();</span>
<span class="fc" id="L2478">			boolean b_boundary = false;</span>

<span class="fc" id="L2480">			env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2481">			env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2482">			env_b_inflated.inflate(tolerance, tolerance);</span>
<span class="pc bpc" id="L2483" title="1 of 2 branches missed.">			if (env_b.getHeight() &gt; tolerance)</span>
<span class="nc" id="L2484">				env_b_deflated.inflate(0, -tolerance);</span>
			else
<span class="fc" id="L2486">				env_b_deflated.inflate(-tolerance, 0);</span>

<span class="fc bfc" id="L2488" title="All 2 branches covered.">			for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L2489">				multipoint_a.getXY(i, pt_a);</span>

<span class="fc bfc" id="L2491" title="All 2 branches covered.">				if (!env_b_inflated.contains(pt_a))</span>
<span class="fc" id="L2492">					continue;</span>

<span class="pc bpc" id="L2494" title="1 of 2 branches missed.">				if (env_b.getHeight() &gt; tolerance) {</span>
<span class="nc bnc" id="L2495" title="All 4 branches missed.">					if (pt_a.y &gt; env_b_deflated.ymin</span>
							&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)
<span class="nc" id="L2497">						return false;</span>

<span class="nc" id="L2499">					b_boundary = true;</span>
				} else {
<span class="fc bfc" id="L2501" title="All 4 branches covered.">					if (pt_a.x &gt; env_b_deflated.xmin</span>
							&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)
<span class="fc" id="L2503">						return false;</span>

<span class="fc" id="L2505">					b_boundary = true;</span>
				}
			}

<span class="fc" id="L2509">			return b_boundary;</span>
		}

		// treat as area
<span class="fc" id="L2513">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2514">		env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2515">		env_b_inflated.inflate(tolerance, tolerance);</span>
<span class="fc" id="L2516">		env_b_deflated.inflate(-tolerance, -tolerance);</span>

<span class="fc" id="L2518">		Point2D pt_a = new Point2D();</span>
<span class="fc" id="L2519">		boolean b_boundary = false;</span>

<span class="fc bfc" id="L2521" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L2522">			multipoint_a.getXY(i, pt_a);</span>

<span class="fc bfc" id="L2524" title="All 2 branches covered.">			if (!env_b_inflated.contains(pt_a))</span>
<span class="fc" id="L2525">				continue;</span>

<span class="fc bfc" id="L2527" title="All 2 branches covered.">			if (env_b_deflated.containsExclusive(pt_a))</span>
<span class="fc" id="L2528">				return false;</span>

<span class="fc" id="L2530">			b_boundary = true;</span>
		}

<span class="fc" id="L2533">		return b_boundary;</span>
	}

	// Returns true if multipoint_a is within envelope_b.
	private static boolean multiPointWithinEnvelope_(MultiPoint multipoint_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2540">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2541">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2542">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2544" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L2545">			return false;</span>

<span class="fc bfc" id="L2547" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L2548">			return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</span>
					progress_tracker); // treat as point

<span class="pc bpc" id="L2551" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</span>
																				// as
																				// line

<span class="fc" id="L2555">			boolean b_interior = false;</span>

<span class="fc" id="L2557">			Envelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L2558">			env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2559">			env_b_inflated.setCoords(env_b);</span>

<span class="pc bpc" id="L2561" title="1 of 2 branches missed.">			if (env_b.getHeight() &gt; tolerance)</span>
<span class="nc" id="L2562">				env_b_deflated.inflate(0, -tolerance);</span>
			else
<span class="fc" id="L2564">				env_b_deflated.inflate(-tolerance, 0);</span>

<span class="fc" id="L2566">			env_b_inflated.inflate(tolerance, tolerance);</span>

<span class="fc" id="L2568">			Point2D pt_a = new Point2D();</span>

<span class="fc bfc" id="L2570" title="All 2 branches covered.">			for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L2571">				multipoint_a.getXY(i, pt_a);</span>

<span class="pc bpc" id="L2573" title="1 of 2 branches missed.">				if (!env_b_inflated.contains(pt_a))</span>
<span class="nc" id="L2574">					return false;</span>

<span class="pc bpc" id="L2576" title="1 of 2 branches missed.">				if (env_b.getHeight() &gt; tolerance) {</span>
<span class="nc bnc" id="L2577" title="All 4 branches missed.">					if (pt_a.y &gt; env_b_deflated.ymin</span>
							&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)
<span class="nc" id="L2579">						b_interior = true;</span>
				} else {
<span class="fc bfc" id="L2581" title="All 4 branches covered.">					if (pt_a.x &gt; env_b_deflated.xmin</span>
							&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)
<span class="fc" id="L2583">						b_interior = true;</span>
				}
			}

<span class="fc" id="L2587">			return b_interior;</span>
		}

		// treat as area

<span class="fc" id="L2592">		boolean b_interior = false;</span>

<span class="fc" id="L2594">		Envelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L2595">		env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2596">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2597">		env_b_deflated.inflate(-tolerance, -tolerance);</span>
<span class="fc" id="L2598">		env_b_inflated.inflate(tolerance, tolerance);</span>

<span class="fc" id="L2600">		Point2D pt_a = new Point2D();</span>

		// we loop to find a proper interior intersection (i.e. something inside
		// instead of just on the boundary)
<span class="fc bfc" id="L2604" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L2605">			multipoint_a.getXY(i, pt_a);</span>

<span class="pc bpc" id="L2607" title="1 of 2 branches missed.">			if (!env_b_inflated.contains(pt_a))</span>
<span class="nc" id="L2608">				return false;</span>

<span class="fc bfc" id="L2610" title="All 2 branches covered.">			if (env_b_deflated.containsExclusive(pt_a))</span>
<span class="fc" id="L2611">				b_interior = true;</span>
		}

<span class="fc" id="L2614">		return b_interior;</span>
	}

	// Returns true if multipoint_a contains envelope_b.
	private static boolean multiPointContainsEnvelope_(MultiPoint multipoint_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2621">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2622">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2623">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="pc bpc" id="L2625" title="1 of 2 branches missed.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="nc" id="L2626">			return false;</span>

<span class="pc bpc" id="L2628" title="1 of 4 branches missed.">		if (env_b.getHeight() &gt; tolerance || env_b.getWidth() &gt; tolerance)</span>
<span class="fc" id="L2629">			return false;</span>

<span class="fc" id="L2631">		Point2D pt_b = envelope_b.getCenterXY();</span>
<span class="pc bpc" id="L2632" title="1 of 2 branches missed.">		return !multiPointDisjointPointImpl_(multipoint_a, pt_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if multipoint_a crosses envelope_b.
	static boolean multiPointCrossesEnvelope_(MultiPoint multipoint_a,
			Envelope envelope_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L2640">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L2641">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L2642">		envelope_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L2644" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L2645">			return false;</span>

<span class="fc bfc" id="L2647" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L2648">			return false;</span>

<span class="pc bpc" id="L2650" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</span>
																				// as
																				// line
<span class="fc" id="L2653">			Envelope2D env_b_deflated = new Envelope2D();</span>
<span class="fc" id="L2654">			Envelope2D env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L2655">			env_b_deflated.setCoords(env_b);</span>

<span class="pc bpc" id="L2657" title="1 of 2 branches missed.">			if (env_b.getHeight() &gt; tolerance)</span>
<span class="nc" id="L2658">				env_b_deflated.inflate(0, -tolerance);</span>
			else
<span class="fc" id="L2660">				env_b_deflated.inflate(-tolerance, 0);</span>

<span class="fc" id="L2662">			env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2663">			env_b_inflated.inflate(tolerance, tolerance);</span>

<span class="fc" id="L2665">			Point2D pt_a = new Point2D();</span>
<span class="fc" id="L2666">			boolean b_interior = false, b_exterior = false;</span>

<span class="fc bfc" id="L2668" title="All 2 branches covered.">			for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L2669">				multipoint_a.getXY(i, pt_a);</span>

<span class="pc bpc" id="L2671" title="1 of 2 branches missed.">				if (!b_interior) {</span>
<span class="pc bpc" id="L2672" title="1 of 2 branches missed.">					if (env_b.getHeight() &gt; tolerance) {</span>
<span class="nc bnc" id="L2673" title="All 4 branches missed.">						if (pt_a.y &gt; env_b_deflated.ymin</span>
								&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)
<span class="nc" id="L2675">							b_interior = true;</span>
					} else {
<span class="fc bfc" id="L2677" title="All 4 branches covered.">						if (pt_a.x &gt; env_b_deflated.xmin</span>
								&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)
<span class="fc" id="L2679">							b_interior = true;</span>
					}
				}

<span class="pc bpc" id="L2683" title="1 of 4 branches missed.">				if (!b_exterior &amp;&amp; !env_b_inflated.contains(pt_a))</span>
<span class="fc" id="L2684">					b_exterior = true;</span>

<span class="pc bpc" id="L2686" title="1 of 4 branches missed.">				if (b_interior &amp;&amp; b_exterior)</span>
<span class="fc" id="L2687">					return true;</span>
			}

<span class="fc" id="L2690">			return false;</span>
		}

<span class="fc" id="L2693">		Envelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L2694">		env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2695">		env_b_deflated.inflate(-tolerance, -tolerance);</span>
<span class="pc bpc" id="L2696" title="1 of 2 branches missed.">		assert (!env_b_deflated.isEmpty());</span>

<span class="fc" id="L2698">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2699">		env_b_inflated.inflate(tolerance, tolerance);</span>

<span class="fc" id="L2701">		Point2D pt_a = new Point2D();</span>
<span class="fc" id="L2702">		boolean b_interior = false, b_exterior = false;</span>

<span class="fc bfc" id="L2704" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L2705">			multipoint_a.getXY(i, pt_a);</span>

<span class="fc bfc" id="L2707" title="All 4 branches covered.">			if (!b_interior &amp;&amp; env_b_deflated.containsExclusive(pt_a))</span>
<span class="fc" id="L2708">				b_interior = true;</span>

<span class="fc bfc" id="L2710" title="All 4 branches covered.">			if (!b_exterior &amp;&amp; !env_b_inflated.contains(pt_a))</span>
<span class="fc" id="L2711">				b_exterior = true;</span>

<span class="fc bfc" id="L2713" title="All 4 branches covered.">			if (b_interior &amp;&amp; b_exterior)</span>
<span class="fc" id="L2714">				return true;</span>
		}

<span class="fc" id="L2717">		return false;</span>
	}

	// Returns true if pt_a equals pt_b.
	private static boolean pointEqualsPoint_(Point2D pt_a, Point2D pt_b,
			double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2723" title="All 2 branches covered.">		if (Point2D.sqrDistance(pt_a, pt_b) &lt;= tolerance * tolerance)</span>
<span class="fc" id="L2724">			return true;</span>

<span class="fc" id="L2726">		return false;</span>
	}

	// Returns true if pt_a is disjoint from pt_b.
	private static boolean pointDisjointPoint_(Point2D pt_a, Point2D pt_b,
			double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2732" title="All 2 branches covered.">		if (Point2D.sqrDistance(pt_a, pt_b) &gt; tolerance * tolerance)</span>
<span class="fc" id="L2733">			return true;</span>

<span class="fc" id="L2735">		return false;</span>
	}

	// Returns true if pt_a contains pt_b.
	private static boolean pointContainsPoint_(Point2D pt_a, Point2D pt_b,
			double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L2741">		return pointEqualsPoint_(pt_a, pt_b, tolerance, progress_tracker);</span>
	}

	// Returns true if pt_a equals enve_b.
	private static boolean pointEqualsEnvelope_(Point2D pt_a, Envelope2D env_b,
			double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L2747">		Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L2748">		env_a.setCoords(pt_a);</span>
<span class="fc" id="L2749">		return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</span>
				progress_tracker);
	}

	// Returns true if pt_a is disjoint from env_b.
	static boolean pointDisjointEnvelope_(Point2D pt_a, Envelope2D env_b,
			double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L2756">		Envelope2D env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L2757">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2758">		env_b_inflated.inflate(tolerance, tolerance);</span>
<span class="fc bfc" id="L2759" title="All 2 branches covered.">		return !env_b_inflated.contains(pt_a);</span>
	}

	// Returns true if pt_a touches env_b.
	private static boolean pointTouchesEnvelope_(Point2D pt_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2765" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L2766">			return false; // when treates as a point, points cannot touch points</span>

<span class="fc" id="L2768">		Envelope2D env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();</span>

<span class="fc" id="L2770">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2771">		env_b_inflated.inflate(tolerance, tolerance);</span>

<span class="fc bfc" id="L2773" title="All 2 branches covered.">		if (!env_b_inflated.contains(pt_a))</span>
<span class="fc" id="L2774">			return false;</span>

<span class="pc bpc" id="L2776" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {</span>
<span class="fc" id="L2777">			env_b_deflated.setCoords(env_b);</span>

<span class="pc bpc" id="L2779" title="1 of 2 branches missed.">			if (env_b.getHeight() &gt; tolerance)</span>
<span class="nc" id="L2780">				env_b_deflated.inflate(0, -tolerance);</span>
			else
<span class="fc" id="L2782">				env_b_deflated.inflate(-tolerance, 0);</span>

<span class="pc bpc" id="L2784" title="1 of 2 branches missed.">			if (env_b.getHeight() &gt; tolerance) {</span>
<span class="nc bnc" id="L2785" title="All 4 branches missed.">				if (pt_a.y &gt; env_b_deflated.ymin</span>
						&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)
<span class="nc" id="L2787">					return false;</span>
			} else {
<span class="pc bpc" id="L2789" title="1 of 4 branches missed.">				if (pt_a.x &gt; env_b_deflated.xmin</span>
						&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)
<span class="fc" id="L2791">					return false;</span>
			}

<span class="fc" id="L2794">			return true;</span>
		}

<span class="fc" id="L2797">		env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2798">		env_b_deflated.inflate(-tolerance, -tolerance);</span>

<span class="fc bfc" id="L2800" title="All 2 branches covered.">		if (env_b_deflated.containsExclusive(pt_a))</span>
<span class="fc" id="L2801">			return false;</span>

<span class="fc" id="L2803">		return true;</span>
	}

	// Returns true if pt_a is within env_b.
	private static boolean pointWithinEnvelope_(Point2D pt_a, Envelope2D env_b,
			double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2809" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {</span>
			// assert(env_b_inflated.contains(pt_a)); // should contain if we
			// got to here (i.e. not disjoint)
<span class="fc" id="L2812">			return true;</span>
		}

<span class="pc bpc" id="L2815" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</span>
																				// as
																				// line
<span class="fc" id="L2818">			Envelope2D env_b_deflated = new Envelope2D();</span>
<span class="fc" id="L2819">			env_b_deflated.setCoords(env_b);</span>

<span class="pc bpc" id="L2821" title="1 of 2 branches missed.">			if (env_b.getHeight() &gt; tolerance)</span>
<span class="nc" id="L2822">				env_b_deflated.inflate(0, -tolerance);</span>
			else
<span class="fc" id="L2824">				env_b_deflated.inflate(-tolerance, 0);</span>

<span class="fc" id="L2826">			boolean b_interior = false;</span>

<span class="pc bpc" id="L2828" title="1 of 2 branches missed.">			if (env_b.getHeight() &gt; tolerance) {</span>
<span class="nc bnc" id="L2829" title="All 4 branches missed.">				if (pt_a.y &gt; env_b_deflated.ymin</span>
						&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)
<span class="nc" id="L2831">					b_interior = true;</span>
			} else {
<span class="fc bfc" id="L2833" title="All 4 branches covered.">				if (pt_a.x &gt; env_b_deflated.xmin</span>
						&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)
<span class="fc" id="L2835">					b_interior = true;</span>
			}

<span class="fc" id="L2838">			return b_interior;</span>
		}

		// treat as area

<span class="fc" id="L2843">		Envelope2D env_b_deflated = new Envelope2D();</span>
<span class="fc" id="L2844">		env_b_deflated.setCoords(env_b);</span>
<span class="fc" id="L2845">		env_b_deflated.inflate(-tolerance, -tolerance);</span>
<span class="fc" id="L2846">		return env_b_deflated.containsExclusive(pt_a);</span>
	}

	// Returns true if pt_a contains env_b.
	private static boolean pointContainsEnvelope_(Point2D pt_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L2852">		return pointEqualsEnvelope_(pt_a, env_b, tolerance, progress_tracker);</span>
	}

	// Returns true if env_a equals env_b.
	private static boolean envelopeEqualsEnvelope_(Envelope2D env_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2858" title="All 2 branches covered.">		return envelopeInfContainsEnvelope_(env_a, env_b, tolerance)</span>
<span class="fc bfc" id="L2859" title="All 2 branches covered.">				&amp;&amp; envelopeInfContainsEnvelope_(env_b, env_a, tolerance);</span>
	}

	// Returns true if env_a is disjoint from env_b.
	static boolean envelopeDisjointEnvelope_(Envelope2D env_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc" id="L2865">		Envelope2D env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L2866">		env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L2867">		env_b_inflated.inflate(tolerance, tolerance);</span>
<span class="fc bfc" id="L2868" title="All 2 branches covered.">		return !env_a.isIntersecting(env_b_inflated);</span>
	}

	// Returns true if env_a touches env_b.
	private static boolean envelopeTouchesEnvelope_(Envelope2D env_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2874" title="All 4 branches covered.">		if (env_a.getHeight() &lt;= tolerance &amp;&amp; env_a.getWidth() &lt;= tolerance) {// treat</span>
																				// env_a
																				// as
																				// point
<span class="fc" id="L2878">			Point2D pt_a = env_a.getCenter();</span>
<span class="fc" id="L2879">			return pointTouchesEnvelope_(pt_a, env_b, tolerance,</span>
					progress_tracker);
		}

<span class="fc bfc" id="L2883" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {// treat</span>
																				// env_b
																				// as
																				// point
<span class="fc" id="L2887">			Point2D pt_b = env_b.getCenter();</span>
<span class="fc" id="L2888">			return pointTouchesEnvelope_(pt_b, env_a, tolerance,</span>
					progress_tracker);
		}

		Envelope2D _env_a;
		Envelope2D _env_b;

<span class="fc bfc" id="L2895" title="All 2 branches covered.">		if (env_a.getHeight() &gt; tolerance</span>
<span class="fc bfc" id="L2896" title="All 2 branches covered.">				&amp;&amp; env_a.getWidth() &gt; tolerance</span>
<span class="pc bpc" id="L2897" title="1 of 4 branches missed.">				&amp;&amp; (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance)) {</span>
			// swap a and b
<span class="fc" id="L2899">			_env_a = env_b;</span>
<span class="fc" id="L2900">			_env_b = env_a;</span>
		} else {
<span class="fc" id="L2902">			_env_a = env_a;</span>
<span class="fc" id="L2903">			_env_b = env_b;</span>
		}

<span class="fc bfc" id="L2906" title="All 4 branches covered.">		if (_env_a.getHeight() &lt;= tolerance || _env_a.getWidth() &lt;= tolerance) {// treat</span>
																				// env_a
																				// as
																				// line

<span class="fc bfc" id="L2911" title="All 2 branches covered.">			if (_env_b.getHeight() &lt;= tolerance</span>
<span class="fc bfc" id="L2912" title="All 2 branches covered.">					|| _env_b.getWidth() &lt;= tolerance) {// treat env_b as line</span>

<span class="fc" id="L2914">				Line line_a = new Line(), line_b = new Line();</span>
<span class="fc" id="L2915">				double[] scalars_a = new double[2];</span>
<span class="fc" id="L2916">				double[] scalars_b = new double[2];</span>
<span class="fc" id="L2917">				Point2D pt = new Point2D();</span>
<span class="fc" id="L2918">				_env_a.queryLowerLeft(pt);</span>
<span class="fc" id="L2919">				line_a.setStartXY(pt);</span>
<span class="fc" id="L2920">				_env_a.queryUpperRight(pt);</span>
<span class="fc" id="L2921">				line_a.setEndXY(pt);</span>
<span class="fc" id="L2922">				_env_b.queryLowerLeft(pt);</span>
<span class="fc" id="L2923">				line_b.setStartXY(pt);</span>
<span class="fc" id="L2924">				_env_b.queryUpperRight(pt);</span>
<span class="fc" id="L2925">				line_b.setEndXY(pt);</span>

<span class="fc" id="L2927">				line_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);</span>
<span class="fc" id="L2928">				int count = line_a.intersect(line_b, null, null, null,</span>
						tolerance);

<span class="fc bfc" id="L2931" title="All 2 branches covered.">				if (count != 1)</span>
<span class="fc" id="L2932">					return false;</span>

<span class="pc bpc" id="L2934" title="2 of 8 branches missed.">				return scalars_a[0] == 0.0 || scalars_a[1] == 1.0</span>
						|| scalars_b[0] == 0.0 || scalars_b[1] == 1.0;
			}

			// treat env_b as area

<span class="fc" id="L2940">			Envelope2D env_b_deflated = new Envelope2D(), env_inter = new Envelope2D();</span>
<span class="fc" id="L2941">			env_b_deflated.setCoords(_env_b);</span>
<span class="fc" id="L2942">			env_b_deflated.inflate(-tolerance, -tolerance);</span>
<span class="fc" id="L2943">			env_inter.setCoords(env_b_deflated);</span>
<span class="fc" id="L2944">			env_inter.intersect(_env_a);</span>

<span class="fc bfc" id="L2946" title="All 2 branches covered.">			if (!env_inter.isEmpty()</span>
<span class="pc bpc" id="L2947" title="1 of 2 branches missed.">					&amp;&amp; (env_inter.getHeight() &gt; tolerance || env_inter</span>
<span class="pc bpc" id="L2948" title="1 of 2 branches missed.">							.getWidth() &gt; tolerance))</span>
<span class="fc" id="L2949">				return false;</span>

<span class="pc bpc" id="L2951" title="1 of 2 branches missed.">			assert (!envelopeDisjointEnvelope_(_env_a, _env_b, tolerance,</span>
					progress_tracker));
<span class="fc" id="L2953">			return true; // we already know they intersect within a tolerance</span>
		}

<span class="fc" id="L2956">		Envelope2D env_inter = new Envelope2D();</span>
<span class="fc" id="L2957">		env_inter.setCoords(_env_a);</span>
<span class="fc" id="L2958">		env_inter.intersect(_env_b);</span>

<span class="fc bfc" id="L2960" title="All 4 branches covered.">		if (!env_inter.isEmpty() &amp;&amp; env_inter.getHeight() &gt; tolerance</span>
<span class="pc bpc" id="L2961" title="1 of 2 branches missed.">				&amp;&amp; env_inter.getWidth() &gt; tolerance)</span>
<span class="fc" id="L2962">			return false;</span>

<span class="fc" id="L2964">		return true; // we already know they intersect within a tolerance</span>
	}

	// Returns true if env_a overlaps env_b.
	private static boolean envelopeOverlapsEnvelope_(Envelope2D env_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L2970" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)</span>
<span class="fc bfc" id="L2971" title="All 2 branches covered.">				|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L2972">			return false;</span>

<span class="pc bpc" id="L2974" title="1 of 4 branches missed.">		if (env_a.getHeight() &lt;= tolerance &amp;&amp; env_a.getWidth() &lt;= tolerance)</span>
<span class="nc" id="L2975">			return false; // points cannot overlap</span>

<span class="pc bpc" id="L2977" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="nc" id="L2978">			return false; // points cannot overlap</span>

<span class="fc bfc" id="L2980" title="All 4 branches covered.">		if (env_a.getHeight() &lt;= tolerance || env_a.getWidth() &lt;= tolerance) {// treat</span>
																				// env_a
																				// as
																				// a
																				// line

<span class="fc bfc" id="L2986" title="All 4 branches covered.">			if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</span>
<span class="fc" id="L2987">				return false; // lines cannot overlap areas</span>

			// treat both as lines

<span class="fc" id="L2991">			Line line_a = new Line(), line_b = new Line();</span>
<span class="fc" id="L2992">			double[] scalars_a = new double[2];</span>
<span class="fc" id="L2993">			double[] scalars_b = new double[2];</span>
<span class="fc" id="L2994">			Point2D pt = new Point2D();</span>
<span class="fc" id="L2995">			env_a.queryLowerLeft(pt);</span>
<span class="fc" id="L2996">			line_a.setStartXY(pt);</span>
<span class="fc" id="L2997">			env_a.queryUpperRight(pt);</span>
<span class="fc" id="L2998">			line_a.setEndXY(pt);</span>
<span class="fc" id="L2999">			env_b.queryLowerLeft(pt);</span>
<span class="fc" id="L3000">			line_b.setStartXY(pt);</span>
<span class="fc" id="L3001">			env_b.queryUpperRight(pt);</span>
<span class="fc" id="L3002">			line_b.setEndXY(pt);</span>

<span class="fc" id="L3004">			line_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);</span>
<span class="fc" id="L3005">			int count = line_a.intersect(line_b, null, null, null, tolerance);</span>

<span class="fc bfc" id="L3007" title="All 2 branches covered.">			if (count != 2)</span>
<span class="fc" id="L3008">				return false;</span>

<span class="pc bpc" id="L3010" title="2 of 8 branches missed.">			return (scalars_a[0] &gt; 0.0 || scalars_a[1] &lt; 1.0)</span>
					&amp;&amp; (scalars_b[0] &gt; 0.0 || scalars_b[1] &lt; 1.0);
		}

<span class="pc bpc" id="L3014" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L3015">			return false; // lines cannot overlap areas</span>

		// treat both as areas

<span class="fc" id="L3019">		Envelope2D env_inter = new Envelope2D();</span>
<span class="fc" id="L3020">		env_inter.setCoords(env_a);</span>
<span class="fc" id="L3021">		env_inter.intersect(env_b);</span>

<span class="fc bfc" id="L3023" title="All 2 branches covered.">		if (env_inter.isEmpty())</span>
<span class="fc" id="L3024">			return false;</span>

<span class="pc bpc" id="L3026" title="1 of 2 branches missed.">		if (env_inter.getHeight() &lt;= tolerance</span>
<span class="pc bpc" id="L3027" title="1 of 2 branches missed.">				|| env_inter.getWidth() &lt;= tolerance)</span>
<span class="nc" id="L3028">			return false; // not an area</span>

<span class="pc bpc" id="L3030" title="2 of 4 branches missed.">		assert (!envelopeInfContainsEnvelope_(env_inter, env_a, tolerance) &amp;&amp; !envelopeInfContainsEnvelope_(</span>
				env_inter, env_b, tolerance));

<span class="fc" id="L3033">		return true;</span>
	}

	// Returns true if env_a contains env_b.
	private static boolean envelopeContainsEnvelope_(Envelope2D env_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L3039" title="All 2 branches covered.">		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</span>
<span class="fc" id="L3040">			return false;</span>

<span class="fc bfc" id="L3042" title="All 4 branches covered.">		if (env_a.getHeight() &lt;= tolerance &amp;&amp; env_a.getWidth() &lt;= tolerance) {</span>
<span class="fc" id="L3043">			Point2D pt_a = env_a.getCenter();</span>
<span class="fc" id="L3044">			return pointWithinEnvelope_(pt_a, env_b, tolerance,</span>
					progress_tracker);
		}

<span class="fc bfc" id="L3048" title="All 4 branches covered.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {</span>
<span class="fc" id="L3049">			Point2D pt_b = env_b.getCenter();</span>
<span class="fc" id="L3050">			return pointWithinEnvelope_(pt_b, env_a, tolerance,</span>
					progress_tracker);
		}

<span class="pc bpc" id="L3054" title="1 of 4 branches missed.">		if (env_a.getHeight() &lt;= tolerance || env_a.getWidth() &lt;= tolerance)</span>
<span class="fc" id="L3055">			return envelopeInfContainsEnvelope_(env_a, env_b, tolerance); // treat</span>
																			// env_b
																			// as
																			// line

		// treat env_a as area

<span class="pc bpc" id="L3062" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</span>
																				// env_b
																				// as
																				// line

<span class="fc" id="L3067">			Envelope2D env_a_deflated = new Envelope2D();</span>
<span class="fc" id="L3068">			env_a_deflated.setCoords(env_a);</span>
<span class="fc" id="L3069">			env_a_deflated.inflate(-tolerance, -tolerance);</span>

<span class="fc bfc" id="L3071" title="All 2 branches covered.">			if (env_a_deflated.containsExclusive(env_b))</span>
<span class="fc" id="L3072">				return true;</span>

<span class="fc" id="L3074">			Envelope2D env_inter = new Envelope2D();</span>
<span class="fc" id="L3075">			env_inter.setCoords(env_a_deflated);</span>
<span class="fc" id="L3076">			env_inter.intersect(env_b);</span>

<span class="fc bfc" id="L3078" title="All 2 branches covered.">			if (env_inter.isEmpty()</span>
<span class="pc bpc" id="L3079" title="1 of 2 branches missed.">					|| (env_inter.getHeight() &lt;= tolerance &amp;&amp; env_inter</span>
<span class="pc bpc" id="L3080" title="1 of 2 branches missed.">							.getWidth() &lt;= tolerance))</span>
<span class="fc" id="L3081">				return false;</span>

<span class="fc" id="L3083">			return true;</span>
		}

<span class="fc" id="L3086">		return envelopeInfContainsEnvelope_(env_a, env_b, tolerance);</span>
	}

	// Returns true if env_a crosses env_b.
	private static boolean envelopeCrossesEnvelope_(Envelope2D env_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="fc bfc" id="L3092" title="All 2 branches covered.">		if (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)</span>
<span class="fc bfc" id="L3093" title="All 2 branches covered.">				|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</span>
<span class="fc" id="L3094">			return false;</span>

<span class="pc bpc" id="L3096" title="1 of 4 branches missed.">		if (env_a.getHeight() &lt;= tolerance &amp;&amp; env_a.getWidth() &lt;= tolerance)</span>
<span class="nc" id="L3097">			return false; // points cannot cross</span>

<span class="pc bpc" id="L3099" title="1 of 4 branches missed.">		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</span>
<span class="nc" id="L3100">			return false; // points cannot cross</span>

<span class="fc bfc" id="L3102" title="All 4 branches covered.">		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance) {</span>
<span class="pc bpc" id="L3103" title="1 of 4 branches missed.">			if (env_a.getHeight() &gt; tolerance &amp;&amp; env_a.getWidth() &gt; tolerance)</span>
<span class="fc" id="L3104">				return false; // areas cannot cross</span>
		}

		Envelope2D _env_a;
		Envelope2D _env_b;

<span class="fc bfc" id="L3110" title="All 4 branches covered.">		if (env_a.getHeight() &gt; tolerance &amp;&amp; env_a.getWidth() &gt; tolerance) {</span>
			// swap b and a
<span class="fc" id="L3112">			_env_a = env_b;</span>
<span class="fc" id="L3113">			_env_b = env_a;</span>
		} else {
<span class="fc" id="L3115">			_env_a = env_a;</span>
<span class="fc" id="L3116">			_env_b = env_b;</span>
		}

<span class="fc bfc" id="L3119" title="All 4 branches covered.">		if (_env_b.getHeight() &gt; tolerance &amp;&amp; _env_b.getWidth() &gt; tolerance) {// treat</span>
																				// env_b
																				// as
																				// an
																				// area
																				// (env_a
																				// as
																				// a
																				// line);

<span class="fc" id="L3129">			Envelope2D env_inter = new Envelope2D(), env_b_deflated = new Envelope2D();</span>
<span class="fc" id="L3130">			env_b_deflated.setCoords(_env_b);</span>
<span class="fc" id="L3131">			env_b_deflated.inflate(-tolerance, -tolerance);</span>
<span class="fc" id="L3132">			env_inter.setCoords(env_b_deflated);</span>
<span class="fc" id="L3133">			env_inter.intersect(_env_a);</span>

<span class="fc bfc" id="L3135" title="All 2 branches covered.">			if (env_inter.isEmpty())</span>
<span class="fc" id="L3136">				return false;</span>

<span class="pc bpc" id="L3138" title="1 of 2 branches missed.">			if (env_inter.getHeight() &lt;= tolerance</span>
<span class="pc bpc" id="L3139" title="1 of 2 branches missed.">					&amp;&amp; env_inter.getWidth() &lt;= tolerance)</span>
<span class="nc" id="L3140">				return false; // not a line</span>

<span class="pc bpc" id="L3142" title="1 of 2 branches missed.">			assert (!envelopeInfContainsEnvelope_(env_inter, _env_a, tolerance));</span>
<span class="fc" id="L3143">			return true;</span>
		}

		// treat both as lines

<span class="fc" id="L3148">		Line line_a = new Line(), line_b = new Line();</span>
<span class="fc" id="L3149">		double[] scalars_a = new double[2];</span>
<span class="fc" id="L3150">		double[] scalars_b = new double[2];</span>
<span class="fc" id="L3151">		Point2D pt = new Point2D();</span>
<span class="fc" id="L3152">		_env_a.queryLowerLeft(pt);</span>
<span class="fc" id="L3153">		line_a.setStartXY(pt);</span>
<span class="fc" id="L3154">		_env_a.queryUpperRight(pt);</span>
<span class="fc" id="L3155">		line_a.setEndXY(pt);</span>
<span class="fc" id="L3156">		_env_b.queryLowerLeft(pt);</span>
<span class="fc" id="L3157">		line_b.setStartXY(pt);</span>
<span class="fc" id="L3158">		_env_b.queryUpperRight(pt);</span>
<span class="fc" id="L3159">		line_b.setEndXY(pt);</span>

<span class="fc" id="L3161">		line_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);</span>
<span class="fc" id="L3162">		int count = line_a.intersect(line_b, null, null, null, tolerance);</span>

<span class="fc bfc" id="L3164" title="All 2 branches covered.">		if (count != 1)</span>
<span class="fc" id="L3165">			return false;</span>

<span class="pc bpc" id="L3167" title="2 of 8 branches missed.">		return scalars_a[0] &gt; 0.0 &amp;&amp; scalars_a[1] &lt; 1.0 &amp;&amp; scalars_b[0] &gt; 0.0</span>
				&amp;&amp; scalars_b[1] &lt; 1.0;
	}

	// Returns true if polygon_a is disjoint from multipath_b.
	private static boolean polygonDisjointMultiPath_(Polygon polygon_a,
			MultiPath multipath_b, double tolerance,
			ProgressTracker progress_tracker) {
        Point2D pt_a, pt_b;
<span class="fc" id="L3176">        Envelope2D env_a_inf = new Envelope2D(), env_b_inf = new Envelope2D();</span>

<span class="fc" id="L3178">        MultiPathImpl multi_path_impl_a = (MultiPathImpl)polygon_a._getImpl();</span>
<span class="fc" id="L3179">        MultiPathImpl multi_path_impl_b = (MultiPathImpl)multipath_b._getImpl();</span>

<span class="fc" id="L3181">        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, true);</span>

<span class="fc bfc" id="L3183" title="All 2 branches covered.">        if (!intersector.next())</span>
<span class="fc" id="L3184">            return true; // no rings intersect</span>

<span class="fc" id="L3186">        boolean b_intersects = linearPathIntersectsLinearPath_(polygon_a, multipath_b, tolerance);</span>

<span class="fc bfc" id="L3188" title="All 2 branches covered.">        if (b_intersects)</span>
<span class="fc" id="L3189">            return false;</span>

<span class="fc" id="L3191">        Polygon pa = null;</span>
<span class="fc" id="L3192">        Polygon p_polygon_a = polygon_a;</span>

<span class="fc" id="L3194">        Polygon pb = null;</span>
<span class="fc" id="L3195">        Polygon p_polygon_b = null;</span>

<span class="fc bfc" id="L3197" title="All 2 branches covered.">        if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)</span>
<span class="fc" id="L3198">            p_polygon_b = (Polygon)multipath_b;</span>

<span class="fc" id="L3200">        boolean b_checked_polygon_a_quad_tree = false;</span>
<span class="fc" id="L3201">        boolean b_checked_polygon_b_quad_tree = false;</span>

        do
        {
<span class="fc" id="L3205">            int path_a = intersector.getRedElement();</span>
<span class="fc" id="L3206">            int path_b = intersector.getBlueElement();</span>

<span class="fc" id="L3208">            pt_b = multipath_b.getXY(multipath_b.getPathStart(path_b));</span>
<span class="fc" id="L3209">            env_a_inf.setCoords(intersector.getRedEnvelope());</span>
<span class="fc" id="L3210">            env_a_inf.inflate(tolerance, tolerance);</span>

<span class="fc bfc" id="L3212" title="All 2 branches covered.">            if (env_a_inf.contains(pt_b))</span>
            {
<span class="fc" id="L3214">                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, pt_b, 0.0);</span>

<span class="fc bfc" id="L3216" title="All 2 branches covered.">                if (result != PolygonUtils.PiPResult.PiPOutside)</span>
<span class="fc" id="L3217">                    return false;</span>
            }

<span class="fc bfc" id="L3220" title="All 2 branches covered.">            if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)</span>
            {
<span class="fc" id="L3222">                pt_a = polygon_a.getXY(polygon_a.getPathStart(path_a));</span>
<span class="fc" id="L3223">                env_b_inf.setCoords(intersector.getBlueEnvelope());</span>
<span class="fc" id="L3224">                env_b_inf.inflate(tolerance, tolerance);</span>

<span class="fc bfc" id="L3226" title="All 2 branches covered.">                if (env_b_inf.contains(pt_a))</span>
                {
<span class="fc" id="L3228">                    PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_b, pt_a, 0.0);</span>

<span class="fc bfc" id="L3230" title="All 2 branches covered.">                    if (result != PolygonUtils.PiPResult.PiPOutside)</span>
<span class="fc" id="L3231">                        return false;</span>
                }
            }

<span class="fc bfc" id="L3235" title="All 2 branches covered.">            if (!b_checked_polygon_a_quad_tree) {</span>
<span class="pc bpc" id="L3236" title="5 of 6 branches missed.">                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipath_b.getPathCount() - 1) &amp;&amp; (multi_path_impl_a._getAccelerators() == null || multi_path_impl_a._getAccelerators().getQuadTree() == null)) {</span>
<span class="nc" id="L3237">                    pa = new Polygon();</span>
<span class="nc" id="L3238">                    polygon_a.copyTo(pa);</span>
<span class="nc" id="L3239">                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</span>
<span class="nc" id="L3240">                    p_polygon_a = pa;</span>
                } else {
<span class="fc" id="L3242">                    p_polygon_a = polygon_a;</span>
                }

<span class="fc" id="L3245">                b_checked_polygon_a_quad_tree = true;</span>
            }

<span class="fc bfc" id="L3248" title="All 2 branches covered.">            if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)</span>
            {
<span class="fc bfc" id="L3250" title="All 2 branches covered.">                if (!b_checked_polygon_b_quad_tree) {</span>
<span class="fc" id="L3251">                    Polygon polygon_b = (Polygon) multipath_b;</span>
<span class="pc bpc" id="L3252" title="5 of 6 branches missed.">                    if (PointInPolygonHelper.quadTreeWillHelp(polygon_b, polygon_a.getPathCount() - 1) &amp;&amp; (multi_path_impl_b._getAccelerators() == null || multi_path_impl_b._getAccelerators().getQuadTree() == null)) {</span>
<span class="nc" id="L3253">                        pb = new Polygon();</span>
<span class="nc" id="L3254">                        polygon_b.copyTo(pb);</span>
<span class="nc" id="L3255">                        ((MultiPathImpl) pb._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</span>
<span class="nc" id="L3256">                        p_polygon_b = pb;</span>
                    } else {
<span class="fc" id="L3258">                        p_polygon_b = (Polygon) multipath_b;</span>
                    }

<span class="fc" id="L3261">                    b_checked_polygon_b_quad_tree = true;</span>
                }
            }

<span class="fc bfc" id="L3265" title="All 2 branches covered.">        } while (intersector.next());</span>

<span class="fc" id="L3267">        return true;</span>
	}

	// Returns true if env_a inflated contains env_b.
	private static boolean envelopeInfContainsEnvelope_(Envelope2D env_a,
			Envelope2D env_b, double tolerance) {
<span class="fc" id="L3273">		Envelope2D env_a_inflated = new Envelope2D();</span>
<span class="fc" id="L3274">		env_a_inflated.setCoords(env_a);</span>
<span class="fc" id="L3275">		env_a_inflated.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3276">		return env_a_inflated.contains(env_b);</span>
	}

	// Returns true if a coordinate of envelope A is outside of envelope B.
	private static boolean interiorEnvExteriorEnv_(Envelope2D env_a,
			Envelope2D env_b, double tolerance) {
<span class="fc" id="L3282">		Envelope2D envBInflated = new Envelope2D();</span>
<span class="fc" id="L3283">		envBInflated.setCoords(env_b);</span>
<span class="fc" id="L3284">		envBInflated.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3285">		Point2D pt = new Point2D();</span>

<span class="fc" id="L3287">		env_a.queryLowerLeft(pt);</span>
<span class="fc bfc" id="L3288" title="All 2 branches covered.">		if (!envBInflated.contains(pt))</span>
<span class="fc" id="L3289">			return true;</span>

<span class="fc" id="L3291">		env_a.queryLowerRight(pt);</span>
<span class="fc bfc" id="L3292" title="All 2 branches covered.">		if (!envBInflated.contains(pt))</span>
<span class="fc" id="L3293">			return true;</span>

<span class="fc" id="L3295">		env_a.queryUpperLeft(pt);</span>
<span class="pc bpc" id="L3296" title="1 of 2 branches missed.">		if (!envBInflated.contains(pt))</span>
<span class="nc" id="L3297">			return true;</span>

<span class="fc" id="L3299">		env_a.queryUpperRight(pt);</span>
<span class="pc bpc" id="L3300" title="1 of 2 branches missed.">		if (!envBInflated.contains(pt))</span>
<span class="nc" id="L3301">			return true;</span>

<span class="pc bpc" id="L3303" title="1 of 2 branches missed.">		assert (envBInflated.contains(env_a));</span>
<span class="fc" id="L3304">		return false;</span>
	}

	// Returns true if the points in each path of multipathA are the same as
	// those in multipathB, within a tolerance, and in the same order.
	private static boolean multiPathExactlyEqualsMultiPath_(
			MultiPath multipathA, MultiPath multipathB, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L3312" title="All 2 branches covered.">		if (multipathA.getPathCount() != multipathB.getPathCount()</span>
<span class="fc bfc" id="L3313" title="All 2 branches covered.">				|| multipathA.getPointCount() != multipathB.getPointCount())</span>
<span class="fc" id="L3314">			return false;</span>

<span class="fc" id="L3316">		Point2D ptA = new Point2D(), ptB = new Point2D();</span>
<span class="fc" id="L3317">		boolean bAllPointsEqual = true;</span>
<span class="fc" id="L3318">		double tolerance_sq = tolerance * tolerance;</span>

<span class="fc bfc" id="L3320" title="All 2 branches covered.">		for (int ipath = 0; ipath &lt; multipathA.getPathCount(); ipath++) {</span>
<span class="pc bpc" id="L3321" title="1 of 2 branches missed.">			if (multipathA.getPathEnd(ipath) != multipathB.getPathEnd(ipath)) {</span>
<span class="nc" id="L3322">				bAllPointsEqual = false;</span>
<span class="nc" id="L3323">				break;</span>
			}

<span class="fc" id="L3326">			for (int i = multipathA.getPathStart(ipath); i &lt; multipathB</span>
<span class="fc bfc" id="L3327" title="All 2 branches covered.">					.getPathEnd(ipath); i++) {</span>
<span class="fc" id="L3328">				multipathA.getXY(i, ptA);</span>
<span class="fc" id="L3329">				multipathB.getXY(i, ptB);</span>

<span class="fc bfc" id="L3331" title="All 2 branches covered.">				if (Point2D.sqrDistance(ptA, ptB) &gt; tolerance_sq) {</span>
<span class="fc" id="L3332">					bAllPointsEqual = false;</span>
<span class="fc" id="L3333">					break;</span>
				}
			}

<span class="fc bfc" id="L3337" title="All 2 branches covered.">			if (!bAllPointsEqual)</span>
<span class="fc" id="L3338">				break;</span>
		}

<span class="fc bfc" id="L3341" title="All 2 branches covered.">		if (!bAllPointsEqual)</span>
<span class="fc" id="L3342">			return false;</span>

<span class="fc" id="L3344">		return true;</span>
	}

	// Returns true if the points of multipoint_a are the same as those in
	// multipoint_b, within a tolerance, and in the same order.
	private static boolean multiPointExactlyEqualsMultiPoint_(
			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc bfc" id="L3352" title="All 2 branches covered.">		if (multipoint_a.getPointCount() != multipoint_b.getPointCount())</span>
<span class="fc" id="L3353">			return false;</span>

<span class="fc" id="L3355">		Point2D ptA = new Point2D(), ptB = new Point2D();</span>
<span class="fc" id="L3356">		boolean bAllPointsEqual = true;</span>
<span class="fc" id="L3357">		double tolerance_sq = tolerance * tolerance;</span>

<span class="fc bfc" id="L3359" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L3360">			multipoint_a.getXY(i, ptA);</span>
<span class="fc" id="L3361">			multipoint_b.getXY(i, ptB);</span>

<span class="pc bpc" id="L3363" title="1 of 2 branches missed.">			if (Point2D.sqrDistance(ptA, ptB) &gt; tolerance_sq) {</span>
<span class="nc" id="L3364">				bAllPointsEqual = false;</span>
<span class="nc" id="L3365">				break;</span>
			}
		}

<span class="pc bpc" id="L3369" title="1 of 2 branches missed.">		if (!bAllPointsEqual)</span>
<span class="nc" id="L3370">			return false;</span>

<span class="fc" id="L3372">		return true;</span>
	}

	// By default this will perform the within operation if bEquals is false.
	// Otherwise it will do equals.
	private static boolean multiPointCoverageMultiPoint_(
			MultiPoint _multipointA, MultiPoint _multipointB, double tolerance,
			boolean bPerformWithin, boolean bPerformEquals,
			boolean bPerformOverlaps, ProgressTracker progress_tracker) {
<span class="fc" id="L3381">		boolean bPerformContains = false;</span>
		MultiPoint multipoint_a;
		MultiPoint multipoint_b;

<span class="fc bfc" id="L3385" title="All 2 branches covered.">		if (_multipointA.getPointCount() &gt; _multipointB.getPointCount()) {</span>
<span class="fc bfc" id="L3386" title="All 2 branches covered.">			if (bPerformWithin) {</span>
<span class="fc" id="L3387">				bPerformWithin = false;</span>
<span class="fc" id="L3388">				bPerformContains = true;</span>
			}

<span class="fc" id="L3391">			multipoint_a = _multipointB;</span>
<span class="fc" id="L3392">			multipoint_b = _multipointA;</span>
		} else {
<span class="fc" id="L3394">			multipoint_a = _multipointA;</span>
<span class="fc" id="L3395">			multipoint_b = _multipointB;</span>
		}

<span class="fc" id="L3398">		AttributeStreamOfInt8 contained = null;</span>

<span class="fc bfc" id="L3400" title="All 6 branches covered.">		if (bPerformEquals || bPerformOverlaps || bPerformContains) {</span>
<span class="fc" id="L3401">			contained = new AttributeStreamOfInt8(multipoint_b.getPointCount());</span>

<span class="fc bfc" id="L3403" title="All 2 branches covered.">			for (int i = 0; i &lt; multipoint_b.getPointCount(); i++)</span>
<span class="fc" id="L3404">				contained.write(i, (byte) 0);</span>
		}

<span class="fc" id="L3407">		Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L3408">		Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L3409">		Envelope2D envInter = new Envelope2D();</span>
<span class="fc" id="L3410">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L3411">		multipoint_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L3412">		env_a.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3413">		env_b.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3414">		envInter.setCoords(env_a);</span>
<span class="fc" id="L3415">		envInter.intersect(env_b);</span>

<span class="fc" id="L3417">		Point2D ptA = new Point2D();</span>
<span class="fc" id="L3418">		Point2D ptB = new Point2D();</span>

<span class="fc" id="L3420">		boolean bWithin = true; // starts off true by default</span>

<span class="fc" id="L3422">		QuadTreeImpl quadTreeB = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L3423">				(MultiPointImpl) (multipoint_b._getImpl()), envInter);</span>
<span class="fc" id="L3424">		QuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();</span>
<span class="fc" id="L3425">		double tolerance_sq = tolerance * tolerance;</span>

<span class="fc bfc" id="L3427" title="All 2 branches covered.">		for (int vertex_a = 0; vertex_a &lt; multipoint_a.getPointCount(); vertex_a++) {</span>
<span class="fc" id="L3428">			multipoint_a.getXY(vertex_a, ptA);</span>

<span class="fc bfc" id="L3430" title="All 2 branches covered.">			if (!envInter.contains(ptA)) {</span>
<span class="pc bpc" id="L3431" title="2 of 4 branches missed.">				if (bPerformEquals || bPerformWithin)</span>
<span class="nc" id="L3432">					return false;</span>
				else {
<span class="fc" id="L3434">					bWithin = false;</span>
<span class="fc" id="L3435">					continue;</span>
				}
			}

<span class="fc" id="L3439">			boolean bPtACovered = false;</span>
<span class="fc" id="L3440">			env_a.setCoords(ptA.x, ptA.y, ptA.x, ptA.y);</span>
<span class="fc" id="L3441">			qtIterB.resetIterator(env_a, tolerance);</span>
<span class="fc bfc" id="L3442" title="All 2 branches covered.">			for (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB</span>
<span class="fc" id="L3443">					.next()) {</span>
<span class="fc" id="L3444">				int vertex_b = quadTreeB.getElement(elementHandleB);</span>
<span class="fc" id="L3445">				multipoint_b.getXY(vertex_b, ptB);</span>

<span class="pc bpc" id="L3447" title="1 of 2 branches missed.">				if (Point2D.sqrDistance(ptA, ptB) &lt;= tolerance_sq) {</span>
<span class="fc bfc" id="L3448" title="All 6 branches covered.">					if (bPerformEquals || bPerformOverlaps || bPerformContains)</span>
<span class="fc" id="L3449">						contained.write(vertex_b, (byte) 1);</span>

<span class="fc" id="L3451">					bPtACovered = true;</span>

<span class="fc bfc" id="L3453" title="All 2 branches covered.">					if (bPerformWithin)</span>
<span class="fc" id="L3454">						break;</span>
				}
			}

<span class="fc bfc" id="L3458" title="All 2 branches covered.">			if (!bPtACovered) {</span>
<span class="fc" id="L3459">				bWithin = false;</span>

<span class="pc bpc" id="L3461" title="1 of 4 branches missed.">				if (bPerformEquals || bPerformWithin)</span>
<span class="fc" id="L3462">					return false;</span>
			}
		}

<span class="fc bfc" id="L3466" title="All 4 branches covered.">		if (bPerformOverlaps &amp;&amp; bWithin)</span>
<span class="fc" id="L3467">			return false;</span>

<span class="fc bfc" id="L3469" title="All 2 branches covered.">		if (bPerformWithin)</span>
<span class="fc" id="L3470">			return true;</span>

<span class="fc bfc" id="L3472" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc bfc" id="L3473" title="All 2 branches covered.">			if (contained.read(i) == 1) {</span>
<span class="fc bfc" id="L3474" title="All 2 branches covered.">				if (bPerformOverlaps)</span>
<span class="fc" id="L3475">					return true;</span>
			} else {
<span class="pc bpc" id="L3477" title="1 of 4 branches missed.">				if (bPerformEquals || bPerformContains)</span>
<span class="fc" id="L3478">					return false;</span>
			}
		}

<span class="fc bfc" id="L3482" title="All 2 branches covered.">		if (bPerformOverlaps)</span>
<span class="fc" id="L3483">			return false;</span>

<span class="fc" id="L3485">		return true;</span>
	}

	// Returns true if multipoint_a intersects multipoint_b.
	private static boolean multiPointIntersectsMultiPoint_(
			MultiPoint _multipointA, MultiPoint _multipointB, double tolerance,
			ProgressTracker progress_tracker) {
		MultiPoint multipoint_a;
		MultiPoint multipoint_b;

<span class="fc bfc" id="L3495" title="All 2 branches covered.">		if (_multipointA.getPointCount() &gt; _multipointB.getPointCount()) {</span>
<span class="fc" id="L3496">			multipoint_a = _multipointB;</span>
<span class="fc" id="L3497">			multipoint_b = _multipointA;</span>
		} else {
<span class="fc" id="L3499">			multipoint_a = _multipointA;</span>
<span class="fc" id="L3500">			multipoint_b = _multipointB;</span>
		}

<span class="fc" id="L3503">		Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L3504">		Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L3505">		Envelope2D envInter = new Envelope2D();</span>
<span class="fc" id="L3506">		multipoint_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L3507">		multipoint_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L3508">		env_a.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3509">		env_b.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3510">		envInter.setCoords(env_a);</span>
<span class="fc" id="L3511">		envInter.intersect(env_b);</span>

<span class="fc" id="L3513">		Point2D ptA = new Point2D();</span>
<span class="fc" id="L3514">		Point2D ptB = new Point2D();</span>
<span class="fc" id="L3515">		double tolerance_sq = tolerance * tolerance;</span>

<span class="fc" id="L3517">		QuadTreeImpl quadTreeB = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L3518">				(MultiPointImpl) (multipoint_b._getImpl()), envInter);</span>
<span class="fc" id="L3519">		QuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();</span>

<span class="fc bfc" id="L3521" title="All 2 branches covered.">		for (int vertex_a = 0; vertex_a &lt; multipoint_a.getPointCount(); vertex_a++) {</span>
<span class="fc" id="L3522">			multipoint_a.getXY(vertex_a, ptA);</span>

<span class="fc bfc" id="L3524" title="All 2 branches covered.">			if (!envInter.contains(ptA))</span>
<span class="fc" id="L3525">				continue;</span>

<span class="fc" id="L3527">			env_a.setCoords(ptA.x, ptA.y, ptA.x, ptA.y);</span>
<span class="fc" id="L3528">			qtIterB.resetIterator(env_a, tolerance);</span>

<span class="pc bfc" id="L3530" title="All 2 branches covered.">			for (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB</span>
<span class="nc" id="L3531">					.next()) {</span>
<span class="fc" id="L3532">				int vertex_b = quadTreeB.getElement(elementHandleB);</span>
<span class="fc" id="L3533">				multipoint_b.getXY(vertex_b, ptB);</span>

<span class="pc bpc" id="L3535" title="1 of 2 branches missed.">				if (Point2D.sqrDistance(ptA, ptB) &lt;= tolerance_sq)</span>
<span class="fc" id="L3536">					return true;</span>
			}
		}

<span class="fc" id="L3540">		return false;</span>
	}

	// Returns true if multipathA equals multipathB.
	private static boolean linearPathEqualsLinearPath_(MultiPath multipathA,
			MultiPath multipathB, double tolerance, boolean bEnforceOrientation) {
<span class="fc bfc" id="L3546" title="All 2 branches covered.">		return linearPathWithinLinearPath_(multipathA, multipathB, tolerance, bEnforceOrientation)</span>
<span class="pc bpc" id="L3547" title="1 of 2 branches missed.">				&amp;&amp; linearPathWithinLinearPath_(multipathB, multipathA,</span>
						tolerance, bEnforceOrientation);
	}

	// Returns true if the segments of multipathA are within the segments of
	// multipathB.
	private static boolean linearPathWithinLinearPath_(MultiPath multipathA,
			MultiPath multipathB, double tolerance, boolean bEnforceOrientation) {
<span class="fc" id="L3555">		boolean bWithin = true;</span>
<span class="fc" id="L3556">		double[] scalarsA = new double[2];</span>
<span class="fc" id="L3557">		double[] scalarsB = new double[2];</span>

<span class="fc" id="L3559">		int ievent = 0;</span>
<span class="fc" id="L3560">		AttributeStreamOfInt32 eventIndices = new AttributeStreamOfInt32(0);</span>
<span class="fc" id="L3561">		RelationalOperations relOps = new RelationalOperations();</span>
<span class="fc" id="L3562">		OverlapComparer overlapComparer = new OverlapComparer(relOps);</span>
		OverlapEvent overlapEvent;

<span class="fc" id="L3565">		Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L3566">		Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L3567">		Envelope2D envInter = new Envelope2D();</span>
<span class="fc" id="L3568">		multipathA.queryEnvelope2D(env_a);</span>
<span class="fc" id="L3569">		multipathB.queryEnvelope2D(env_b);</span>
<span class="fc" id="L3570">		env_a.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3571">		env_b.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3572">		envInter.setCoords(env_a);</span>
<span class="fc" id="L3573">		envInter.intersect(env_b);</span>

<span class="fc" id="L3575">		SegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())</span>
<span class="fc" id="L3576">				.querySegmentIterator();</span>
<span class="fc" id="L3577">		SegmentIteratorImpl segIterB = ((MultiPathImpl) multipathB._getImpl())</span>
<span class="fc" id="L3578">				.querySegmentIterator();</span>

<span class="fc" id="L3580">		QuadTreeImpl qtB = null;</span>
<span class="fc" id="L3581">		QuadTreeImpl quadTreeB = null;</span>
<span class="fc" id="L3582">        QuadTreeImpl quadTreePathsB = null;</span>

<span class="fc" id="L3584">		GeometryAccelerators accel = ((MultiPathImpl) multipathB._getImpl())</span>
<span class="fc" id="L3585">				._getAccelerators();</span>

<span class="fc bfc" id="L3587" title="All 2 branches covered.">		if (accel != null) {</span>
<span class="fc" id="L3588">			quadTreeB = accel.getQuadTree();</span>
<span class="fc" id="L3589">            quadTreePathsB = accel.getQuadTreeForPaths();</span>
<span class="pc bpc" id="L3590" title="1 of 2 branches missed.">			if (quadTreeB == null) {</span>
<span class="fc" id="L3591">				qtB = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L3592">						(MultiPathImpl) multipathB._getImpl(), envInter);</span>
<span class="fc" id="L3593">				quadTreeB = qtB;</span>
			}
		} else {
<span class="fc" id="L3596">			qtB = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L3597">					(MultiPathImpl) multipathB._getImpl(), envInter);</span>
<span class="fc" id="L3598">			quadTreeB = qtB;</span>
		}

<span class="fc" id="L3601">		QuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();</span>

<span class="fc" id="L3603">        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsB = null;</span>
<span class="pc bpc" id="L3604" title="1 of 2 branches missed.">        if (quadTreePathsB != null)</span>
<span class="nc" id="L3605">            qtIterPathsB = quadTreePathsB.getIterator();</span>

<span class="fc bfc" id="L3607" title="All 2 branches covered.">		while (segIterA.nextPath()) {</span>
<span class="fc bfc" id="L3608" title="All 2 branches covered.">			while (segIterA.hasNextSegment()) {</span>
<span class="fc" id="L3609">				boolean bStringOfSegmentAsCovered = false;</span>

<span class="fc" id="L3611">				Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L3612">				segmentA.queryEnvelope2D(env_a);</span>

<span class="pc bpc" id="L3614" title="1 of 2 branches missed.">				if (!env_a.isIntersecting(envInter)) {</span>
<span class="nc" id="L3615">					return false; // bWithin = false</span>
				}

<span class="pc bpc" id="L3618" title="1 of 2 branches missed.">                if (qtIterPathsB != null) {</span>
<span class="nc" id="L3619">                    qtIterPathsB.resetIterator(env_a, tolerance);</span>

<span class="nc bnc" id="L3621" title="All 2 branches missed.">                    if (qtIterPathsB.next() == -1) {</span>
<span class="nc" id="L3622">                        bWithin = false;</span>
<span class="nc" id="L3623">                        return false;</span>
                    }
                }

<span class="fc" id="L3627">				double lengthA = segmentA.calculateLength2D();</span>

<span class="fc" id="L3629">				qtIterB.resetIterator(segmentA, tolerance);</span>

<span class="fc bfc" id="L3631" title="All 2 branches covered.">				for (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB</span>
<span class="fc" id="L3632">						.next()) {</span>
<span class="fc" id="L3633">					int vertex_b = quadTreeB.getElement(elementHandleB);</span>
<span class="fc" id="L3634">					segIterB.resetToVertex(vertex_b);</span>
<span class="fc" id="L3635">					Segment segmentB = segIterB.nextSegment();</span>

<span class="fc" id="L3637">					int result = segmentA.intersect(segmentB, null, scalarsA,</span>
							scalarsB, tolerance);

<span class="fc bfc" id="L3640" title="All 6 branches covered.">					if (result == 2 &amp;&amp; (!bEnforceOrientation || scalarsB[0] &lt;= scalarsB[1])) {</span>
<span class="fc" id="L3641">						double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L3642">						double scalar_a_1 = scalarsA[1];</span>
<span class="fc" id="L3643">						double scalar_b_0 = scalarsB[0];</span>
<span class="fc" id="L3644">						double scalar_b_1 = scalarsB[1];</span>

						// Performance enhancement for nice cases where
						// localization occurs. Increment segIterA as far as we
						// can while the current segmentA is covered.
<span class="fc bfc" id="L3649" title="All 4 branches covered.">						if (scalar_a_0 * lengthA &lt;= tolerance</span>
								&amp;&amp; (1.0 - scalar_a_1) * lengthA &lt;= tolerance) {
<span class="fc" id="L3651">							bStringOfSegmentAsCovered = true;</span>

<span class="fc" id="L3653">							ievent = 0;</span>
<span class="fc" id="L3654">							eventIndices.resize(0);</span>
<span class="fc" id="L3655">							relOps.m_overlap_events.clear();</span>

<span class="fc" id="L3657">							int ivertex_a = segIterA.getStartPointIndex();</span>
<span class="fc" id="L3658">							boolean bSegmentACovered = true;</span>

<span class="fc bfc" id="L3660" title="All 2 branches covered.">							while (bSegmentACovered) {// keep going while the</span>
								// current segmentA is
								// covered.
<span class="fc bfc" id="L3663" title="All 2 branches covered.">								if (segIterA.hasNextSegment()) {</span>
<span class="fc" id="L3664">									segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L3665">									lengthA = segmentA.calculateLength2D();</span>

<span class="fc" id="L3667">									result = segmentA.intersect(segmentB, null,</span>
											scalarsA, scalarsB, tolerance);

<span class="pc bpc" id="L3670" title="1 of 6 branches missed.">									if (result == 2 &amp;&amp; (!bEnforceOrientation || scalarsB[0] &lt;= scalarsB[1])) {</span>
<span class="fc" id="L3671">										scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L3672">										scalar_a_1 = scalarsA[1];</span>

<span class="pc bpc" id="L3674" title="1 of 4 branches missed.">										if (scalar_a_0 * lengthA &lt;= tolerance</span>
												&amp;&amp; (1.0 - scalar_a_1) * lengthA &lt;= tolerance) {
<span class="fc" id="L3676">											ivertex_a = segIterA</span>
<span class="fc" id="L3677">													.getStartPointIndex();</span>
<span class="fc" id="L3678">											continue;</span>
										}
									}

<span class="fc bfc" id="L3682" title="All 2 branches covered.">									if (segIterB.hasNextSegment()) {</span>
<span class="fc" id="L3683">										segmentB = segIterB.nextSegment();</span>
<span class="fc" id="L3684">										result = segmentA.intersect(segmentB,</span>
												null, scalarsA, scalarsB,
												tolerance);

<span class="pc bpc" id="L3688" title="1 of 6 branches missed.">										if (result == 2 &amp;&amp; (!bEnforceOrientation || scalarsB[0] &lt;= scalarsB[1])) {</span>
<span class="fc" id="L3689">											scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L3690">											scalar_a_1 = scalarsA[1];</span>

<span class="fc bfc" id="L3692" title="All 4 branches covered.">											if (scalar_a_0 * lengthA &lt;= tolerance</span>
													&amp;&amp; (1.0 - scalar_a_1)
															* lengthA &lt;= tolerance) {
<span class="fc" id="L3695">												ivertex_a = segIterA</span>
<span class="fc" id="L3696">														.getStartPointIndex();</span>
<span class="fc" id="L3697">												continue;</span>
											}
										}
									}
								}

<span class="fc" id="L3703">								bSegmentACovered = false;</span>
							}

<span class="fc bfc" id="L3706" title="All 2 branches covered.">							if (ivertex_a != segIterA.getStartPointIndex()) {</span>
<span class="fc" id="L3707">								segIterA.resetToVertex(ivertex_a);</span>
<span class="fc" id="L3708">								segIterA.nextSegment();</span>
							}

							break;
						} else {
<span class="fc" id="L3713">							int ivertex_a = segIterA.getStartPointIndex();</span>
<span class="fc" id="L3714">							int ipath_a = segIterA.getPathIndex();</span>
<span class="fc" id="L3715">							int ivertex_b = segIterB.getStartPointIndex();</span>
<span class="fc" id="L3716">							int ipath_b = segIterB.getPathIndex();</span>

<span class="fc" id="L3718">							overlapEvent = OverlapEvent.construct(ivertex_a,</span>
									ipath_a, scalar_a_0, scalar_a_1, ivertex_b,
									ipath_b, scalar_b_0, scalar_b_1);
<span class="fc" id="L3721">							relOps.m_overlap_events.add(overlapEvent);</span>
<span class="fc" id="L3722">							eventIndices.add(eventIndices.size());</span>
						}
					}
				}

<span class="fc bfc" id="L3727" title="All 2 branches covered.">				if (bStringOfSegmentAsCovered) {</span>
<span class="fc" id="L3728">					continue; // no need to check that segmentA is covered</span>
				}
<span class="fc bfc" id="L3730" title="All 2 branches covered.">				if (ievent == relOps.m_overlap_events.size()) {</span>
<span class="fc" id="L3731">					return false; // bWithin = false</span>
				}

<span class="pc bpc" id="L3734" title="1 of 2 branches missed.">				if (eventIndices.size() - ievent &gt; 1) {</span>
<span class="fc" id="L3735">					eventIndices.Sort(ievent, eventIndices.size(),</span>
							overlapComparer);
				}

<span class="fc" id="L3739">				double lastScalar = 0.0;</span>

<span class="pc bpc" id="L3741" title="1 of 2 branches missed.">				for (int i = ievent; i &lt; relOps.m_overlap_events.size(); i++) {</span>
<span class="fc" id="L3742">					overlapEvent = relOps.m_overlap_events.get(eventIndices</span>
<span class="fc" id="L3743">							.get(i));</span>

<span class="pc bpc" id="L3745" title="3 of 4 branches missed.">					if (overlapEvent.m_scalar_a_0 &lt; lastScalar</span>
							&amp;&amp; overlapEvent.m_scalar_a_1 &lt; lastScalar) {
<span class="nc" id="L3747">						continue;</span>
					}

<span class="pc bpc" id="L3750" title="1 of 2 branches missed.">					if (lengthA * (overlapEvent.m_scalar_a_0 - lastScalar) &gt; tolerance) {</span>
<span class="nc" id="L3751">						return false; // bWithin = false</span>
					} else {
<span class="fc" id="L3753">						lastScalar = overlapEvent.m_scalar_a_1;</span>

<span class="pc bpc" id="L3755" title="1 of 4 branches missed.">						if (lengthA * (1.0 - lastScalar) &lt;= tolerance</span>
								|| lastScalar == 1.0) {
<span class="nc" id="L3757">							break;</span>
						}
					}
				}

<span class="pc bpc" id="L3762" title="1 of 2 branches missed.">				if (lengthA * (1.0 - lastScalar) &gt; tolerance) {</span>
<span class="nc" id="L3763">					return false; // bWithin = false</span>
				}

<span class="fc" id="L3766">				ievent = 0;</span>
<span class="fc" id="L3767">				eventIndices.resize(0);</span>
<span class="fc" id="L3768">				relOps.m_overlap_events.clear();</span>
<span class="fc" id="L3769">			}</span>
		}

<span class="fc" id="L3772">		return bWithin;</span>
	}

	// Returns true if the segments of multipathA overlap the segments of
	// multipathB.
	private static boolean linearPathOverlapsLinearPath_(MultiPath multipathA,
			MultiPath multipathB, double tolerance) {
<span class="fc" id="L3779">		int dim = linearPathIntersectsLinearPathMaxDim_(multipathA, multipathB,</span>
				tolerance, null);

<span class="fc bfc" id="L3782" title="All 2 branches covered.">		if (dim &lt; 1)</span>
<span class="fc" id="L3783">			return false;</span>

<span class="fc" id="L3785">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</span>
<span class="fc" id="L3786">		multipathA.queryEnvelope2D(env_a);</span>
<span class="fc" id="L3787">		multipathB.queryEnvelope2D(env_b);</span>

<span class="fc" id="L3789">		boolean bIntAExtB = interiorEnvExteriorEnv_(env_a, env_b, tolerance);</span>
<span class="fc" id="L3790">		boolean bIntBExtA = interiorEnvExteriorEnv_(env_b, env_a, tolerance);</span>

<span class="fc bfc" id="L3792" title="All 4 branches covered.">		if (bIntAExtB &amp;&amp; bIntBExtA)</span>
<span class="fc" id="L3793">			return true;</span>

<span class="pc bpc" id="L3795" title="1 of 4 branches missed.">		if (bIntAExtB &amp;&amp; !bIntBExtA)</span>
<span class="pc bpc" id="L3796" title="1 of 2 branches missed.">			return !linearPathWithinLinearPath_(multipathB, multipathA,</span>
					tolerance, false);

<span class="pc bpc" id="L3799" title="1 of 4 branches missed.">		if (bIntBExtA &amp;&amp; !bIntAExtB)</span>
<span class="pc bpc" id="L3800" title="1 of 2 branches missed.">			return !linearPathWithinLinearPath_(multipathA, multipathB,</span>
					tolerance, false);

<span class="pc bpc" id="L3803" title="1 of 2 branches missed.">		return !linearPathWithinLinearPath_(multipathA, multipathB, tolerance, false)</span>
<span class="pc bnc" id="L3804" title="All 2 branches missed.">				&amp;&amp; !linearPathWithinLinearPath_(multipathB, multipathA,</span>
						tolerance, false);
	}

	// Returns true the dimension of intersection of _multipathA and
	// _multipathB.
	static int linearPathIntersectsLinearPathMaxDim_(MultiPath _multipathA,
			MultiPath _multipathB, double tolerance,
			AttributeStreamOfDbl intersections) {
		MultiPath multipathA;
		MultiPath multipathB;

<span class="fc bfc" id="L3816" title="All 2 branches covered.">		if (_multipathA.getSegmentCount() &gt; _multipathB.getSegmentCount()) {</span>
<span class="fc" id="L3817">			multipathA = _multipathB;</span>
<span class="fc" id="L3818">			multipathB = _multipathA;</span>
		} else {
<span class="fc" id="L3820">			multipathA = _multipathA;</span>
<span class="fc" id="L3821">			multipathB = _multipathB;</span>
		}

<span class="fc" id="L3824">		SegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())</span>
<span class="fc" id="L3825">				.querySegmentIterator();</span>
<span class="fc" id="L3826">		SegmentIteratorImpl segIterB = ((MultiPathImpl) multipathB._getImpl())</span>
<span class="fc" id="L3827">				.querySegmentIterator();</span>
<span class="fc" id="L3828">		double[] scalarsA = new double[2];</span>
<span class="fc" id="L3829">		double[] scalarsB = new double[2];</span>

<span class="fc" id="L3831">		int dim = -1;</span>

<span class="fc" id="L3833">		int ievent = 0;</span>
		double overlapLength;
<span class="fc" id="L3835">		AttributeStreamOfInt32 eventIndices = new AttributeStreamOfInt32(0);</span>
<span class="fc" id="L3836">		RelationalOperations relOps = new RelationalOperations();</span>
<span class="fc" id="L3837">		OverlapComparer overlapComparer = new OverlapComparer(relOps);</span>
		OverlapEvent overlapEvent;

<span class="fc" id="L3840">		Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L3841">		Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L3842">		Envelope2D envInter = new Envelope2D();</span>
<span class="fc" id="L3843">		multipathA.queryEnvelope2D(env_a);</span>
<span class="fc" id="L3844">		multipathB.queryEnvelope2D(env_b);</span>
<span class="fc" id="L3845">		env_a.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3846">		env_b.inflate(tolerance, tolerance);</span>
<span class="fc" id="L3847">		envInter.setCoords(env_a);</span>
<span class="fc" id="L3848">		envInter.intersect(env_b);</span>

<span class="fc" id="L3850">		Point2D int_point = null;</span>

<span class="fc bfc" id="L3852" title="All 2 branches covered.">		if (intersections != null) {</span>
<span class="fc" id="L3853">			int_point = new Point2D();</span>
		}

<span class="fc" id="L3856">		QuadTreeImpl qtB = null;</span>
<span class="fc" id="L3857">		QuadTreeImpl quadTreeB = null;</span>
<span class="fc" id="L3858">        QuadTreeImpl quadTreePathsB = null;</span>

<span class="fc" id="L3860">		GeometryAccelerators accel = ((MultiPathImpl) multipathB._getImpl())</span>
<span class="fc" id="L3861">				._getAccelerators();</span>

<span class="pc bpc" id="L3863" title="1 of 2 branches missed.">		if (accel != null) {</span>
<span class="nc" id="L3864">			quadTreeB = accel.getQuadTree();</span>
<span class="nc" id="L3865">            quadTreePathsB = accel.getQuadTreeForPaths();</span>
<span class="nc bnc" id="L3866" title="All 2 branches missed.">			if (quadTreeB == null) {</span>
<span class="nc" id="L3867">				qtB = InternalUtils.buildQuadTree(</span>
<span class="nc" id="L3868">						(MultiPathImpl) multipathB._getImpl(), envInter);</span>
<span class="nc" id="L3869">				quadTreeB = qtB;</span>
			}
		} else {
<span class="fc" id="L3872">			qtB = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L3873">					(MultiPathImpl) multipathB._getImpl(), envInter);</span>
<span class="fc" id="L3874">			quadTreeB = qtB;</span>
		}

<span class="fc" id="L3877">		QuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();</span>

<span class="fc" id="L3879">        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsB = null;</span>
<span class="pc bpc" id="L3880" title="1 of 2 branches missed.">        if (quadTreePathsB != null)</span>
<span class="nc" id="L3881">            qtIterPathsB = quadTreePathsB.getIterator();</span>

<span class="fc bfc" id="L3883" title="All 2 branches covered.">		while (segIterA.nextPath()) {</span>
<span class="fc" id="L3884">			overlapLength = 0.0;</span>

<span class="fc bfc" id="L3886" title="All 2 branches covered.">			while (segIterA.hasNextSegment()) {</span>
<span class="fc" id="L3887">				Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L3888">				segmentA.queryEnvelope2D(env_a);</span>

<span class="fc bfc" id="L3890" title="All 2 branches covered.">				if (!env_a.isIntersecting(envInter)) {</span>
<span class="fc" id="L3891">					continue;</span>
				}

<span class="pc bpc" id="L3894" title="1 of 2 branches missed.">                if (qtIterPathsB != null) {</span>
<span class="nc" id="L3895">                    qtIterPathsB.resetIterator(env_a, tolerance);</span>

<span class="nc bnc" id="L3897" title="All 2 branches missed.">                    if (qtIterPathsB.next() == -1)</span>
<span class="nc" id="L3898">                        continue;</span>
                }

<span class="fc" id="L3901">				double lengthA = segmentA.calculateLength2D();</span>

<span class="fc" id="L3903">				qtIterB.resetIterator(segmentA, tolerance);</span>

<span class="fc bfc" id="L3905" title="All 2 branches covered.">				for (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB</span>
<span class="fc" id="L3906">						.next()) {</span>
<span class="fc" id="L3907">					int vertex_b = quadTreeB.getElement(elementHandleB);</span>
<span class="fc" id="L3908">					segIterB.resetToVertex(vertex_b);</span>

<span class="fc" id="L3910">					Segment segmentB = segIterB.nextSegment();</span>
<span class="fc" id="L3911">					double lengthB = segmentB.calculateLength2D();</span>

<span class="fc" id="L3913">					int result = segmentA.intersect(segmentB, null, scalarsA,</span>
							scalarsB, tolerance);

<span class="fc bfc" id="L3916" title="All 2 branches covered.">					if (result &gt; 0) {</span>
<span class="fc" id="L3917">						double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L3918">						double scalar_b_0 = scalarsB[0];</span>
<span class="fc bfc" id="L3919" title="All 2 branches covered.">						double scalar_a_1 = (result == 2 ? scalarsA[1]</span>
<span class="fc" id="L3920">								: NumberUtils.TheNaN);</span>
<span class="fc bfc" id="L3921" title="All 2 branches covered.">						double scalar_b_1 = (result == 2 ? scalarsB[1]</span>
<span class="fc" id="L3922">								: NumberUtils.TheNaN);</span>

<span class="fc bfc" id="L3924" title="All 2 branches covered.">						if (result == 2) {</span>
<span class="pc bpc" id="L3925" title="1 of 2 branches missed.">							if (lengthA * (scalar_a_1 - scalar_a_0) &gt; tolerance) {</span>
<span class="fc" id="L3926">								dim = 1;</span>
<span class="fc" id="L3927">								return dim;</span>
							}

							// Quick neighbor check
<span class="nc" id="L3931">							double length = lengthA * (scalar_a_1 - scalar_a_0);</span>

<span class="nc bnc" id="L3933" title="All 2 branches missed.">							if (segIterB.hasNextSegment()) {</span>
<span class="nc" id="L3934">								segmentB = segIterB.nextSegment();</span>
<span class="nc" id="L3935">								result = segmentA.intersect(segmentB, null,</span>
										scalarsA, null, tolerance);

<span class="nc bnc" id="L3938" title="All 2 branches missed.">								if (result == 2) {</span>
<span class="nc" id="L3939">									double nextScalarA0 = scalarsA[0];</span>
<span class="nc" id="L3940">									double nextScalarA1 = scalarsA[1];</span>

<span class="nc" id="L3942">									double lengthNext = lengthA</span>
											* (nextScalarA1 - nextScalarA0);

<span class="nc bnc" id="L3945" title="All 2 branches missed.">									if (length + lengthNext &gt; tolerance) {</span>
<span class="nc" id="L3946">										dim = 1;</span>
<span class="nc" id="L3947">										return dim;</span>
									}
								}

<span class="nc" id="L3951">								segIterB.resetToVertex(vertex_b);</span>
<span class="nc" id="L3952">								segIterB.nextSegment();</span>
							}

<span class="nc bnc" id="L3955" title="All 2 branches missed.">							if (!segIterB.isFirstSegmentInPath()) {</span>
<span class="nc" id="L3956">								segIterB.previousSegment();</span>
<span class="nc" id="L3957">								segmentB = segIterB.previousSegment();</span>
<span class="nc" id="L3958">								result = segmentA.intersect(segmentB, null,</span>
										scalarsA, null, tolerance);

<span class="nc bnc" id="L3961" title="All 2 branches missed.">								if (result == 2) {</span>
<span class="nc" id="L3962">									double nextScalarA0 = scalarsA[0];</span>
<span class="nc" id="L3963">									double nextScalarA1 = scalarsA[1];</span>

<span class="nc" id="L3965">									double lengthPrevious = lengthA</span>
											* (nextScalarA1 - nextScalarA0);

<span class="nc bnc" id="L3968" title="All 2 branches missed.">									if (length + lengthPrevious &gt; tolerance) {</span>
<span class="nc" id="L3969">										dim = 1;</span>
<span class="nc" id="L3970">										return dim;</span>
									}
								}

<span class="nc" id="L3974">								segIterB.resetToVertex(vertex_b);</span>
<span class="nc" id="L3975">								segIterB.nextSegment();</span>
							}

<span class="nc bnc" id="L3978" title="All 2 branches missed.">							if (segIterA.hasNextSegment()) {</span>
<span class="nc" id="L3979">								int vertex_a = segIterA.getStartPointIndex();</span>
<span class="nc" id="L3980">								segmentA = segIterA.nextSegment();</span>
<span class="nc" id="L3981">								result = segmentA.intersect(segmentB, null,</span>
										scalarsA, null, tolerance);

<span class="nc bnc" id="L3984" title="All 2 branches missed.">								if (result == 2) {</span>
<span class="nc" id="L3985">									double nextScalarA0 = scalarsA[0];</span>
<span class="nc" id="L3986">									double nextScalarA1 = scalarsA[1];</span>

<span class="nc" id="L3988">									double lengthNext = lengthA</span>
											* (nextScalarA1 - nextScalarA0);

<span class="nc bnc" id="L3991" title="All 2 branches missed.">									if (length + lengthNext &gt; tolerance) {</span>
<span class="nc" id="L3992">										dim = 1;</span>
<span class="nc" id="L3993">										return dim;</span>
									}
								}

<span class="nc" id="L3997">								segIterA.resetToVertex(vertex_a);</span>
<span class="nc" id="L3998">								segIterA.nextSegment();</span>
							}

<span class="nc bnc" id="L4001" title="All 2 branches missed.">							if (!segIterA.isFirstSegmentInPath()) {</span>
<span class="nc" id="L4002">								int vertex_a = segIterA.getStartPointIndex();</span>
<span class="nc" id="L4003">								segIterA.previousSegment();</span>
<span class="nc" id="L4004">								segmentA = segIterA.previousSegment();</span>
<span class="nc" id="L4005">								result = segmentA.intersect(segmentB, null,</span>
										scalarsA, null, tolerance);

<span class="nc bnc" id="L4008" title="All 2 branches missed.">								if (result == 2) {</span>
<span class="nc" id="L4009">									double nextScalarA0 = scalarsA[0];</span>
<span class="nc" id="L4010">									double nextScalarA1 = scalarsA[1];</span>

<span class="nc" id="L4012">									double lengthPrevious = lengthB</span>
											* (nextScalarA1 - nextScalarA0);

<span class="nc bnc" id="L4015" title="All 2 branches missed.">									if (length + lengthPrevious &gt; tolerance) {</span>
<span class="nc" id="L4016">										dim = 1;</span>
<span class="nc" id="L4017">										return dim;</span>
									}
								}

<span class="nc" id="L4021">								segIterA.resetToVertex(vertex_a);</span>
<span class="nc" id="L4022">								segIterA.nextSegment();</span>
							}

<span class="nc" id="L4025">							int ivertex_a = segIterA.getStartPointIndex();</span>
<span class="nc" id="L4026">							int ipath_a = segIterA.getPathIndex();</span>
<span class="nc" id="L4027">							int ivertex_b = segIterB.getStartPointIndex();</span>
<span class="nc" id="L4028">							int ipath_b = segIterB.getPathIndex();</span>

<span class="nc" id="L4030">							overlapEvent = OverlapEvent.construct(ivertex_a,</span>
									ipath_a, scalar_a_0, scalar_a_1, ivertex_b,
									ipath_b, scalar_b_0, scalar_b_1);
<span class="nc" id="L4033">							relOps.m_overlap_events.add(overlapEvent);</span>
<span class="nc" id="L4034">							eventIndices.add(eventIndices.size());</span>
						}

<span class="fc" id="L4037">						dim = 0;</span>

<span class="fc bfc" id="L4039" title="All 2 branches covered.">						if (intersections != null) {</span>
<span class="fc" id="L4040">							segmentA.getCoord2D(scalar_a_0, int_point);</span>
<span class="fc" id="L4041">							intersections.add(int_point.x);</span>
<span class="fc" id="L4042">							intersections.add(int_point.y);</span>
						}
					}
				}

<span class="pc bpc" id="L4047" title="1 of 2 branches missed.">				if (ievent &lt; relOps.m_overlap_events.size()) {</span>
<span class="nc" id="L4048">					eventIndices.Sort(ievent, eventIndices.size(),</span>
							overlapComparer);

<span class="nc" id="L4051">					double lastScalar = 0.0;</span>
<span class="nc" id="L4052">					int lastPath = relOps.m_overlap_events.get(eventIndices</span>
<span class="nc" id="L4053">							.get(ievent)).m_ipath_a;</span>

<span class="nc bnc" id="L4055" title="All 2 branches missed.">					for (int i = ievent; i &lt; relOps.m_overlap_events.size(); i++) {</span>
<span class="nc" id="L4056">						overlapEvent = relOps.m_overlap_events.get(eventIndices</span>
<span class="nc" id="L4057">								.get(i));</span>

<span class="nc bnc" id="L4059" title="All 4 branches missed.">						if (overlapEvent.m_scalar_a_0 &lt; lastScalar</span>
								&amp;&amp; overlapEvent.m_scalar_a_1 &lt; lastScalar) {
<span class="nc" id="L4061">							continue;</span>
						}

<span class="nc bnc" id="L4064" title="All 2 branches missed.">						if (lengthA * (overlapEvent.m_scalar_a_0 - lastScalar) &gt; tolerance) {</span>
<span class="nc" id="L4065">							overlapLength = lengthA</span>
									* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // reset
<span class="nc" id="L4067">							lastScalar = overlapEvent.m_scalar_a_1;</span>
<span class="nc" id="L4068">							lastPath = overlapEvent.m_ipath_a;</span>
						} else {
<span class="nc bnc" id="L4070" title="All 2 branches missed.">							if (overlapEvent.m_ipath_a != lastPath) {</span>
<span class="nc" id="L4071">								overlapLength = lengthA</span>
										* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // reset
<span class="nc" id="L4073">								lastPath = overlapEvent.m_ipath_a;</span>
							} else {
<span class="nc" id="L4075">								overlapLength += lengthA</span>
										* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // accumulate
							}
<span class="nc bnc" id="L4078" title="All 2 branches missed.">							if (overlapLength &gt; tolerance) {</span>
<span class="nc" id="L4079">								dim = 1;</span>
<span class="nc" id="L4080">								return dim;</span>
							}

<span class="nc" id="L4083">							lastScalar = overlapEvent.m_scalar_a_1;</span>

<span class="nc bnc" id="L4085" title="All 2 branches missed.">							if (lastScalar == 1.0) {</span>
<span class="nc" id="L4086">								break;</span>
							}
						}
					}

<span class="nc bnc" id="L4091" title="All 2 branches missed.">					if (lengthA * (1.0 - lastScalar) &gt; tolerance) {</span>
<span class="nc" id="L4092">						overlapLength = 0.0; // reset</span>
					}
<span class="nc" id="L4094">					ievent = 0;</span>
<span class="nc" id="L4095">					eventIndices.resize(0);</span>
<span class="nc" id="L4096">					relOps.m_overlap_events.clear();</span>
				}
<span class="fc" id="L4098">			}</span>
		}

<span class="fc" id="L4101">		return dim;</span>
	}

	// Returns true if the line segments of _multipathA intersect the line
	// segments of _multipathB.
	private static boolean linearPathIntersectsLinearPath_(
			MultiPath multipathA, MultiPath multipathB, double tolerance) {
<span class="fc" id="L4108">		MultiPathImpl multi_path_impl_a = (MultiPathImpl) multipathA._getImpl();</span>
<span class="fc" id="L4109">		MultiPathImpl multi_path_impl_b = (MultiPathImpl) multipathB._getImpl();</span>

<span class="fc" id="L4111">		SegmentIteratorImpl segIterA = multi_path_impl_a.querySegmentIterator();</span>
<span class="fc" id="L4112">		SegmentIteratorImpl segIterB = multi_path_impl_b.querySegmentIterator();</span>

<span class="fc" id="L4114">        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, false);</span>

<span class="fc bfc" id="L4116" title="All 2 branches covered.">		while (intersector.next()) {</span>
<span class="fc" id="L4117">			int vertex_a = intersector.getRedElement();</span>
<span class="fc" id="L4118">			int vertex_b = intersector.getBlueElement();</span>

<span class="fc" id="L4120">			segIterA.resetToVertex(vertex_a);</span>
<span class="fc" id="L4121">			segIterB.resetToVertex(vertex_b);</span>
<span class="fc" id="L4122">			Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L4123">			Segment segmentB = segIterB.nextSegment();</span>

<span class="fc" id="L4125">			int result = segmentB.intersect(segmentA, null, null, null,</span>
					tolerance);

<span class="fc bfc" id="L4128" title="All 2 branches covered.">			if (result &gt; 0) {</span>
<span class="fc" id="L4129">				return true;</span>
			}
<span class="fc" id="L4131">		}</span>

<span class="fc" id="L4133">		return false;</span>
	}

	// Returns true if the relation intersects, crosses, or contains holds
	// between multipathA and multipoint_b. multipathA is put in the
	// Quad_tree_impl.
	private static boolean linearPathIntersectsMultiPoint_(
			MultiPath multipathA, MultiPoint multipoint_b, double tolerance,
			boolean b_intersects_all) {
<span class="fc" id="L4142">		SegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())</span>
<span class="fc" id="L4143">				.querySegmentIterator();</span>

<span class="fc" id="L4145">		Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L4146">		Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L4147">		Envelope2D envInter = new Envelope2D();</span>
<span class="fc" id="L4148">		multipathA.queryEnvelope2D(env_a);</span>
<span class="fc" id="L4149">		multipoint_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L4150">		env_a.inflate(tolerance, tolerance);</span>

<span class="fc" id="L4152">		env_b.inflate(tolerance, tolerance);</span>
<span class="fc" id="L4153">		envInter.setCoords(env_a);</span>
<span class="fc" id="L4154">		envInter.intersect(env_b);</span>

<span class="fc" id="L4156">		QuadTreeImpl qtA = null;</span>
<span class="fc" id="L4157">		QuadTreeImpl quadTreeA = null;</span>
<span class="fc" id="L4158">        QuadTreeImpl quadTreePathsA = null;</span>

<span class="fc" id="L4160">		GeometryAccelerators accel = ((MultiPathImpl) multipathA._getImpl())</span>
<span class="fc" id="L4161">				._getAccelerators();</span>

<span class="fc bfc" id="L4163" title="All 2 branches covered.">		if (accel != null) {</span>
<span class="fc" id="L4164">			quadTreeA = accel.getQuadTree();</span>
<span class="fc" id="L4165">			quadTreePathsA = accel.getQuadTreeForPaths();</span>
<span class="pc bpc" id="L4166" title="1 of 2 branches missed.">			if (quadTreeA == null) {</span>
<span class="fc" id="L4167">				qtA = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L4168">						(MultiPathImpl) multipathA._getImpl(), envInter);</span>
<span class="fc" id="L4169">				quadTreeA = qtA;</span>
			}
		} else {
<span class="fc" id="L4172">			qtA = InternalUtils.buildQuadTree(</span>
<span class="fc" id="L4173">					(MultiPathImpl) multipathA._getImpl(), envInter);</span>
<span class="fc" id="L4174">			quadTreeA = qtA;</span>
		}

<span class="fc" id="L4177">		QuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();</span>

<span class="fc" id="L4179">        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;</span>
<span class="pc bpc" id="L4180" title="1 of 2 branches missed.">        if (quadTreePathsA != null)</span>
<span class="nc" id="L4181">            qtIterPathsA = quadTreePathsA.getIterator();</span>

<span class="fc" id="L4183">		Point2D ptB = new Point2D(), closest = new Point2D();</span>
<span class="fc" id="L4184">		double toleranceSq = tolerance * tolerance;</span>

<span class="fc bfc" id="L4186" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</span>
<span class="fc" id="L4187">			multipoint_b.getXY(i, ptB);</span>

<span class="pc bpc" id="L4189" title="1 of 2 branches missed.">			if (!envInter.contains(ptB)) {</span>
<span class="nc" id="L4190">				continue;</span>
			}

<span class="fc" id="L4193">			env_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);</span>

<span class="pc bpc" id="L4195" title="1 of 2 branches missed.">            if (qtIterPathsA != null) {</span>
<span class="nc" id="L4196">                qtIterPathsA.resetIterator(env_b, tolerance);</span>

<span class="nc bnc" id="L4198" title="All 2 branches missed.">                if (qtIterPathsA.next() == -1)</span>
<span class="nc" id="L4199">                    continue;</span>
            }

<span class="fc" id="L4202">			qtIterA.resetIterator(env_b, tolerance);</span>

<span class="fc" id="L4204">			boolean b_covered = false;</span>

<span class="fc bfc" id="L4206" title="All 2 branches covered.">			for (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA</span>
<span class="fc" id="L4207">					.next()) {</span>
<span class="fc" id="L4208">				int vertex_a = quadTreeA.getElement(elementHandleA);</span>
<span class="fc" id="L4209">				segIterA.resetToVertex(vertex_a);</span>
<span class="fc" id="L4210">				Segment segmentA = segIterA.nextSegment();</span>

<span class="fc" id="L4212">				double t = segmentA.getClosestCoordinate(ptB, false);</span>
<span class="fc" id="L4213">				segmentA.getCoord2D(t, closest);</span>

<span class="fc bfc" id="L4215" title="All 2 branches covered.">				if (Point2D.sqrDistance(closest, ptB) &lt;= toleranceSq) {</span>
<span class="fc" id="L4216">					b_covered = true;</span>
<span class="fc" id="L4217">					break;</span>
				}
			}

<span class="fc bfc" id="L4221" title="All 2 branches covered.">			if (b_intersects_all) {</span>
<span class="fc bfc" id="L4222" title="All 2 branches covered.">				if (!b_covered) {</span>
<span class="fc" id="L4223">					return false;</span>
				}
			} else {
<span class="fc bfc" id="L4226" title="All 2 branches covered.">				if (b_covered) {</span>
<span class="fc" id="L4227">					return true;</span>
				}
			}
		}

<span class="fc bfc" id="L4232" title="All 2 branches covered.">		if (b_intersects_all) {</span>
<span class="fc" id="L4233">			return true;</span>
		}

<span class="fc" id="L4236">		return false;</span>
	}

	// Returns true if a segment of multipathA intersects point_b.
	static boolean linearPathIntersectsPoint_(MultiPath multipathA,
			Point2D ptB, double tolerance) {
<span class="fc" id="L4242">		Point2D closest = new Point2D();</span>
<span class="fc" id="L4243">		double toleranceSq = tolerance * tolerance;</span>
<span class="fc" id="L4244">		SegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())</span>
<span class="fc" id="L4245">				.querySegmentIterator();</span>

<span class="fc" id="L4247">		GeometryAccelerators accel = ((MultiPathImpl) multipathA._getImpl())</span>
<span class="fc" id="L4248">				._getAccelerators();</span>

<span class="fc bfc" id="L4250" title="All 2 branches covered.">		if (accel != null) {</span>
<span class="fc" id="L4251">			QuadTreeImpl quadTreeA = accel.getQuadTree();</span>
<span class="pc bpc" id="L4252" title="1 of 2 branches missed.">			if (quadTreeA != null) {</span>
<span class="fc" id="L4253">				Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L4254">				env_b.setCoords(ptB);</span>

<span class="fc" id="L4256">				QuadTreeImpl.QuadTreeIteratorImpl qt_iter = quadTreeA</span>
<span class="fc" id="L4257">						.getIterator(env_b, tolerance);</span>

<span class="pc bpc" id="L4259" title="1 of 2 branches missed.">				for (int e = qt_iter.next(); e != -1; e = qt_iter.next()) {</span>
<span class="fc" id="L4260">					segIterA.resetToVertex(quadTreeA.getElement(e));</span>

<span class="pc bpc" id="L4262" title="1 of 2 branches missed.">					if (segIterA.hasNextSegment()) {</span>
<span class="fc" id="L4263">						Segment segmentA = segIterA.nextSegment();</span>

<span class="fc" id="L4265">						double t = segmentA.getClosestCoordinate(ptB, false);</span>
<span class="fc" id="L4266">						segmentA.getCoord2D(t, closest);</span>

<span class="pc bpc" id="L4268" title="1 of 2 branches missed.">						if (Point2D.sqrDistance(ptB, closest) &lt;= toleranceSq) {</span>
<span class="fc" id="L4269">							return true;</span>
						}
					}
				}

<span class="nc" id="L4274">				return false;</span>
			}
		}
<span class="fc" id="L4277">		Envelope2D env_a = new Envelope2D();</span>

<span class="fc bfc" id="L4279" title="All 2 branches covered.">		while (segIterA.nextPath()) {</span>
<span class="fc bfc" id="L4280" title="All 2 branches covered.">			while (segIterA.hasNextSegment()) {</span>
<span class="fc" id="L4281">				Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L4282">				segmentA.queryEnvelope2D(env_a);</span>
<span class="fc" id="L4283">				env_a.inflate(tolerance, tolerance);</span>

<span class="fc bfc" id="L4285" title="All 2 branches covered.">				if (!env_a.contains(ptB)) {</span>
<span class="fc" id="L4286">					continue;</span>
				}

<span class="fc" id="L4289">				double t = segmentA.getClosestCoordinate(ptB, false);</span>
<span class="fc" id="L4290">				segmentA.getCoord2D(t, closest);</span>

<span class="pc bpc" id="L4292" title="1 of 2 branches missed.">				if (Point2D.sqrDistance(ptB, closest) &lt;= toleranceSq) {</span>
<span class="fc" id="L4293">					return true;</span>
				}
<span class="nc" id="L4295">			}</span>
		}

<span class="fc" id="L4298">		return false;</span>
	}

	private static boolean linearPathContainsPoint_(MultiPath multipathA,
			Point2D pt_b, double tolerance) {
<span class="fc bfc" id="L4303" title="All 2 branches covered.">		return linearPathIntersectsPoint_(multipathA, pt_b, tolerance)</span>
<span class="fc bfc" id="L4304" title="All 2 branches covered.">				&amp;&amp; !linearPathTouchesPointImpl_(multipathA, pt_b, tolerance);</span>
	}

	private static boolean linearPathTouchesPointImpl_(MultiPath multipathA,
			Point2D ptB, double tolerance) {
<span class="fc" id="L4309">		MultiPoint boundary = (MultiPoint) (multipathA.getBoundary());</span>
<span class="fc bfc" id="L4310" title="All 2 branches covered.">		return !multiPointDisjointPointImpl_(boundary, ptB, tolerance, null);</span>
	}

	// Returns true if the segments of multipathA intersects env_b
	private static boolean linearPathIntersectsEnvelope_(MultiPath multipath_a,
			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<span class="pc bpc" id="L4316" title="1 of 2 branches missed.">		if (!multipath_a.hasNonLinearSegments()) {</span>
<span class="fc" id="L4317">			Envelope2D env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L4318">			env_b_inflated.setCoords(env_b);</span>
<span class="fc" id="L4319">			env_b_inflated.inflate(tolerance, tolerance);</span>
<span class="fc" id="L4320">			MultiPathImpl mimpl_a = (MultiPathImpl) multipath_a._getImpl();</span>
<span class="fc" id="L4321">			AttributeStreamOfDbl xy = (AttributeStreamOfDbl) (mimpl_a</span>
<span class="fc" id="L4322">					.getAttributeStreamRef(VertexDescription.Semantics.POSITION));</span>
<span class="fc" id="L4323">			Point2D pt = new Point2D();</span>
<span class="fc" id="L4324">			Point2D pt_prev = new Point2D();</span>
<span class="fc" id="L4325">			Point2D pt_1 = new Point2D();</span>
<span class="fc" id="L4326">			Point2D pt_2 = new Point2D();</span>
<span class="fc bfc" id="L4327" title="All 2 branches covered.">			for (int ipath = 0, npath = mimpl_a.getPathCount(); ipath &lt; npath; ipath++) {</span>
<span class="fc" id="L4328">				boolean b_first = true;</span>
<span class="fc" id="L4329">				for (int i = mimpl_a.getPathStart(ipath), n = mimpl_a</span>
<span class="fc bfc" id="L4330" title="All 2 branches covered.">						.getPathEnd(ipath); i &lt; n; i++) {</span>
<span class="fc bfc" id="L4331" title="All 2 branches covered.">					if (b_first) {</span>
<span class="fc" id="L4332">						xy.read(2 * i, pt_prev);</span>
<span class="fc" id="L4333">						b_first = false;</span>
<span class="fc" id="L4334">						continue;</span>
					}

<span class="fc" id="L4337">					xy.read(2 * i, pt);</span>
<span class="fc" id="L4338">					pt_1.setCoords(pt_prev);</span>
<span class="fc" id="L4339">					pt_2.setCoords(pt);</span>
<span class="fc bfc" id="L4340" title="All 2 branches covered.">					if (env_b_inflated.clipLine(pt_1, pt_2) != 0)</span>
<span class="fc" id="L4341">						return true;</span>

<span class="fc" id="L4343">					pt_prev.setCoords(pt);</span>
				}
			}
<span class="fc" id="L4346">		} else {</span>
<span class="nc" id="L4347">			Line line_1 = new Line(env_b.xmin, env_b.ymin, env_b.xmin,</span>
					env_b.ymax);
<span class="nc" id="L4349">			Line line_2 = new Line(env_b.xmin, env_b.ymax, env_b.xmax,</span>
					env_b.ymax);
<span class="nc" id="L4351">			Line line3 = new Line(env_b.xmax, env_b.ymax, env_b.xmax,</span>
					env_b.ymin);
<span class="nc" id="L4353">			Line line4 = new Line(env_b.xmax, env_b.ymin, env_b.xmin,</span>
					env_b.ymin);
<span class="nc" id="L4355">			SegmentIterator iter = multipath_a.querySegmentIterator();</span>
<span class="nc bnc" id="L4356" title="All 2 branches missed.">			while (iter.nextPath()) {</span>
<span class="nc bnc" id="L4357" title="All 2 branches missed.">				while (iter.hasNextSegment()) {</span>
<span class="nc" id="L4358">					Segment polySeg = iter.nextSegment();</span>
<span class="nc bnc" id="L4359" title="All 2 branches missed.">					if (polySeg.isIntersecting(line_1, tolerance))</span>
<span class="nc" id="L4360">						return true;</span>

<span class="nc bnc" id="L4362" title="All 2 branches missed.">					if (polySeg.isIntersecting(line_2, tolerance))</span>
<span class="nc" id="L4363">						return true;</span>

<span class="nc bnc" id="L4365" title="All 2 branches missed.">					if (polySeg.isIntersecting(line3, tolerance))</span>
<span class="nc" id="L4366">						return true;</span>

<span class="nc bnc" id="L4368" title="All 2 branches missed.">					if (polySeg.isIntersecting(line4, tolerance))</span>
<span class="nc" id="L4369">						return true;</span>
<span class="nc" id="L4370">				}</span>
			}
		}

<span class="fc" id="L4374">		return false;</span>
	}

	// Returns contains, disjoint, or within if the relationship can be
	// determined from the rasterized tests.
	// When bExtraTestForIntersects is true performs extra tests and can return
	// &quot;intersects&quot;.
	static int tryRasterizedContainsOrDisjoint_(Geometry geom_a,
			Geometry geom_b, double tolerance, boolean bExtraTestForIntersects) {
<span class="fc" id="L4383">		int gtA = geom_a.getType().value();</span>
<span class="fc" id="L4384">		int gtB = geom_b.getType().value();</span>
		do {
<span class="pc bpc" id="L4386" title="1 of 2 branches missed.">			if (Geometry.isMultiVertex(gtA)) {</span>
<span class="fc" id="L4387">				MultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geom_a</span>
<span class="fc" id="L4388">						._getImpl();</span>
<span class="fc" id="L4389">				GeometryAccelerators accel = impl._getAccelerators();</span>
<span class="fc bfc" id="L4390" title="All 2 branches covered.">				if (accel != null) {</span>
<span class="fc" id="L4391">					RasterizedGeometry2D rgeom = accel.getRasterizedGeometry();</span>
<span class="pc bpc" id="L4392" title="1 of 2 branches missed.">					if (rgeom != null) {</span>
<span class="fc bfc" id="L4393" title="All 2 branches covered.">						if (gtB == Geometry.GeometryType.Point) {</span>
<span class="fc" id="L4394">							Point2D ptB = ((Point) geom_b).getXY();</span>
<span class="fc" id="L4395">							RasterizedGeometry2D.HitType hit = rgeom</span>
<span class="fc" id="L4396">									.queryPointInGeometry(ptB.x, ptB.y);</span>
<span class="pc bpc" id="L4397" title="1 of 2 branches missed.">							if (hit == RasterizedGeometry2D.HitType.Inside) {</span>
<span class="nc" id="L4398">								return Relation.contains;</span>
<span class="pc bpc" id="L4399" title="1 of 2 branches missed.">							} else if (hit == RasterizedGeometry2D.HitType.Outside) {</span>
<span class="nc" id="L4400">								return Relation.disjoint;</span>
							}
							break;
						}
<span class="fc" id="L4404">						Envelope2D env_b = new Envelope2D();</span>
<span class="fc" id="L4405">						geom_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L4406">						RasterizedGeometry2D.HitType hit = rgeom</span>
<span class="fc" id="L4407">								.queryEnvelopeInGeometry(env_b);</span>
<span class="fc bfc" id="L4408" title="All 2 branches covered.">						if (hit == RasterizedGeometry2D.HitType.Inside) {</span>
<span class="fc" id="L4409">							return Relation.contains;</span>
<span class="fc bfc" id="L4410" title="All 2 branches covered.">						} else if (hit == RasterizedGeometry2D.HitType.Outside) {</span>
<span class="fc" id="L4411">							return Relation.disjoint;</span>
<span class="fc bfc" id="L4412" title="All 2 branches covered.">						} else if (bExtraTestForIntersects</span>
<span class="pc bpc" id="L4413" title="1 of 2 branches missed.">								&amp;&amp; Geometry.isMultiVertex(gtB)) {</span>
<span class="fc bfc" id="L4414" title="All 2 branches covered.">							if (checkVerticesForIntersection_(</span>
<span class="fc" id="L4415">									(MultiVertexGeometryImpl) geom_b._getImpl(),</span>
									rgeom)) {
<span class="fc" id="L4417">								return Relation.intersects;</span>
							}
						}

						break;
					}
				}
			}
		} while (false);

		do {
<span class="fc bfc" id="L4428" title="All 2 branches covered.">			if (Geometry.isMultiVertex(gtB)) {</span>
<span class="fc" id="L4429">				MultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geom_b</span>
<span class="fc" id="L4430">						._getImpl();</span>
<span class="fc" id="L4431">				GeometryAccelerators accel = impl._getAccelerators();</span>
<span class="fc bfc" id="L4432" title="All 2 branches covered.">				if (accel != null) {</span>
<span class="fc" id="L4433">					RasterizedGeometry2D rgeom = accel.getRasterizedGeometry();</span>
<span class="pc bpc" id="L4434" title="1 of 2 branches missed.">					if (rgeom != null) {</span>
<span class="pc bpc" id="L4435" title="1 of 2 branches missed.">						if (gtA == Geometry.GeometryType.Point) {</span>
<span class="nc" id="L4436">							Point2D ptA = ((Point) geom_a).getXY();</span>
<span class="nc" id="L4437">							RasterizedGeometry2D.HitType hit = rgeom</span>
<span class="nc" id="L4438">									.queryPointInGeometry(ptA.x, ptA.y);</span>
<span class="nc bnc" id="L4439" title="All 2 branches missed.">							if (hit == RasterizedGeometry2D.HitType.Inside) {</span>
<span class="nc" id="L4440">								return Relation.within;</span>
<span class="nc bnc" id="L4441" title="All 2 branches missed.">							} else if (hit == RasterizedGeometry2D.HitType.Outside) {</span>
<span class="nc" id="L4442">								return Relation.disjoint;</span>
							}
							break;
						}

<span class="fc" id="L4447">						Envelope2D env_a = new Envelope2D();</span>
<span class="fc" id="L4448">						geom_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L4449">						RasterizedGeometry2D.HitType hit = rgeom</span>
<span class="fc" id="L4450">								.queryEnvelopeInGeometry(env_a);</span>
<span class="pc bpc" id="L4451" title="1 of 2 branches missed.">						if (hit == RasterizedGeometry2D.HitType.Inside) {</span>
<span class="nc" id="L4452">							return Relation.within;</span>
<span class="fc bfc" id="L4453" title="All 2 branches covered.">						} else if (hit == RasterizedGeometry2D.HitType.Outside) {</span>
<span class="fc" id="L4454">							return Relation.disjoint;</span>
<span class="fc bfc" id="L4455" title="All 2 branches covered.">						} else if (bExtraTestForIntersects</span>
<span class="pc bpc" id="L4456" title="1 of 2 branches missed.">								&amp;&amp; Geometry.isMultiVertex(gtA)) {</span>
<span class="fc bfc" id="L4457" title="All 2 branches covered.">							if (checkVerticesForIntersection_(</span>
<span class="fc" id="L4458">									(MultiVertexGeometryImpl) geom_a._getImpl(),</span>
									rgeom)) {
<span class="fc" id="L4460">								return Relation.intersects;</span>
							}
						}

						break;
					}
				}
			}
		} while (false);

<span class="fc" id="L4470">		return Relation.unknown;</span>
	}

	// Returns true if intersects and false if nothing can be determined.
	private static boolean checkVerticesForIntersection_(
			MultiVertexGeometryImpl geom, RasterizedGeometry2D rgeom) {
		// Do a quick raster test for each point. If any point is inside, then
		// there is an intersection.
<span class="fc" id="L4478">		int pointCount = geom.getPointCount();</span>
<span class="fc" id="L4479">		Point2D pt = new Point2D();</span>
<span class="fc bfc" id="L4480" title="All 2 branches covered.">		for (int ipoint = 0; ipoint &lt; pointCount; ipoint++) {</span>
<span class="fc" id="L4481">			geom.getXY(ipoint, pt);</span>
<span class="fc" id="L4482">			RasterizedGeometry2D.HitType hit = rgeom.queryPointInGeometry(pt.x,</span>
					pt.y);
<span class="fc bfc" id="L4484" title="All 2 branches covered.">			if (hit == RasterizedGeometry2D.HitType.Inside) {</span>
<span class="fc" id="L4485">				return true;</span>
			}
		}

<span class="fc" id="L4489">		return false;</span>
	}

	private static boolean polygonTouchesPolygonImpl_(Polygon polygon_a,
			Polygon polygon_b, double tolerance, ProgressTracker progressTracker) {
<span class="fc" id="L4494">		MultiPathImpl polygon_impl_a = (MultiPathImpl) polygon_a._getImpl();</span>
<span class="fc" id="L4495">		MultiPathImpl polygon_impl_b = (MultiPathImpl) polygon_b._getImpl();</span>

		// double geom_tolerance;
<span class="pc bpc" id="L4498" title="1 of 2 branches missed.">		boolean b_geometries_simple = polygon_impl_a.getIsSimple(0.0) &gt;= 1</span>
<span class="pc bnc" id="L4499" title="All 2 branches missed.">				&amp;&amp; polygon_impl_b.getIsSimple(0.0) &gt;= 1;</span>

<span class="fc" id="L4501">		SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</span>
<span class="fc" id="L4502">		SegmentIteratorImpl segIterB = polygon_impl_b.querySegmentIterator();</span>
<span class="fc" id="L4503">		double[] scalarsA = new double[2];</span>
<span class="fc" id="L4504">		double[] scalarsB = new double[2];</span>

<span class="fc" id="L4506">		PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(</span>
				polygon_impl_a, polygon_impl_b, tolerance, false);

<span class="fc" id="L4509">		boolean b_boundaries_intersect = false;</span>

<span class="fc bfc" id="L4511" title="All 2 branches covered.">		while (intersector.next()) {</span>
<span class="fc" id="L4512">			int vertex_a = intersector.getRedElement();</span>
<span class="fc" id="L4513">			int vertex_b = intersector.getBlueElement();</span>

<span class="fc" id="L4515">			segIterA.resetToVertex(vertex_a);</span>
<span class="fc" id="L4516">			segIterB.resetToVertex(vertex_b);</span>
<span class="fc" id="L4517">			Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L4518">			Segment segmentB = segIterB.nextSegment();</span>

<span class="fc" id="L4520">			int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA,</span>
					tolerance);

<span class="fc bfc" id="L4523" title="All 2 branches covered.">			if (result == 2) {</span>
<span class="fc" id="L4524">				double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L4525">				double scalar_a_1 = scalarsA[1];</span>
<span class="fc" id="L4526">				double length_a = segmentA.calculateLength2D();</span>

<span class="pc bpc" id="L4528" title="3 of 4 branches missed.">				if (b_geometries_simple</span>
						&amp;&amp; (scalar_a_1 - scalar_a_0) * length_a &gt; tolerance) {
					// If the line segments overlap along the same direction,
					// then we have an Interior-Interior intersection
<span class="nc" id="L4532">					return false;</span>
				}

<span class="fc" id="L4535">				b_boundaries_intersect = true;</span>
<span class="fc bfc" id="L4536" title="All 2 branches covered.">			} else if (result != 0) {</span>
<span class="fc" id="L4537">				double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L4538">				double scalar_b_0 = scalarsB[0];</span>

<span class="fc bfc" id="L4540" title="All 8 branches covered.">				if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0</span>
						&amp;&amp; scalar_b_0 &lt; 1.0) {
<span class="fc" id="L4542">					return false;</span>
				}

<span class="fc" id="L4545">				b_boundaries_intersect = true;</span>
			}
<span class="fc" id="L4547">		}</span>

<span class="pc bpc" id="L4549" title="1 of 2 branches missed.">		if (!b_boundaries_intersect) {</span>
<span class="nc" id="L4550">			return false;</span>
		}

<span class="fc" id="L4553">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), envInter = new Envelope2D();</span>
<span class="fc" id="L4554">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L4555">		polygon_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L4556">		env_a.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>
<span class="fc" id="L4557">		env_b.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>
<span class="fc" id="L4558">		envInter.setCoords(env_a);</span>
<span class="fc" id="L4559">		envInter.intersect(env_b);</span>

		Polygon _polygonA;
		Polygon _polygonB;

<span class="fc bfc" id="L4564" title="All 2 branches covered.">		if (polygon_a.getPointCount() &gt; 10) {</span>
<span class="fc" id="L4565">			_polygonA = (Polygon) (Clipper.clip(polygon_a, envInter, tolerance,</span>
					0.0));
<span class="pc bpc" id="L4567" title="1 of 2 branches missed.">			if (_polygonA.isEmpty()) {</span>
<span class="nc" id="L4568">				return false;</span>
			}
		} else {
<span class="fc" id="L4571">			_polygonA = polygon_a;</span>
		}

<span class="pc bpc" id="L4574" title="1 of 2 branches missed.">		if (polygon_b.getPointCount() &gt; 10) {</span>
<span class="nc" id="L4575">			_polygonB = (Polygon) (Clipper.clip(polygon_b, envInter, tolerance,</span>
					0.0));
<span class="nc bnc" id="L4577" title="All 2 branches missed.">			if (_polygonB.isEmpty()) {</span>
<span class="nc" id="L4578">				return false;</span>
			}
		} else {
<span class="fc" id="L4581">			_polygonB = polygon_b;</span>
		}

		// We just need to determine whether interior_interior is false
<span class="fc" id="L4585">		String scl = &quot;F********&quot;;</span>
<span class="fc" id="L4586">		boolean bRelation = RelationalOperationsMatrix.polygonRelatePolygon_(</span>
				_polygonA, _polygonB, tolerance, scl, progressTracker);

<span class="fc" id="L4589">		return bRelation;</span>
	}

	private static boolean polygonOverlapsPolygonImpl_(Polygon polygon_a,
			Polygon polygon_b, double tolerance, ProgressTracker progressTracker) {
<span class="fc" id="L4594">		MultiPathImpl polygon_impl_a = (MultiPathImpl) polygon_a._getImpl();</span>
<span class="fc" id="L4595">		MultiPathImpl polygon_impl_b = (MultiPathImpl) polygon_b._getImpl();</span>

		// double geom_tolerance;
<span class="pc bpc" id="L4598" title="1 of 2 branches missed.">		boolean b_geometries_simple = polygon_impl_a.getIsSimple(0.0) &gt;= 1</span>
<span class="pc bnc" id="L4599" title="All 2 branches missed.">				&amp;&amp; polygon_impl_b.getIsSimple(0.0) &gt;= 1;</span>

<span class="fc" id="L4601">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), envInter = new Envelope2D();</span>
<span class="fc" id="L4602">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L4603">		polygon_b.queryEnvelope2D(env_b);</span>

<span class="fc" id="L4605">		boolean bInteriorIntersectionKnown = false;</span>

<span class="fc" id="L4607">		boolean bIntAExtB = interiorEnvExteriorEnv_(env_a, env_b, tolerance);</span>
<span class="fc" id="L4608">		boolean bExtAIntB = interiorEnvExteriorEnv_(env_b, env_a, tolerance);</span>

<span class="fc" id="L4610">		SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</span>
<span class="fc" id="L4611">		SegmentIteratorImpl segIterB = polygon_impl_b.querySegmentIterator();</span>
<span class="fc" id="L4612">		double[] scalarsA = new double[2];</span>
<span class="fc" id="L4613">		double[] scalarsB = new double[2];</span>

<span class="fc" id="L4615">		PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(</span>
				polygon_impl_a, polygon_impl_b, tolerance, false);

<span class="fc bfc" id="L4618" title="All 2 branches covered.">		while (intersector.next()) {</span>
<span class="fc" id="L4619">			int vertex_a = intersector.getRedElement();</span>
<span class="fc" id="L4620">			int vertex_b = intersector.getBlueElement();</span>

<span class="fc" id="L4622">			segIterA.resetToVertex(vertex_a);</span>
<span class="fc" id="L4623">			segIterB.resetToVertex(vertex_b);</span>
<span class="fc" id="L4624">			Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L4625">			Segment segmentB = segIterB.nextSegment();</span>

<span class="fc" id="L4627">			int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA,</span>
					tolerance);

<span class="fc bfc" id="L4630" title="All 2 branches covered.">			if (result == 2) {</span>
<span class="fc" id="L4631">				double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L4632">				double scalar_a_1 = scalarsA[1];</span>
<span class="fc" id="L4633">				double length_a = segmentA.calculateLength2D();</span>

<span class="pc bpc" id="L4635" title="3 of 4 branches missed.">				if (b_geometries_simple</span>
						&amp;&amp; (scalar_a_1 - scalar_a_0) * length_a &gt; tolerance) {
					// When the line segments intersect along the same
					// direction, then we have an interior-interior intersection
<span class="nc" id="L4639">					bInteriorIntersectionKnown = true;</span>

<span class="nc bnc" id="L4641" title="All 4 branches missed.">					if (bIntAExtB &amp;&amp; bExtAIntB) {</span>
<span class="nc" id="L4642">						return true;</span>
					}
				}
<span class="fc bfc" id="L4645" title="All 2 branches covered.">			} else if (result != 0) {</span>
<span class="fc" id="L4646">				double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L4647">				double scalar_b_0 = scalarsB[0];</span>

<span class="fc bfc" id="L4649" title="All 8 branches covered.">				if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0</span>
						&amp;&amp; scalar_b_0 &lt; 1.0) {
<span class="fc" id="L4651">					return true;</span>
				}
			}
<span class="fc" id="L4654">		}</span>

<span class="fc" id="L4656">		Envelope2D envAInflated = new Envelope2D(), envBInflated = new Envelope2D();</span>
<span class="fc" id="L4657">		envAInflated.setCoords(env_a);</span>
<span class="fc" id="L4658">		envAInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>
<span class="fc" id="L4659">		envBInflated.setCoords(env_b);</span>
<span class="fc" id="L4660">		envBInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>

<span class="fc" id="L4662">		envInter.setCoords(envAInflated);</span>
<span class="fc" id="L4663">		envInter.intersect(envBInflated);</span>

		Polygon _polygonA;
		Polygon _polygonB;
<span class="fc" id="L4667">		StringBuilder scl = new StringBuilder();</span>

<span class="pc bpc" id="L4669" title="1 of 2 branches missed.">		if (!bInteriorIntersectionKnown) {</span>
<span class="fc" id="L4670">			scl.append(&quot;T*&quot;);</span>
		} else {
<span class="nc" id="L4672">			scl.append(&quot;**&quot;);</span>
		}

<span class="fc bfc" id="L4675" title="All 2 branches covered.">		if (bIntAExtB) {</span>
<span class="pc bpc" id="L4676" title="1 of 2 branches missed.">			if (polygon_b.getPointCount() &gt; 10) {</span>
<span class="nc" id="L4677">				_polygonB = (Polygon) (Clipper.clip(polygon_b, envInter,</span>
						tolerance, 0.0));
<span class="nc bnc" id="L4679" title="All 2 branches missed.">				if (_polygonB.isEmpty()) {</span>
<span class="nc" id="L4680">					return false;</span>
				}
			} else {
<span class="fc" id="L4683">				_polygonB = polygon_b;</span>
			}

<span class="fc" id="L4686">			scl.append(&quot;****&quot;);</span>
		} else {
<span class="fc" id="L4688">			_polygonB = polygon_b;</span>
<span class="fc" id="L4689">			scl.append(&quot;T***&quot;);</span>
		}

<span class="fc bfc" id="L4692" title="All 2 branches covered.">		if (bExtAIntB) {</span>
<span class="fc bfc" id="L4693" title="All 2 branches covered.">			if (polygon_a.getPointCount() &gt; 10) {</span>
<span class="fc" id="L4694">				_polygonA = (Polygon) (Clipper.clip(polygon_a, envInter,</span>
						tolerance, 0.0));
<span class="pc bpc" id="L4696" title="1 of 2 branches missed.">				if (_polygonA.isEmpty()) {</span>
<span class="nc" id="L4697">					return false;</span>
				}
			} else {
<span class="fc" id="L4700">				_polygonA = polygon_a;</span>
			}

<span class="fc" id="L4703">			scl.append(&quot;***&quot;);</span>
		} else {
<span class="fc" id="L4705">			_polygonA = polygon_a;</span>
<span class="fc" id="L4706">			scl.append(&quot;T**&quot;);</span>
		}

<span class="fc" id="L4709">		boolean bRelation = RelationalOperationsMatrix.polygonRelatePolygon_(</span>
<span class="fc" id="L4710">				_polygonA, _polygonB, tolerance, scl.toString(),</span>
				progressTracker);
<span class="fc" id="L4712">		return bRelation;</span>
	}

	private static boolean polygonContainsPolygonImpl_(Polygon polygon_a,
			Polygon polygon_b, double tolerance, ProgressTracker progressTracker) {
<span class="fc" id="L4717">        boolean[] b_result_known = new boolean[1];</span>
<span class="fc" id="L4718">        b_result_known[0] = false;</span>
<span class="fc" id="L4719">        boolean res = polygonContainsMultiPath_(polygon_a, polygon_b, tolerance, b_result_known, progressTracker);</span>

<span class="fc bfc" id="L4721" title="All 2 branches covered.">        if (b_result_known[0])</span>
<span class="fc" id="L4722">            return res;</span>

        // We can clip polygon_a to the extent of polyline_b

<span class="fc" id="L4726">        Envelope2D envBInflated = new Envelope2D();</span>
<span class="fc" id="L4727">        polygon_b.queryEnvelope2D(envBInflated);</span>
<span class="fc" id="L4728">        envBInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>

<span class="fc" id="L4730">        Polygon _polygonA = null;</span>

<span class="fc bfc" id="L4732" title="All 2 branches covered.">        if (polygon_a.getPointCount() &gt; 10)</span>
        {
<span class="fc" id="L4734">            _polygonA = (Polygon)Clipper.clip(polygon_a, envBInflated, tolerance, 0.0);</span>
<span class="pc bpc" id="L4735" title="1 of 2 branches missed.">            if (_polygonA.isEmpty())</span>
<span class="nc" id="L4736">                return false;</span>
        }
        else
        {
<span class="fc" id="L4740">            _polygonA = polygon_a;</span>
        }

<span class="fc" id="L4743">        boolean bContains = RelationalOperationsMatrix.polygonContainsPolygon_(_polygonA, polygon_b, tolerance, progressTracker);</span>
<span class="fc" id="L4744">        return bContains;</span>
	}

    private static boolean polygonContainsMultiPath_(Polygon polygon_a, MultiPath multi_path_b, double tolerance, boolean[] b_result_known, ProgressTracker progress_tracker)
    {
<span class="fc" id="L4749">        b_result_known[0] = false;</span>

<span class="fc" id="L4751">        MultiPathImpl polygon_impl_a = (MultiPathImpl)polygon_a._getImpl();</span>
<span class="fc" id="L4752">        MultiPathImpl multi_path_impl_b = (MultiPathImpl)multi_path_b._getImpl();</span>

<span class="fc" id="L4754">        SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</span>
<span class="fc" id="L4755">        SegmentIteratorImpl segIterB = multi_path_impl_b.querySegmentIterator();</span>
<span class="fc" id="L4756">        double[] scalarsA = new double[2];</span>
<span class="fc" id="L4757">        double[] scalarsB = new double[2];</span>

<span class="fc" id="L4759">        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(polygon_impl_a, multi_path_impl_b, tolerance, false);</span>
<span class="fc" id="L4760">        boolean b_boundaries_intersect = false;</span>

<span class="fc bfc" id="L4762" title="All 2 branches covered.">        while (intersector.next())</span>
        {
<span class="fc" id="L4764">            int vertex_a = intersector.getRedElement();</span>
<span class="fc" id="L4765">            int vertex_b = intersector.getBlueElement();</span>

<span class="fc" id="L4767">            segIterA.resetToVertex(vertex_a, -1);</span>
<span class="fc" id="L4768">            segIterB.resetToVertex(vertex_b, -1);</span>
<span class="fc" id="L4769">            Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L4770">            Segment segmentB = segIterB.nextSegment();</span>

<span class="fc" id="L4772">            int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA, tolerance);</span>

<span class="fc bfc" id="L4774" title="All 2 branches covered.">            if (result != 0) {</span>
<span class="fc" id="L4775">                b_boundaries_intersect = true;</span>
<span class="fc bfc" id="L4776" title="All 2 branches covered.">                if (result == 1) {</span>
<span class="fc" id="L4777">                    double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L4778">                    double scalar_b_0 = scalarsB[0];</span>

<span class="fc bfc" id="L4780" title="All 8 branches covered.">                    if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0 &amp;&amp; scalar_b_0 &lt; 1.0) {</span>
<span class="fc" id="L4781">                        b_result_known[0] = true;</span>
<span class="fc" id="L4782">                        return false;</span>
                    }
                }
            }
<span class="fc" id="L4786">        }</span>

<span class="fc bfc" id="L4788" title="All 2 branches covered.">        if (!b_boundaries_intersect)</span>
        {
<span class="fc" id="L4790">            b_result_known[0] = true;</span>

            //boundaries do not intersect

<span class="fc" id="L4794">            Envelope2D env_a_inflated = new Envelope2D();</span>
<span class="fc" id="L4795">            polygon_a.queryEnvelope2D(env_a_inflated);</span>
<span class="fc" id="L4796">            env_a_inflated.inflate(tolerance, tolerance);</span>

<span class="fc" id="L4798">            Polygon pa = null;</span>
<span class="fc" id="L4799">            Polygon p_polygon_a = polygon_a;</span>

<span class="fc" id="L4801">            boolean b_checked_polygon_a_quad_tree = false;</span>

<span class="fc" id="L4803">            Envelope2D path_env_b = new Envelope2D();</span>

<span class="fc bfc" id="L4805" title="All 2 branches covered.">            for (int ipath = 0, npath = multi_path_b.getPathCount(); ipath &lt; npath; ipath++)</span>
            {
<span class="pc bpc" id="L4807" title="1 of 2 branches missed.">                if (multi_path_b.getPathSize(ipath) &gt; 0)</span>
                {
<span class="fc" id="L4809">                    multi_path_b.queryPathEnvelope2D(ipath, path_env_b);</span>

<span class="pc bpc" id="L4811" title="1 of 2 branches missed.">                    if (env_a_inflated.isIntersecting(path_env_b))</span>
                    {
<span class="fc" id="L4813">                        Point2D anyPoint = multi_path_b.getXY(multi_path_b.getPathStart(ipath));</span>
<span class="fc" id="L4814">                        int res = PointInPolygonHelper.isPointInPolygon(p_polygon_a, anyPoint, 0);</span>
<span class="fc bfc" id="L4815" title="All 2 branches covered.">                        if (res == 0)</span>
<span class="fc" id="L4816">                            return false;</span>
<span class="fc" id="L4817">                    }</span>
                    else
                    {
<span class="nc" id="L4820">                        return false;</span>
                    }

<span class="fc bfc" id="L4823" title="All 2 branches covered.">                    if (!b_checked_polygon_a_quad_tree) {</span>
<span class="pc bpc" id="L4824" title="5 of 6 branches missed.">                        if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multi_path_b.getPathCount() - 1) &amp;&amp; (polygon_impl_a._getAccelerators() == null || polygon_impl_a._getAccelerators().getQuadTree() == null)) {</span>
<span class="nc" id="L4825">                            pa = new Polygon();</span>
<span class="nc" id="L4826">                            polygon_a.copyTo(pa);</span>
<span class="nc" id="L4827">                            ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</span>
<span class="nc" id="L4828">                            p_polygon_a = pa;</span>
                        } else {
<span class="fc" id="L4830">                            p_polygon_a = polygon_a;</span>
                        }

<span class="fc" id="L4833">                        b_checked_polygon_a_quad_tree = true;</span>
                    }
                }
            }

<span class="pc bpc" id="L4838" title="1 of 4 branches missed.">            if (polygon_a.getPathCount() == 1 || multi_path_b.getType().value() == Geometry.GeometryType.Polyline)</span>
<span class="fc" id="L4839">                return true; //boundaries do not intersect. all paths of b are inside of a</span>

            // Polygon A has multiple rings, and Multi_path B is a polygon.

<span class="fc" id="L4843">            Polygon polygon_b = (Polygon)multi_path_b;</span>

<span class="fc" id="L4845">            Envelope2D env_b_inflated = new Envelope2D();</span>
<span class="fc" id="L4846">            polygon_b.queryEnvelope2D(env_b_inflated);</span>
<span class="fc" id="L4847">            env_b_inflated.inflate(tolerance, tolerance);</span>

<span class="fc" id="L4849">            Polygon pb = null;</span>
<span class="fc" id="L4850">            Polygon p_polygon_b = polygon_b;</span>

<span class="fc" id="L4852">            boolean b_checked_polygon_b_quad_tree = false;</span>

<span class="fc" id="L4854">            Envelope2D path_env_a = new Envelope2D();</span>

<span class="fc bfc" id="L4856" title="All 2 branches covered.">            for (int ipath = 0, npath = polygon_a.getPathCount(); ipath &lt; npath; ipath++)</span>
            {
<span class="pc bpc" id="L4858" title="1 of 2 branches missed.">                if (polygon_a.getPathSize(ipath) &gt; 0)</span>
                {
<span class="fc" id="L4860">                    polygon_a.queryPathEnvelope2D(ipath, path_env_a);</span>

<span class="pc bpc" id="L4862" title="1 of 2 branches missed.">                    if (env_b_inflated.isIntersecting(path_env_a))</span>
                    {
<span class="fc" id="L4864">                        Point2D anyPoint = polygon_a.getXY(polygon_a.getPathStart(ipath));</span>
<span class="fc" id="L4865">                        int res = PointInPolygonHelper.isPointInPolygon(p_polygon_b, anyPoint, 0);</span>
<span class="fc bfc" id="L4866" title="All 2 branches covered.">                        if (res == 1)</span>
<span class="fc" id="L4867">                            return false;</span>
                    }

<span class="fc bfc" id="L4870" title="All 2 branches covered.">                    if (!b_checked_polygon_b_quad_tree) {</span>
<span class="pc bpc" id="L4871" title="5 of 6 branches missed.">                        if (PointInPolygonHelper.quadTreeWillHelp(polygon_b, polygon_a.getPathCount() - 1) &amp;&amp; (multi_path_impl_b._getAccelerators() == null || multi_path_impl_b._getAccelerators().getQuadTree() == null)) {</span>
<span class="nc" id="L4872">                            pb = new Polygon();</span>
<span class="nc" id="L4873">                            polygon_b.copyTo(pb);</span>
<span class="nc" id="L4874">                            ((MultiPathImpl) pb._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</span>
<span class="nc" id="L4875">                            p_polygon_b = pb;</span>
                        } else {
<span class="fc" id="L4877">                            p_polygon_b = polygon_b;</span>
                        }

<span class="fc" id="L4880">                        b_checked_polygon_b_quad_tree = true;</span>
                    }
                }
            }

<span class="fc" id="L4885">            return true;</span>
        }

<span class="fc" id="L4888">        return false;</span>
    }

	private static boolean polygonTouchesPolylineImpl_(Polygon polygon_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progressTracker) {
<span class="fc" id="L4894">		MultiPathImpl polygon_impl_a = (MultiPathImpl) polygon_a._getImpl();</span>
<span class="fc" id="L4895">		MultiPathImpl polyline_impl_b = (MultiPathImpl) polyline_b._getImpl();</span>

<span class="fc" id="L4897">		SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</span>
<span class="fc" id="L4898">		SegmentIteratorImpl segIterB = polyline_impl_b.querySegmentIterator();</span>
<span class="fc" id="L4899">		double[] scalarsA = new double[2];</span>
<span class="fc" id="L4900">		double[] scalarsB = new double[2];</span>

<span class="fc" id="L4902">		PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(</span>
				polygon_impl_a, polyline_impl_b, tolerance, false);

<span class="fc" id="L4905">		boolean b_boundaries_intersect = false;</span>

<span class="fc bfc" id="L4907" title="All 2 branches covered.">		while (intersector.next()) {</span>
<span class="fc" id="L4908">			int vertex_a = intersector.getRedElement();</span>
<span class="fc" id="L4909">			int vertex_b = intersector.getBlueElement();</span>

<span class="fc" id="L4911">			segIterA.resetToVertex(vertex_a);</span>
<span class="fc" id="L4912">			segIterB.resetToVertex(vertex_b);</span>
<span class="fc" id="L4913">			Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L4914">			Segment segmentB = segIterB.nextSegment();</span>

<span class="fc" id="L4916">			int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA,</span>
					tolerance);

<span class="fc bfc" id="L4919" title="All 2 branches covered.">			if (result == 2) {</span>
<span class="fc" id="L4920">				b_boundaries_intersect = true;</span>
<span class="fc bfc" id="L4921" title="All 2 branches covered.">			} else if (result != 0) {</span>
<span class="fc" id="L4922">				double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L4923">				double scalar_b_0 = scalarsB[0];</span>

<span class="pc bpc" id="L4925" title="1 of 8 branches missed.">				if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0</span>
						&amp;&amp; scalar_b_0 &lt; 1.0) {
<span class="fc" id="L4927">					return false;</span>
				}

<span class="fc" id="L4930">				b_boundaries_intersect = true;</span>
			}
<span class="fc" id="L4932">		}</span>

<span class="pc bpc" id="L4934" title="1 of 2 branches missed.">		if (!b_boundaries_intersect) {</span>
<span class="nc" id="L4935">			return false;</span>
		}

<span class="fc" id="L4938">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), envInter = new Envelope2D();</span>
<span class="fc" id="L4939">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L4940">		polyline_b.queryEnvelope2D(env_b);</span>
<span class="fc" id="L4941">		env_a.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>
<span class="fc" id="L4942">		env_b.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>
<span class="fc" id="L4943">		envInter.setCoords(env_a);</span>
<span class="fc" id="L4944">		envInter.intersect(env_b);</span>

		Polygon _polygonA;
		Polyline _polylineB;

<span class="fc bfc" id="L4949" title="All 2 branches covered.">		if (polygon_a.getPointCount() &gt; 10) {</span>
<span class="fc" id="L4950">			_polygonA = (Polygon) (Clipper.clip(polygon_a, envInter, tolerance,</span>
					0.0));
<span class="pc bpc" id="L4952" title="1 of 2 branches missed.">			if (_polygonA.isEmpty()) {</span>
<span class="nc" id="L4953">				return false;</span>
			}
		} else {
<span class="fc" id="L4956">			_polygonA = polygon_a;</span>
		}

<span class="pc bpc" id="L4959" title="1 of 2 branches missed.">		if (polyline_b.getPointCount() &gt; 10) {</span>
<span class="nc" id="L4960">			_polylineB = (Polyline) Clipper.clip(polyline_b, envInter,</span>
					tolerance, 0.0);
<span class="nc bnc" id="L4962" title="All 2 branches missed.">			if (_polylineB.isEmpty()) {</span>
<span class="nc" id="L4963">				return false;</span>
			}
		} else {
<span class="fc" id="L4966">			_polylineB = polyline_b;</span>
		}

		// We just need to determine that interior_interior is false
<span class="fc" id="L4970">		String scl = &quot;F********&quot;;</span>
<span class="fc" id="L4971">		boolean bRelation = RelationalOperationsMatrix.polygonRelatePolyline_(</span>
				_polygonA, _polylineB, tolerance, scl, progressTracker);

<span class="fc" id="L4974">		return bRelation;</span>
	}

	private static boolean polygonCrossesPolylineImpl_(Polygon polygon_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progressTracker) {
<span class="fc" id="L4980">		MultiPathImpl polygon_impl_a = (MultiPathImpl) polygon_a._getImpl();</span>
<span class="fc" id="L4981">		MultiPathImpl polyline_impl_b = (MultiPathImpl) polyline_b._getImpl();</span>

<span class="fc" id="L4983">		SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</span>
<span class="fc" id="L4984">		SegmentIteratorImpl segIterB = polyline_impl_b.querySegmentIterator();</span>
<span class="fc" id="L4985">		double[] scalarsA = new double[2];</span>
<span class="fc" id="L4986">		double[] scalarsB = new double[2];</span>

<span class="fc" id="L4988">		PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(</span>
				polygon_impl_a, polyline_impl_b, tolerance, false);

<span class="fc" id="L4991">		boolean b_boundaries_intersect = false;</span>

<span class="fc bfc" id="L4993" title="All 2 branches covered.">		while (intersector.next()) {</span>
<span class="fc" id="L4994">			int vertex_a = intersector.getRedElement();</span>
<span class="fc" id="L4995">			int vertex_b = intersector.getBlueElement();</span>

<span class="fc" id="L4997">			segIterA.resetToVertex(vertex_a);</span>
<span class="fc" id="L4998">			segIterB.resetToVertex(vertex_b);</span>
<span class="fc" id="L4999">			Segment segmentA = segIterA.nextSegment();</span>
<span class="fc" id="L5000">			Segment segmentB = segIterB.nextSegment();</span>

<span class="fc" id="L5002">			int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA,</span>
					tolerance);

<span class="fc bfc" id="L5005" title="All 2 branches covered.">			if (result == 2) {</span>
<span class="fc" id="L5006">				b_boundaries_intersect = true;</span>
<span class="pc bpc" id="L5007" title="1 of 2 branches missed.">			} else if (result != 0) {</span>
<span class="fc" id="L5008">				double scalar_a_0 = scalarsA[0];</span>
<span class="fc" id="L5009">				double scalar_b_0 = scalarsB[0];</span>

<span class="fc bfc" id="L5011" title="All 8 branches covered.">				if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0</span>
						&amp;&amp; scalar_b_0 &lt; 1.0) {
<span class="fc" id="L5013">					return true;</span>
				}

<span class="fc" id="L5016">				b_boundaries_intersect = true;</span>
			}
<span class="fc" id="L5018">		}</span>

<span class="pc bpc" id="L5020" title="1 of 2 branches missed.">		if (!b_boundaries_intersect) {</span>
<span class="nc" id="L5021">			return false;</span>
		}

<span class="fc" id="L5024">		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), envAInflated = new Envelope2D(), envBInflated = new Envelope2D(), envInter = new Envelope2D();</span>
<span class="fc" id="L5025">		polygon_a.queryEnvelope2D(env_a);</span>
<span class="fc" id="L5026">		polyline_b.queryEnvelope2D(env_b);</span>

<span class="fc bfc" id="L5028" title="All 2 branches covered.">		if (interiorEnvExteriorEnv_(env_b, env_a, tolerance)) {</span>
<span class="fc" id="L5029">			envAInflated.setCoords(env_a);</span>
<span class="fc" id="L5030">			envAInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>
<span class="fc" id="L5031">			envBInflated.setCoords(env_b);</span>
<span class="fc" id="L5032">			envBInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>
<span class="fc" id="L5033">			envInter.setCoords(envAInflated);</span>
<span class="fc" id="L5034">			envInter.intersect(envBInflated);</span>

			Polygon _polygonA;
			Polyline _polylineB;

<span class="pc bpc" id="L5039" title="1 of 2 branches missed.">			if (polygon_a.getPointCount() &gt; 10) {</span>
<span class="nc" id="L5040">				_polygonA = (Polygon) (Clipper.clip(polygon_a, envInter,</span>
						tolerance, 0.0));
<span class="nc bnc" id="L5042" title="All 2 branches missed.">				if (_polygonA.isEmpty()) {</span>
<span class="nc" id="L5043">					return false;</span>
				}
			} else {
<span class="fc" id="L5046">				_polygonA = polygon_a;</span>
			}

<span class="pc bpc" id="L5049" title="1 of 2 branches missed.">			if (polyline_b.getPointCount() &gt; 10) {</span>
<span class="nc" id="L5050">				_polylineB = (Polyline) (Clipper.clip(polyline_b, envInter,</span>
						tolerance, 0.0));
<span class="nc bnc" id="L5052" title="All 2 branches missed.">				if (_polylineB.isEmpty()) {</span>
<span class="nc" id="L5053">					return false;</span>
				}
			} else {
<span class="fc" id="L5056">				_polylineB = polyline_b;</span>
			}

<span class="fc" id="L5059">			String scl = &quot;T********&quot;;</span>
<span class="fc" id="L5060">			boolean bRelation = RelationalOperationsMatrix</span>
<span class="fc" id="L5061">					.polygonRelatePolyline_(_polygonA, _polylineB, tolerance,</span>
							scl, progressTracker);
<span class="fc" id="L5063">			return bRelation;</span>
		}

<span class="fc" id="L5066">		String scl = &quot;T*****T**&quot;;</span>
<span class="fc" id="L5067">		boolean bRelation = RelationalOperationsMatrix.polygonRelatePolyline_(</span>
				polygon_a, polyline_b, tolerance, scl, progressTracker);

<span class="fc" id="L5070">		return bRelation;</span>
	}

	private static boolean polygonContainsPolylineImpl_(Polygon polygon_a,
			Polyline polyline_b, double tolerance,
			ProgressTracker progress_tracker) {
<span class="fc" id="L5076">        boolean[] b_result_known = new boolean[1];</span>
<span class="fc" id="L5077">        b_result_known[0] = false;</span>
<span class="fc" id="L5078">        boolean res = polygonContainsMultiPath_(polygon_a, polyline_b, tolerance, b_result_known, progress_tracker);</span>

<span class="fc bfc" id="L5080" title="All 2 branches covered.">        if (b_result_known[0])</span>
<span class="fc" id="L5081">            return res;</span>

        // We can clip polygon_a to the extent of polyline_b

<span class="fc" id="L5085">        Envelope2D envBInflated = new Envelope2D();</span>
<span class="fc" id="L5086">        polyline_b.queryEnvelope2D(envBInflated);</span>
<span class="fc" id="L5087">        envBInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</span>

<span class="fc" id="L5089">        Polygon _polygonA = null;</span>

<span class="fc bfc" id="L5091" title="All 2 branches covered.">        if (polygon_a.getPointCount() &gt; 10)</span>
        {
<span class="fc" id="L5093">            _polygonA = (Polygon)Clipper.clip(polygon_a, envBInflated, tolerance, 0.0);</span>
<span class="pc bpc" id="L5094" title="1 of 2 branches missed.">            if (_polygonA.isEmpty())</span>
<span class="nc" id="L5095">                return false;</span>
        }
        else
        {
<span class="fc" id="L5099">            _polygonA = polygon_a;</span>
        }

<span class="fc" id="L5102">        boolean bContains = RelationalOperationsMatrix.polygonContainsPolyline_(_polygonA, polyline_b, tolerance, progress_tracker);</span>
<span class="fc" id="L5103">        return bContains;</span>
	}

	private static boolean polygonContainsPointImpl_(Polygon polygon_a,
			Point2D pt_b, double tolerance, ProgressTracker progressTracker) {
<span class="fc" id="L5108">		PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(</span>
				polygon_a, pt_b, tolerance);

<span class="fc bfc" id="L5111" title="All 2 branches covered.">		if (result == PolygonUtils.PiPResult.PiPInside)</span>
<span class="fc" id="L5112">			return true;</span>

<span class="fc" id="L5114">		return false;</span>
	}

	private static boolean polygonTouchesPointImpl_(Polygon polygon_a,
			Point2D pt_b, double tolerance, ProgressTracker progressTracker) {
<span class="fc" id="L5119">		PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(</span>
				polygon_a, pt_b, tolerance);

<span class="fc bfc" id="L5122" title="All 2 branches covered.">		if (result == PolygonUtils.PiPResult.PiPBoundary)</span>
<span class="fc" id="L5123">			return true;</span>

<span class="fc" id="L5125">		return false;</span>
	}

	static boolean multiPointDisjointPointImpl_(MultiPoint multipoint_a,
			Point2D pt_b, double tolerance, ProgressTracker progressTracker) {
<span class="fc" id="L5130">		Point2D pt_a = new Point2D();</span>
<span class="fc" id="L5131">		double tolerance_sq = tolerance * tolerance;</span>

<span class="fc bfc" id="L5133" title="All 2 branches covered.">		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</span>
<span class="fc" id="L5134">			multipoint_a.getXY(i, pt_a);</span>

<span class="fc bfc" id="L5136" title="All 2 branches covered.">			if (Point2D.sqrDistance(pt_a, pt_b) &lt;= tolerance_sq)</span>
<span class="fc" id="L5137">				return false;</span>
		}

<span class="fc" id="L5140">		return true;</span>
	}

	private static final class OverlapEvent {
		int m_ivertex_a;
		int m_ipath_a;
		double m_scalar_a_0;
		double m_scalar_a_1;
		int m_ivertex_b;
//		int m_ipath_b;
//		double m_scalar_b_0;
//		double m_scalar_b_1;

		static OverlapEvent construct(int ivertex_a, int ipath_a,
				double scalar_a_0, double scalar_a_1, int ivertex_b,
				int ipath_b, double scalar_b_0, double scalar_b_1) {
<span class="fc" id="L5156">			OverlapEvent overlapEvent = new OverlapEvent();</span>
<span class="fc" id="L5157">			overlapEvent.m_ivertex_a = ivertex_a;</span>
<span class="fc" id="L5158">			overlapEvent.m_ipath_a = ipath_a;</span>
<span class="fc" id="L5159">			overlapEvent.m_scalar_a_0 = scalar_a_0;</span>
<span class="fc" id="L5160">			overlapEvent.m_scalar_a_1 = scalar_a_1;</span>
<span class="fc" id="L5161">			overlapEvent.m_ivertex_b = ivertex_b;</span>
//			overlapEvent.m_ipath_b = ipath_b;
//			overlapEvent.m_scalar_b_0 = scalar_b_0;
//			overlapEvent.m_scalar_b_1 = scalar_b_1;
<span class="fc" id="L5165">			return overlapEvent;</span>
		}
	}

	ArrayList&lt;OverlapEvent&gt; m_overlap_events;

<span class="fc" id="L5171">	private RelationalOperations() {</span>
<span class="fc" id="L5172">		m_overlap_events = new ArrayList&lt;OverlapEvent&gt;();</span>
<span class="fc" id="L5173">	}</span>

	private static class OverlapComparer extends
			AttributeStreamOfInt32.IntComparator {
<span class="fc" id="L5177">		OverlapComparer(RelationalOperations rel_ops) {</span>
<span class="fc" id="L5178">			m_rel_ops = rel_ops;</span>
<span class="fc" id="L5179">		}</span>

		@Override
		public int compare(int o_1, int o_2) {
<span class="fc" id="L5183">			return m_rel_ops.compareOverlapEvents_(o_1, o_2);</span>
		}

		private RelationalOperations m_rel_ops;
	}

	int compareOverlapEvents_(int o_1, int o_2) {
<span class="fc" id="L5190">		OverlapEvent overlapEvent1 = m_overlap_events.get(o_1);</span>
<span class="fc" id="L5191">		OverlapEvent overlapEvent2 = m_overlap_events.get(o_2);</span>

<span class="pc bpc" id="L5193" title="1 of 2 branches missed.">		if (overlapEvent1.m_ipath_a &lt; overlapEvent2.m_ipath_a)</span>
<span class="nc" id="L5194">			return -1;</span>

<span class="pc bpc" id="L5196" title="1 of 2 branches missed.">		if (overlapEvent1.m_ipath_a == overlapEvent2.m_ipath_a) {</span>
<span class="pc bpc" id="L5197" title="1 of 2 branches missed.">			if (overlapEvent1.m_ivertex_a &lt; overlapEvent2.m_ivertex_a)</span>
<span class="nc" id="L5198">				return -1;</span>

<span class="pc bpc" id="L5200" title="1 of 2 branches missed.">			if (overlapEvent1.m_ivertex_a == overlapEvent2.m_ivertex_a) {</span>
<span class="fc bfc" id="L5201" title="All 2 branches covered.">				if (overlapEvent1.m_scalar_a_0 &lt; overlapEvent2.m_scalar_a_0)</span>
<span class="fc" id="L5202">					return -1;</span>

<span class="pc bpc" id="L5204" title="1 of 2 branches missed.">				if (overlapEvent1.m_scalar_a_0 == overlapEvent2.m_scalar_a_0) {</span>
<span class="nc bnc" id="L5205" title="All 2 branches missed.">					if (overlapEvent1.m_scalar_a_1 &lt; overlapEvent2.m_scalar_a_1)</span>
<span class="nc" id="L5206">						return -1;</span>

<span class="nc bnc" id="L5208" title="All 2 branches missed.">					if (overlapEvent1.m_scalar_a_1 == overlapEvent2.m_scalar_a_1) {</span>
<span class="nc bnc" id="L5209" title="All 2 branches missed.">						if (overlapEvent1.m_ivertex_b &lt; overlapEvent2.m_ivertex_b)</span>
<span class="nc" id="L5210">							return -1;</span>
					}
				}
			}
		}

<span class="fc" id="L5216">		return 1;</span>
	}

<span class="nc" id="L5219">	static final class Accelerate_helper {</span>
		static boolean accelerate_geometry(Geometry geometry,
				SpatialReference sr,
				Geometry.GeometryAccelerationDegree accel_degree) {
<span class="pc bpc" id="L5223" title="1 of 2 branches missed.">			if (!can_accelerate_geometry(geometry))</span>
<span class="nc" id="L5224">				return false;</span>

<span class="fc" id="L5226">			double tol = InternalUtils.calculateToleranceFromGeometry(sr,</span>
					geometry, false);
<span class="fc" id="L5228">			boolean bAccelerated = false;</span>
<span class="pc bpc" id="L5229" title="1 of 2 branches missed.">			if (GeometryAccelerators.canUseRasterizedGeometry(geometry))</span>
<span class="fc" id="L5230">				bAccelerated |= ((MultiVertexGeometryImpl) geometry._getImpl())</span>
<span class="fc" id="L5231">						._buildRasterizedGeometryAccelerator(tol, accel_degree);</span>

<span class="fc" id="L5233">			Geometry.Type type = geometry.getType();</span>
<span class="pc bpc" id="L5234" title="1 of 4 branches missed.">			if ((type == Geometry.Type.Polygon || type == Geometry.Type.Polyline)</span>
<span class="fc bfc" id="L5235" title="All 4 branches covered.">					&amp;&amp; GeometryAccelerators.canUseQuadTree(geometry)</span>
					&amp;&amp; accel_degree != Geometry.GeometryAccelerationDegree.enumMild)
<span class="fc" id="L5237">				bAccelerated |= ((MultiVertexGeometryImpl) geometry._getImpl())</span>
<span class="fc" id="L5238">						._buildQuadTreeAccelerator(accel_degree);</span>

<span class="pc bpc" id="L5240" title="1 of 4 branches missed.">			if ((type == Geometry.Type.Polygon || type == Geometry.Type.Polyline)</span>
<span class="fc bfc" id="L5241" title="All 4 branches covered.">					&amp;&amp; GeometryAccelerators.canUseQuadTreeForPaths(geometry)</span>
					&amp;&amp; accel_degree != Geometry.GeometryAccelerationDegree.enumMild)
<span class="fc" id="L5243">				bAccelerated |= ((MultiPathImpl) geometry._getImpl())</span>
<span class="fc" id="L5244">						._buildQuadTreeForPathsAccelerator(accel_degree);</span>

<span class="fc" id="L5246">			return bAccelerated;</span>
		}

        static boolean can_accelerate_geometry(Geometry geometry) {
<span class="pc bpc" id="L5250" title="1 of 2 branches missed.">            return GeometryAccelerators.canUseRasterizedGeometry(geometry)</span>
<span class="pc bnc" id="L5251" title="All 4 branches missed.">                    || GeometryAccelerators.canUseQuadTree(geometry) || GeometryAccelerators.canUseQuadTreeForPaths(geometry);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>