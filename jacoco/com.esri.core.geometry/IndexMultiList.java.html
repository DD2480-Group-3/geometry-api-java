<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IndexMultiList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">IndexMultiList.java</span></div><h1>IndexMultiList.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2015 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */
package com.esri.core.geometry;

<span class="fc" id="L26">class IndexMultiList {</span>

	StridedIndexTypeCollection m_listNodes; // stores lists and list elements.
											// Each list element is Index, next.
	StridedIndexTypeCollection m_lists; // stores lists. Each list is Head,
										// Tail, [PrevList, NextList].
	int m_list_of_lists;
	boolean m_b_allow_navigation_between_lists;// when False, get_first_list,
												// get_next_list return -1.

	void freeNode_(int node) {
<span class="fc" id="L37">		m_listNodes.deleteElement(node);</span>
<span class="fc" id="L38">	}</span>

	int newNode_() {
<span class="fc" id="L41">		int node = m_listNodes.newElement();</span>
<span class="fc" id="L42">		return node;</span>
	}

	void freeList_(int list) {
<span class="fc" id="L46">		m_lists.deleteElement(list);</span>
<span class="fc" id="L47">	}</span>

	int newList_() {
<span class="fc" id="L50">		int list = m_lists.newElement();</span>
<span class="fc" id="L51">		return list;</span>
	}

	// Same as Index_multi_list(true);
<span class="fc" id="L55">	IndexMultiList() {</span>
<span class="fc" id="L56">		m_listNodes = new StridedIndexTypeCollection(2);</span>
<span class="fc" id="L57">		m_lists = new StridedIndexTypeCollection(4);</span>
<span class="fc" id="L58">		m_list_of_lists = nullNode();</span>
<span class="fc" id="L59">		m_b_allow_navigation_between_lists = true;</span>
<span class="fc" id="L60">	}</span>

	// When b_allow_navigation_between_lists is False, the get_first_list and
	// get_next_list do not work.
	// There will be two Index_type elements per list and two Index_type
	// elements per list element
	// When b_allow_navigation_between_lists is True, the get_first_list and
	// get_next_list will work.
	// There will be four Index_type elements per list and two Index_type
	// elements per list element
<span class="nc" id="L70">	IndexMultiList(boolean b_allow_navigation_between_lists) {</span>
<span class="nc" id="L71">		m_listNodes = new StridedIndexTypeCollection(2);</span>
<span class="nc" id="L72">		m_lists = new StridedIndexTypeCollection(</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">				b_allow_navigation_between_lists ? 4 : 2);</span>
<span class="nc" id="L74">		m_list_of_lists = nullNode();</span>
<span class="nc" id="L75">		m_b_allow_navigation_between_lists = b_allow_navigation_between_lists;</span>
<span class="nc" id="L76">	}</span>

	// Creates new list and returns it's handle.
	int createList() {
<span class="fc" id="L80">		int node = newList_();</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">		if (m_b_allow_navigation_between_lists) {</span>
<span class="fc" id="L82">			m_lists.setField(node, 3, m_list_of_lists);</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">			if (m_list_of_lists != nullNode())</span>
<span class="fc" id="L84">				m_lists.setField(m_list_of_lists, 2, node);</span>
<span class="fc" id="L85">			m_list_of_lists = node;</span>
		}

<span class="fc" id="L88">		return node;</span>
	}

	// Deletes a list.
	void deleteList(int list) {
<span class="fc" id="L93">		int ptr = getFirst(list);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">		while (ptr != nullNode()) {</span>
<span class="fc" id="L95">			int p = ptr;</span>
<span class="fc" id="L96">			ptr = getNext(ptr);</span>
<span class="fc" id="L97">			freeNode_(p);</span>
<span class="fc" id="L98">		}</span>

<span class="pc bpc" id="L100" title="1 of 2 branches missed.">		if (m_b_allow_navigation_between_lists) {</span>
<span class="fc" id="L101">			int prevList = m_lists.getField(list, 2);</span>
<span class="fc" id="L102">			int nextList = m_lists.getField(list, 3);</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">			if (prevList != nullNode())</span>
<span class="fc" id="L104">				m_lists.setField(prevList, 3, nextList);</span>
			else
<span class="fc" id="L106">				m_list_of_lists = nextList;</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">			if (nextList != nullNode())</span>
<span class="fc" id="L109">				m_lists.setField(nextList, 2, prevList);</span>
		}

<span class="fc" id="L112">		freeList_(list);</span>
<span class="fc" id="L113">	}</span>

	// Reserves memory for the given number of lists.
	void reserveLists(int listCount) {
<span class="fc" id="L117">		m_lists.setCapacity(listCount);</span>
<span class="fc" id="L118">	}</span>

	// Adds element to a given list. The element is added to the end. Returns
	// the new
	int addElement(int list, int element) {
<span class="fc" id="L123">		int head = m_lists.getField(list, 0);</span>
<span class="fc" id="L124">		int tail = m_lists.getField(list, 1);</span>
<span class="fc" id="L125">		int node = newNode_();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">		if (tail != nullNode()) {</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">			assert (head != nullNode());</span>
<span class="fc" id="L128">			m_listNodes.setField(tail, 1, node);</span>
<span class="fc" id="L129">			m_lists.setField(list, 1, node);</span>
		} else {// empty list
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">			assert (head == nullNode());</span>
<span class="fc" id="L132">			m_lists.setField(list, 0, node);</span>
<span class="fc" id="L133">			m_lists.setField(list, 1, node);</span>
		}

<span class="fc" id="L136">		m_listNodes.setField(node, 0, element);</span>
<span class="fc" id="L137">		return node;</span>
	}

	// Reserves memory for the given number of nodes.
	void reserveNodes(int nodeCount) {
<span class="fc" id="L142">		m_listNodes.setCapacity(nodeCount);</span>
<span class="fc" id="L143">	}</span>

	// Deletes a node from a list, given the previous node (previous node is
	// required, because the list is singly connected).
	void deleteElement(int list, int prevNode, int node) {
<span class="fc bfc" id="L148" title="All 2 branches covered.">		if (prevNode != nullNode()) {</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">			assert (m_listNodes.getField(prevNode, 1) == node);</span>
<span class="fc" id="L150">			m_listNodes.setField(prevNode, 1, m_listNodes.getField(node, 1));</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">			if (m_lists.getField(list, 1) == node)// deleting a tail</span>
			{
<span class="fc" id="L153">				m_lists.setField(list, 1, prevNode);</span>
			}
		} else {
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">			assert (m_lists.getField(list, 0) == node);</span>
<span class="fc" id="L157">			m_lists.setField(list, 0, m_listNodes.getField(node, 1));</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">			if (m_lists.getField(list, 1) == node) {// removing last element</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">				assert (m_listNodes.getField(node, 1) == nullNode());</span>
<span class="fc" id="L160">				m_lists.setField(list, 1, nullNode());</span>
			}
		}
<span class="fc" id="L163">		freeNode_(node);</span>
<span class="fc" id="L164">	}</span>

	// Concatenates list1 and list2. The nodes of list2 are added to the end of
	// list1. The list2 index becomes invalid.
	// Returns list1.
	int concatenateLists(int list1, int list2) {
<span class="fc" id="L170">		int tailNode1 = m_lists.getField(list1, 1);</span>
<span class="fc" id="L171">		int headNode2 = m_lists.getField(list2, 0);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">		if (headNode2 != nullNode())// do not concatenate empty lists</span>
		{
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">			if (tailNode1 != nullNode()) {</span>
				// connect head of list2 to the tail of list1.
<span class="fc" id="L176">				m_listNodes.setField(tailNode1, 1, headNode2);</span>
				// set the tail of the list1 to be the tail of list2.
<span class="fc" id="L178">				m_lists.setField(list1, 1, m_lists.getField(list2, 1));</span>
			} else {// list1 is empty, while list2 is not.
<span class="nc" id="L180">				m_lists.setField(list1, 0, headNode2);</span>
<span class="nc" id="L181">				m_lists.setField(list1, 1, m_lists.getField(list2, 1));</span>
			}
		}

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		if (m_b_allow_navigation_between_lists) {</span>
<span class="fc" id="L186">			int prevList = m_lists.getField(list2, 2);</span>
<span class="fc" id="L187">			int nextList = m_lists.getField(list2, 3);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">			if (prevList != nullNode())</span>
<span class="fc" id="L189">				m_lists.setField(prevList, 3, nextList);</span>
			else
<span class="fc" id="L191">				m_list_of_lists = nextList;</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">			if (nextList != nullNode())</span>
<span class="fc" id="L194">				m_lists.setField(nextList, 2, prevList);</span>
		}

<span class="fc" id="L197">		freeList_(list2);</span>
<span class="fc" id="L198">		return list1;</span>
	}

	// Returns the data from the given list node.
	int getElement(int node_index) {
<span class="fc" id="L203">		return m_listNodes.getField(node_index, 0);</span>
	}

	// Sets the data to the given list node.
	void setElement(int node_index, int element) {
<span class="nc" id="L208">		m_listNodes.setField(node_index, 0, element);</span>
<span class="nc" id="L209">	}</span>

	// Returns index of next node for the give node.
	int getNext(int node_index) {
<span class="fc" id="L213">		return m_listNodes.getField(node_index, 1);</span>
	}

	// Returns the first node in the least
	int getFirst(int list) {
<span class="fc" id="L218">		return m_lists.getField(list, 0);</span>
	}

	// Returns the element from the first node in the least. Equivalent to
	// get_element(get_first(list));
	int getFirstElement(int list) {
<span class="fc" id="L224">		int f = getFirst(list);</span>
<span class="fc" id="L225">		return getElement(f);</span>
	}

	// Check if the node is Null (does not exist)
	static int nullNode() {
<span class="fc" id="L230">		return -1;</span>
	}

	// Clears all nodes and removes all lists. Frees the memory.
	void clear() {
<span class="nc" id="L235">		m_listNodes.deleteAll(true);</span>
<span class="nc" id="L236">		m_lists.deleteAll(true);</span>
<span class="nc" id="L237">		m_list_of_lists = nullNode();</span>
<span class="nc" id="L238">	}</span>

	// Returns True if the given list is empty.
	boolean isEmpty(int list) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">		return m_lists.getField(list, 0) == nullNode();</span>
	}

	boolean isEmpty() {
<span class="nc bnc" id="L246" title="All 2 branches missed.">		return m_listNodes.size() == 0;</span>
	}

	int getNodeCount() {
<span class="nc" id="L250">		return m_listNodes.size();</span>
	}

	int getListCount() {
<span class="nc" id="L254">		return m_lists.size();</span>
	}

	int getFirstList() {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">		assert (m_b_allow_navigation_between_lists);</span>
<span class="fc" id="L259">		return m_list_of_lists;</span>
	}

	int getNextList(int list) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">		assert (m_b_allow_navigation_between_lists);</span>
<span class="fc" id="L264">		return m_lists.getField(list, 3);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>