<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OperatorFactoryLocal.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">OperatorFactoryLocal.java</span></div><h1>OperatorFactoryLocal.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2017 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */

package com.esri.core.geometry;

import com.esri.core.geometry.Operator.Type;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.Reader;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;
import java.util.HashMap;

/**
 *An abstract class that represent the basic OperatorFactory interface.
 */
public class OperatorFactoryLocal extends OperatorFactory {
<span class="fc" id="L45">	private static final OperatorFactoryLocal INSTANCE = new OperatorFactoryLocal();</span>

<span class="fc" id="L47">	private static final HashMap&lt;Operator.Type, Operator&gt; st_supportedOperators = new HashMap&lt;Operator.Type, Operator&gt;();</span>

	static {
		// Register all implemented operator allocators in the dictionary

<span class="fc" id="L52">		st_supportedOperators.put(Type.Project, new OperatorProjectLocal());</span>
<span class="fc" id="L53">		st_supportedOperators.put(Type.ExportToJson,</span>
				new OperatorExportToJsonLocal());
<span class="fc" id="L55">		st_supportedOperators.put(Type.ImportFromJson,</span>
				new OperatorImportFromJsonLocal());
<span class="fc" id="L57">		st_supportedOperators.put(Type.ExportToESRIShape,</span>
				new OperatorExportToESRIShapeLocal());
<span class="fc" id="L59">		st_supportedOperators.put(Type.ImportFromESRIShape,</span>
				new OperatorImportFromESRIShapeLocal());

<span class="fc" id="L62">		st_supportedOperators.put(Type.Proximity2D,</span>
				new OperatorProximity2DLocal());
<span class="fc" id="L64">		st_supportedOperators.put(Type.Centroid2D,</span>
				new OperatorCentroid2DLocal());
<span class="fc" id="L66">		st_supportedOperators.put(Type.DensifyByLength,</span>
				new OperatorDensifyByLengthLocal());

<span class="fc" id="L69">		st_supportedOperators.put(Type.Relate, new OperatorRelateLocal());</span>
<span class="fc" id="L70">		st_supportedOperators.put(Type.Equals, new OperatorEqualsLocal());</span>
<span class="fc" id="L71">		st_supportedOperators.put(Type.Disjoint, new OperatorDisjointLocal());</span>

<span class="fc" id="L73">		st_supportedOperators.put(Type.Intersects,</span>
				new OperatorIntersectsLocal());
<span class="fc" id="L75">		st_supportedOperators.put(Type.Within, new OperatorWithinLocal());</span>
<span class="fc" id="L76">		st_supportedOperators.put(Type.Contains, new OperatorContainsLocal());</span>
<span class="fc" id="L77">		st_supportedOperators.put(Type.Crosses, new OperatorCrossesLocal());</span>
<span class="fc" id="L78">		st_supportedOperators.put(Type.Touches, new OperatorTouchesLocal());</span>
<span class="fc" id="L79">		st_supportedOperators.put(Type.Overlaps, new OperatorOverlapsLocal());</span>

<span class="fc" id="L81">		st_supportedOperators.put(Type.SimplifyOGC,</span>
				new OperatorSimplifyLocalOGC());
<span class="fc" id="L83">		st_supportedOperators.put(Type.Simplify, new OperatorSimplifyLocal());</span>
<span class="fc" id="L84">		st_supportedOperators.put(Type.Offset, new OperatorOffsetLocal());</span>

<span class="fc" id="L86">		st_supportedOperators.put(Type.GeodeticDensifyByLength,</span>
				new OperatorGeodeticDensifyLocal());
		
<span class="fc" id="L89">	  st_supportedOperators.put(Type.ShapePreservingDensify,</span>
		    new OperatorShapePreservingDensifyLocal());	
		
<span class="fc" id="L92">	  st_supportedOperators.put(Type.GeodesicBuffer,</span>
		    new OperatorGeodesicBufferLocal());	

<span class="fc" id="L95">		st_supportedOperators.put(Type.GeodeticLength,</span>
				new OperatorGeodeticLengthLocal());
<span class="fc" id="L97">		st_supportedOperators.put(Type.GeodeticArea,</span>
				new OperatorGeodeticAreaLocal());

<span class="fc" id="L100">		st_supportedOperators.put(Type.Buffer, new OperatorBufferLocal());</span>
<span class="fc" id="L101">		st_supportedOperators.put(Type.Distance, new OperatorDistanceLocal());</span>
<span class="fc" id="L102">		st_supportedOperators.put(Type.Intersection,</span>
				new OperatorIntersectionLocal());
<span class="fc" id="L104">		st_supportedOperators.put(Type.Difference,</span>
				new OperatorDifferenceLocal());
<span class="fc" id="L106">		st_supportedOperators.put(Type.SymmetricDifference,</span>
				new OperatorSymmetricDifferenceLocal());
<span class="fc" id="L108">		st_supportedOperators.put(Type.Clip, new OperatorClipLocal());</span>
<span class="fc" id="L109">		st_supportedOperators.put(Type.Cut, new OperatorCutLocal());</span>
<span class="fc" id="L110">		st_supportedOperators.put(Type.ExportToWkb,</span>
				new OperatorExportToWkbLocal());
<span class="fc" id="L112">		st_supportedOperators.put(Type.ImportFromWkb,</span>
				new OperatorImportFromWkbLocal());
<span class="fc" id="L114">		st_supportedOperators.put(Type.ExportToWkt,</span>
				new OperatorExportToWktLocal());
<span class="fc" id="L116">		st_supportedOperators.put(Type.ImportFromWkt,</span>
				new OperatorImportFromWktLocal());
<span class="fc" id="L118">		st_supportedOperators.put(Type.ImportFromGeoJson,</span>
				new OperatorImportFromGeoJsonLocal());
<span class="fc" id="L120">        st_supportedOperators.put(Type.ExportToGeoJson,</span>
                new OperatorExportToGeoJsonLocal());
<span class="fc" id="L122">		st_supportedOperators.put(Type.Union, new OperatorUnionLocal());</span>

<span class="fc" id="L124">		st_supportedOperators.put(Type.Generalize,</span>
				new OperatorGeneralizeLocal());
<span class="fc" id="L126">		st_supportedOperators.put(Type.ConvexHull,</span>
				new OperatorConvexHullLocal());
<span class="fc" id="L128">		st_supportedOperators.put(Type.Boundary, new OperatorBoundaryLocal());</span>

		// LabelPoint, - not ported

<span class="fc" id="L132">	}</span>

	private OperatorFactoryLocal() {

	}


	/**
	 *Returns a reference to the singleton.
	 */
	public static OperatorFactoryLocal getInstance() {
<span class="fc" id="L143">		return INSTANCE;</span>
	}

	@Override
	public Operator getOperator(Type type) {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		if (st_supportedOperators.containsKey(type)) {</span>
<span class="fc" id="L149">			return st_supportedOperators.get(type);</span>
		} else {
<span class="nc" id="L151">			throw new IllegalArgumentException();</span>
		}
	}

	@Override
	public boolean isOperatorSupported(Operator.Type type) {
<span class="nc" id="L157">		return st_supportedOperators.containsKey(type);</span>
	}

	public static void saveJSONToTextFileDbg(String file_name,
			Geometry geometry, SpatialReference spatial_ref) {
<span class="nc bnc" id="L162" title="All 2 branches missed.">		if (file_name == null) {</span>
<span class="nc" id="L163">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L166">		OperatorFactoryLocal engine = OperatorFactoryLocal.getInstance();</span>
<span class="nc" id="L167">		OperatorExportToJson exporterJSON = (OperatorExportToJson) engine</span>
<span class="nc" id="L168">				.getOperator(Operator.Type.ExportToJson);</span>
<span class="nc" id="L169">		String jsonString = exporterJSON.execute(spatial_ref, geometry);</span>

		try {
<span class="nc" id="L172">			FileOutputStream outfile = new FileOutputStream(file_name);</span>
<span class="nc" id="L173">			PrintStream p = new PrintStream(outfile);</span>
<span class="nc" id="L174">			p.print(jsonString);</span>
<span class="nc" id="L175">			p.close();</span>
<span class="nc" id="L176">		} catch (Exception ex) {</span>
<span class="nc" id="L177">		}</span>
<span class="nc" id="L178">	}</span>

	public static MapGeometry loadGeometryFromJSONFileDbg(String file_name) {
<span class="nc bnc" id="L181" title="All 2 branches missed.">		if (file_name == null) {</span>
<span class="nc" id="L182">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L185">		String jsonString = null;</span>
<span class="nc" id="L186">		Reader reader = null;</span>
		try {
<span class="nc" id="L188">			FileInputStream stream = new FileInputStream(file_name);</span>
<span class="nc" id="L189">			reader = new BufferedReader(new InputStreamReader(stream));</span>
<span class="nc" id="L190">			StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L191">			char[] buffer = new char[8192];</span>
			int read;
<span class="nc bnc" id="L193" title="All 2 branches missed.">			while ((read = reader.read(buffer, 0, buffer.length)) &gt; 0) {</span>
<span class="nc" id="L194">				builder.append(buffer, 0, read);</span>
			}

<span class="nc" id="L197">			jsonString = builder.toString();</span>
<span class="nc" id="L198">		} catch (Exception ex) {</span>
		}
		finally {
<span class="nc bnc" id="L201" title="All 2 branches missed.">			if (reader != null) {</span>
				try {
<span class="nc" id="L203">					reader.close();</span>
<span class="nc" id="L204">				} catch (IOException e) {</span>
<span class="nc" id="L205">				}</span>
			}
		}

<span class="nc" id="L209">		MapGeometry mapGeom = OperatorImportFromJson.local().execute(Geometry.Type.Unknown, jsonString);</span>
<span class="nc" id="L210">		return mapGeom;</span>
	}

	public static MapGeometry loadGeometryFromJSONStringDbg(String json) {
<span class="nc bnc" id="L214" title="All 2 branches missed.">		if (json == null) {</span>
<span class="nc" id="L215">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L218">		MapGeometry mapGeom = null;</span>
		try {
<span class="nc" id="L220">			mapGeom = OperatorImportFromJson.local().execute(Geometry.Type.Unknown, json);</span>
<span class="nc" id="L221">		} catch (Exception e) {</span>
<span class="nc" id="L222">			throw new IllegalArgumentException(e.toString());</span>
<span class="nc" id="L223">		}</span>
<span class="nc" id="L224">		return mapGeom;</span>
	}
	
	public static Geometry loadGeometryFromEsriShapeDbg(String file_name) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">		if (file_name == null) {</span>
<span class="nc" id="L229">			throw new IllegalArgumentException();</span>
		}

		try {
<span class="nc" id="L233">			FileInputStream stream = new FileInputStream(file_name);</span>
<span class="nc" id="L234">			FileChannel fchan = stream.getChannel();</span>
<span class="nc" id="L235">			ByteBuffer bb = ByteBuffer.allocate((int) fchan.size());</span>
<span class="nc" id="L236">			fchan.read(bb);</span>
<span class="nc" id="L237">			bb.order(ByteOrder.LITTLE_ENDIAN);</span>
<span class="nc" id="L238">			Geometry g = OperatorImportFromESRIShape.local().execute(0,</span>
					Geometry.Type.Unknown, bb);
<span class="nc" id="L240">			fchan.close();</span>
<span class="nc" id="L241">			stream.close();</span>
<span class="nc" id="L242">			return g;</span>
<span class="nc" id="L243">		} catch (Exception ex) {</span>
<span class="nc" id="L244">			throw new IllegalArgumentException();</span>
		}
	}

	public static void saveGeometryToEsriShapeDbg(String file_name, Geometry geometry) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">		if (file_name == null) {</span>
<span class="nc" id="L250">			throw new IllegalArgumentException();</span>
		}

		try {
<span class="nc" id="L254">			ByteBuffer bb = OperatorExportToESRIShape.local().execute(0, geometry);</span>
<span class="nc" id="L255">			FileOutputStream outfile = new FileOutputStream(file_name);</span>
<span class="nc" id="L256">			FileChannel fchan = outfile.getChannel();</span>
<span class="nc" id="L257">			fchan.write(bb);</span>
<span class="nc" id="L258">			fchan.close();</span>
<span class="nc" id="L259">			outfile.close();</span>
<span class="nc" id="L260">		} catch (Exception ex) {</span>
<span class="nc" id="L261">			throw new IllegalArgumentException();</span>
<span class="nc" id="L262">		}</span>
<span class="nc" id="L263">	}</span>
	
	public static void saveToWKTFileDbg(String file_name,
			Geometry geometry, SpatialReference spatial_ref) {
<span class="nc bnc" id="L267" title="All 2 branches missed.">		if (file_name == null) {</span>
<span class="nc" id="L268">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L271">		String jsonString = OperatorExportToWkt.local().execute(0, geometry, null);</span>

		try {
<span class="nc" id="L274">			FileOutputStream outfile = new FileOutputStream(file_name);</span>
<span class="nc" id="L275">			PrintStream p = new PrintStream(outfile);</span>
<span class="nc" id="L276">			p.print(jsonString);</span>
<span class="nc" id="L277">			p.close();</span>
<span class="nc" id="L278">		} catch (Exception ex) {</span>
<span class="nc" id="L279">		}</span>
<span class="nc" id="L280">	}</span>

	public static Geometry loadGeometryFromWKTFileDbg(String file_name) {
<span class="nc bnc" id="L283" title="All 2 branches missed.">		if (file_name == null) {</span>
<span class="nc" id="L284">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L287">		String s = null;</span>
<span class="nc" id="L288">		Reader reader = null;</span>
		try {
<span class="nc" id="L290">			FileInputStream stream = new FileInputStream(file_name);</span>
<span class="nc" id="L291">			reader = new BufferedReader(new InputStreamReader(stream));</span>
<span class="nc" id="L292">			StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L293">			char[] buffer = new char[8192];</span>
			int read;
<span class="nc bnc" id="L295" title="All 2 branches missed.">			while ((read = reader.read(buffer, 0, buffer.length)) &gt; 0) {</span>
<span class="nc" id="L296">				builder.append(buffer, 0, read);</span>
			}

<span class="nc" id="L299">			s = builder.toString();</span>
<span class="nc" id="L300">		} catch (Exception ex) {</span>
		}
		finally {
<span class="nc bnc" id="L303" title="All 2 branches missed.">			if (reader != null) {</span>
				try {
<span class="nc" id="L305">					reader.close();</span>
<span class="nc" id="L306">				} catch (IOException e) {</span>
<span class="nc" id="L307">				}</span>
			}
		}

<span class="nc" id="L311">		return OperatorImportFromWkt.local().execute(0, Geometry.Type.Unknown, s, null);</span>
	}


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>