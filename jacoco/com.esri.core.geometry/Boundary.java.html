<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Boundary.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">Boundary.java</span></div><h1>Boundary.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2015 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */
package com.esri.core.geometry;

<span class="nc" id="L26">class Boundary {</span>

	static boolean hasNonEmptyBoundary(Geometry geom,
			ProgressTracker progress_tracker) {
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">		if (geom.isEmpty())</span>
<span class="nc" id="L31">			return false;</span>

<span class="fc" id="L33">		Geometry.Type gt = geom.getType();</span>
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">		if (gt == Geometry.Type.Polygon) {</span>
<span class="nc bnc" id="L35" title="All 2 branches missed.">			if (geom.calculateArea2D() == 0)</span>
<span class="nc" id="L36">				return false;</span>

<span class="nc" id="L38">			return true;</span>
<span class="pc bpc" id="L39" title="1 of 2 branches missed.">		} else if (gt == Geometry.Type.Polyline) {</span>
<span class="fc" id="L40">			boolean[] b = new boolean[1];</span>
<span class="fc" id="L41">			b[0] = false;</span>
<span class="fc" id="L42">			calculatePolylineBoundary_(geom._getImpl(), progress_tracker, true,</span>
					b);
<span class="fc" id="L44">			return b[0];</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">		} else if (gt == Geometry.Type.Envelope) {</span>
<span class="nc" id="L46">			return true;</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">		} else if (Geometry.isSegment(gt.value())) {</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">			if (!((Segment) geom).isClosed()) {</span>
<span class="nc" id="L49">				return true;</span>
			}

<span class="nc" id="L52">			return false;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">		} else if (Geometry.isPoint(gt.value())) {</span>
<span class="nc" id="L54">			return false;</span>
		}

<span class="nc" id="L57">		return false;</span>
	}

	static Geometry calculate(Geometry geom, ProgressTracker progress_tracker) {
<span class="fc" id="L61">		int gt = geom.getType().value();</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">		if (gt == Geometry.GeometryType.Polygon) {</span>
<span class="fc" id="L63">			Polyline dst = new Polyline(geom.getDescription());</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">			if (!geom.isEmpty()) {</span>
<span class="fc" id="L65">				((MultiPathImpl) geom._getImpl())</span>
<span class="fc" id="L66">						._copyToUnsafe((MultiPathImpl) dst._getImpl());</span>
			}

<span class="fc" id="L69">			return dst;</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">		} else if (gt == Geometry.GeometryType.Polyline) {</span>
<span class="fc" id="L71">			return calculatePolylineBoundary_(geom._getImpl(),</span>
					progress_tracker, false, null);
<span class="nc bnc" id="L73" title="All 2 branches missed.">		} else if (gt == Geometry.GeometryType.Envelope) {</span>
<span class="nc" id="L74">			Polyline dst = new Polyline(geom.getDescription());</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">			if (!geom.isEmpty())</span>
<span class="nc" id="L76">				dst.addEnvelope((Envelope) geom, false);</span>

<span class="nc" id="L78">			return dst;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">		} else if (Geometry.isSegment(gt)) {</span>
<span class="nc" id="L80">			MultiPoint mp = new MultiPoint(geom.getDescription());</span>
<span class="nc bnc" id="L81" title="All 4 branches missed.">			if (!geom.isEmpty() &amp;&amp; !((Segment) geom).isClosed()) {</span>
<span class="nc" id="L82">				Point pt = new Point();</span>
<span class="nc" id="L83">				((Segment) geom).queryStart(pt);</span>
<span class="nc" id="L84">				mp.add(pt);</span>
<span class="nc" id="L85">				((Segment) geom).queryEnd(pt);</span>
<span class="nc" id="L86">				mp.add(pt);</span>
			}
<span class="nc" id="L88">			return mp;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">		} else if (Geometry.isPoint(gt)) {</span>
			// returns empty point for points and multipoints.
<span class="nc" id="L91">			return null;</span>
		}

<span class="nc" id="L94">		throw new IllegalArgumentException();</span>
	}

	private static final class MultiPathImplBoundarySorter extends ClassicSort {
		AttributeStreamOfDbl m_xy;

		static final class CompareIndices extends
				AttributeStreamOfInt32.IntComparator {
			AttributeStreamOfDbl m_xy;
			Point2D pt1_helper;
			Point2D pt2_helper;

<span class="fc" id="L106">			CompareIndices(AttributeStreamOfDbl xy) {</span>
<span class="fc" id="L107">				m_xy = xy;</span>
<span class="fc" id="L108">				pt1_helper = new Point2D();</span>
<span class="fc" id="L109">				pt2_helper = new Point2D();</span>
<span class="fc" id="L110">			}</span>

			@Override
			public int compare(int v1, int v2) {
<span class="fc" id="L114">				m_xy.read(2 * v1, pt1_helper);</span>
<span class="fc" id="L115">				m_xy.read(2 * v2, pt2_helper);</span>
<span class="fc" id="L116">				return pt1_helper.compare(pt2_helper);</span>
			}
		}

<span class="fc" id="L120">		MultiPathImplBoundarySorter(AttributeStreamOfDbl xy) {</span>
<span class="fc" id="L121">			m_xy = xy;</span>
<span class="fc" id="L122">		}</span>

		@Override
		public void userSort(int begin, int end, AttributeStreamOfInt32 indices) {
<span class="fc" id="L126">			indices.Sort(begin, end, new CompareIndices(m_xy));</span>
<span class="fc" id="L127">		}</span>

		@Override
		public double getValue(int index) {
<span class="nc" id="L131">			return m_xy.read(2 * index + 1);</span>
		}
	}

	static MultiPoint calculatePolylineBoundary_(Object impl,
			ProgressTracker progress_tracker,
			boolean only_check_non_empty_boundary, boolean[] not_empty) {
<span class="fc bfc" id="L138" title="All 2 branches covered.">		if (not_empty != null)</span>
<span class="fc" id="L139">			not_empty[0] = false;</span>
<span class="fc" id="L140">		MultiPathImpl mpImpl = (MultiPathImpl) impl;</span>
<span class="fc" id="L141">		MultiPoint dst = null;</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">		if (!only_check_non_empty_boundary)</span>
<span class="fc" id="L143">			dst = new MultiPoint(mpImpl.getDescription());</span>

<span class="pc bpc" id="L145" title="1 of 2 branches missed.">		if (!mpImpl.isEmpty()) {</span>
<span class="fc" id="L146">			AttributeStreamOfInt32 indices = new AttributeStreamOfInt32(0);</span>
<span class="fc" id="L147">			indices.reserve(mpImpl.getPathCount() * 2);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">			for (int ipath = 0, nPathCount = mpImpl.getPathCount(); ipath &lt; nPathCount; ipath++) {</span>
<span class="fc" id="L149">				int path_size = mpImpl.getPathSize(ipath);</span>
<span class="pc bpc" id="L150" title="1 of 4 branches missed.">				if (path_size &gt; 0 &amp;&amp; !mpImpl.isClosedPathInXYPlane(ipath))// closed</span>
																			// paths
																			// of
																			// polyline
																			// do
																			// not
																			// contribute
																			// to
																			// the
																			// boundary.
				{
<span class="fc" id="L161">					int start = mpImpl.getPathStart(ipath);</span>
<span class="fc" id="L162">					indices.add(start);</span>
<span class="fc" id="L163">					int end = mpImpl.getPathEnd(ipath) - 1;</span>
<span class="fc" id="L164">					indices.add(end);</span>
				}
			}
<span class="fc bfc" id="L167" title="All 2 branches covered.">			if (indices.size() &gt; 0) {</span>
<span class="fc" id="L168">				BucketSort sorter = new BucketSort();</span>
<span class="fc" id="L169">				AttributeStreamOfDbl xy = (AttributeStreamOfDbl) (mpImpl</span>
<span class="fc" id="L170">						.getAttributeStreamRef(VertexDescription.Semantics.POSITION));</span>
<span class="fc" id="L171">				sorter.sort(indices, 0, indices.size(),</span>
						new MultiPathImplBoundarySorter(xy));
<span class="fc" id="L173">				Point2D ptPrev = new Point2D();</span>
<span class="fc" id="L174">				xy.read(2 * indices.get(0), ptPrev);</span>
<span class="fc" id="L175">				int ind = 0;</span>
<span class="fc" id="L176">				int counter = 1;</span>
<span class="fc" id="L177">				Point point = new Point();</span>
<span class="fc" id="L178">				Point2D pt = new Point2D();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">				for (int i = 1, n = indices.size(); i &lt; n; i++) {</span>
<span class="fc" id="L180">					xy.read(2 * indices.get(i), pt);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">					if (pt.isEqual(ptPrev)) {</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">						if (indices.get(ind) &gt; indices.get(i)) {</span>
							// remove duplicate point
<span class="nc" id="L184">							indices.set(ind, NumberUtils.intMax());</span>
<span class="nc" id="L185">							ind = i;// just for the heck of it, have the first</span>
									// point in the order to be added to the
									// boundary.
						} else
<span class="fc" id="L189">							indices.set(i, NumberUtils.intMax());</span>

<span class="fc" id="L191">						counter++;</span>
					} else {
<span class="fc bfc" id="L193" title="All 2 branches covered.">						if ((counter &amp; 1) == 0) {// remove boundary point</span>
<span class="fc" id="L194">							indices.set(ind, NumberUtils.intMax());</span>
						} else {
<span class="fc bfc" id="L196" title="All 2 branches covered.">							if (only_check_non_empty_boundary) {</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">								if (not_empty != null)</span>
<span class="fc" id="L198">									not_empty[0] = true;</span>
<span class="fc" id="L199">								return null;</span>
							}
						}

<span class="fc" id="L203">						ptPrev.setCoords(pt);</span>
<span class="fc" id="L204">						ind = i;</span>
<span class="fc" id="L205">						counter = 1;</span>
					}
				}

<span class="fc bfc" id="L209" title="All 2 branches covered.">				if ((counter &amp; 1) == 0) {// remove the point</span>
<span class="fc" id="L210">					indices.set(ind, NumberUtils.intMax());</span>
				} else {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">					if (only_check_non_empty_boundary) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">						if (not_empty != null)</span>
<span class="nc" id="L214">							not_empty[0] = true;</span>
<span class="nc" id="L215">						return null;</span>
					}
				}
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">				if (!only_check_non_empty_boundary) {</span>
<span class="fc" id="L219">					indices.sort(0, indices.size());</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">					for (int i = 0, n = indices.size(); i &lt; n; i++) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">						if (indices.get(i) == NumberUtils.intMax())</span>
<span class="fc" id="L223">							break;</span>

<span class="fc" id="L225">						mpImpl.getPointByVal(indices.get(i), point);</span>
<span class="fc" id="L226">						dst.add(point);</span>
					}
				}
			}
		}

<span class="fc bfc" id="L232" title="All 2 branches covered.">		if (only_check_non_empty_boundary)</span>
<span class="fc" id="L233">			return null;</span>

<span class="fc" id="L235">		return dst;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>