<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SegmentIntersector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Esri Geometry API for Java</a> &gt; <a href="index.source.html" class="el_package">com.esri.core.geometry</a> &gt; <span class="el_source">SegmentIntersector.java</span></div><h1>SegmentIntersector.java</h1><pre class="source lang-java linenums">/*
 Copyright 1995-2015 Esri

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 For additional information, contact:
 Environmental Systems Research Institute, Inc.
 Attn: Contracts Dept
 380 New York Street
 Redlands, California, USA 92373

 email: contracts@esri.com
 */
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.esri.core.geometry;

import java.util.ArrayList;

<span class="fc" id="L32">class SegmentIntersector {</span>
	private static class IntersectionPart {
		public Segment seg;
		// Weight controls the snapping. When points of the same rank are
		// snapped together,
		// The new posistion is calculated as a weighted average.
		public double weight_start;
		public double weight_end;
		// The rank controls the snapping. The point with lower rank will be
		// snapped to the point with the higher rank.
		public int rank_start; // the rank of the start point
		public int rank_end; // the rank of the end point
		public int rank_interior; // the rank of the interior point

<span class="fc" id="L46">		IntersectionPart(Segment _seg) {</span>
<span class="fc" id="L47">			seg = _seg;</span>
<span class="fc" id="L48">			weight_start = 1.0;</span>
<span class="fc" id="L49">			weight_end = 1.0;</span>
<span class="fc" id="L50">			rank_start = 0;</span>
<span class="fc" id="L51">			rank_end = 0;</span>
<span class="fc" id="L52">			rank_interior = 0;</span>
<span class="fc" id="L53">		}</span>
	}

	// typedef std::shared_ptr&lt;Segment_buffer&gt; segment_buffer_sptr;
	// typedef std::shared_ptr&lt;Intersection_part&gt; intersection_part_sptr;
	// typedef Dynamic_array&lt;intersection_part_sptr&gt; intersection_parts;

	private ArrayList&lt;IntersectionPart&gt; m_input_segments;
	private ArrayList&lt;IntersectionPart&gt; m_result_segments_1;
	private ArrayList&lt;IntersectionPart&gt; m_result_segments_2;
	private ArrayList&lt;IntersectionPart&gt; m_recycled_intersection_parts;
	private ArrayList&lt;SegmentBuffer&gt; m_recycled_segments;
<span class="fc" id="L65">	private double[] m_param_1 = new double[15];</span>
<span class="fc" id="L66">	private double[] m_param_2 = new double[15];</span>
<span class="fc" id="L67">	private Point m_point = new Point();</span>

	private int m_used_recycled_segments;

	private void recycle_(ArrayList&lt;IntersectionPart&gt; parts) {
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">		if (parts == null)</span>
<span class="nc" id="L73">			return;</span>

<span class="fc bfc" id="L75" title="All 2 branches covered.">		for (int i = 0, n = (int) parts.size(); i &lt; n; i++) {</span>
<span class="fc" id="L76">			recycle_(parts.get(i));</span>
		}

<span class="fc" id="L79">		parts.clear();</span>
<span class="fc" id="L80">	}</span>

	private void recycle_(IntersectionPart part) {
<span class="fc" id="L83">		part.seg = null;</span>
<span class="fc" id="L84">		m_recycled_intersection_parts.add(part);</span>
<span class="fc" id="L85">	}</span>

	private IntersectionPart newIntersectionPart_(Segment _seg) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">		if (m_recycled_intersection_parts.isEmpty()) {</span>
<span class="fc" id="L89">			IntersectionPart part = new IntersectionPart(_seg);</span>
<span class="fc" id="L90">			return part;</span>
		} else {
<span class="fc" id="L92">			IntersectionPart part = m_recycled_intersection_parts</span>
<span class="fc" id="L93">					.get(m_recycled_intersection_parts.size() - 1);</span>
<span class="fc" id="L94">			part.seg = _seg;</span>
<span class="fc" id="L95">			m_recycled_intersection_parts.remove(m_recycled_intersection_parts</span>
<span class="fc" id="L96">					.size() - 1);</span>
<span class="fc" id="L97">			return part;</span>
		}
	}

	private IntersectionPart getResultPart_(int input_segment_index,
			int segment_index) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">		if (input_segment_index == 0) {</span>
<span class="fc" id="L104">			return m_result_segments_1.get(segment_index);</span>
		} else {
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">			assert (input_segment_index == 1);</span>
<span class="fc" id="L107">			return m_result_segments_2.get(segment_index);</span>
		}
	}

	private SegmentBuffer newSegmentBuffer_() {
<span class="fc bfc" id="L112" title="All 2 branches covered.">		if (m_used_recycled_segments &gt;= m_recycled_segments.size()) {</span>
<span class="fc" id="L113">			m_recycled_segments.add(new SegmentBuffer());</span>
		}

<span class="fc" id="L116">		SegmentBuffer p = m_recycled_segments.get(m_used_recycled_segments);</span>
<span class="fc" id="L117">		m_used_recycled_segments++;</span>
<span class="fc" id="L118">		return p;</span>
	}

	private double m_tolerance;

<span class="fc" id="L123">	public SegmentIntersector() {</span>
<span class="fc" id="L124">		m_used_recycled_segments = 0;</span>
<span class="fc" id="L125">		m_tolerance = 0;</span>
<span class="fc" id="L126">		m_input_segments = new ArrayList&lt;IntersectionPart&gt;();</span>
<span class="fc" id="L127">		m_result_segments_1 = new ArrayList&lt;IntersectionPart&gt;();</span>
<span class="fc" id="L128">		m_result_segments_2 = new ArrayList&lt;IntersectionPart&gt;();</span>
<span class="fc" id="L129">		m_recycled_intersection_parts = new ArrayList&lt;IntersectionPart&gt;();</span>
<span class="fc" id="L130">		m_recycled_segments = new ArrayList&lt;SegmentBuffer&gt;();</span>
<span class="fc" id="L131">	}</span>

	// Clears the results and input segments
	public void clear() {
<span class="fc" id="L135">		recycle_(m_input_segments);</span>
<span class="fc" id="L136">		recycle_(m_result_segments_1);</span>
<span class="fc" id="L137">		recycle_(m_result_segments_2);</span>
<span class="fc" id="L138">		m_used_recycled_segments = 0;</span>
<span class="fc" id="L139">	}</span>

	// Adds a segment to intersect and returns an index of the segment.
	// Two segments has to be pushed for the intersect method to succeed.
	public int pushSegment(Segment seg) {
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">		assert (m_input_segments.size() &lt; 2);</span>
<span class="fc" id="L145">		m_input_segments.add(newIntersectionPart_(seg));</span>
		// m_param_1.resize(15);
		// m_param_2.resize(15);
<span class="fc" id="L148">		return (int) m_input_segments.size() - 1;</span>
	}

	public void setRankAndWeight(int input_segment_index, double start_weight,
			int start_rank, double end_weight, int end_rank, int interior_rank) {
<span class="nc" id="L153">		IntersectionPart part = m_input_segments.get(input_segment_index);</span>
<span class="nc" id="L154">		part.rank_end = end_rank;</span>
<span class="nc" id="L155">		part.weight_start = start_weight;</span>
<span class="nc" id="L156">		part.weight_end = end_weight;</span>
<span class="nc" id="L157">		part.rank_start = start_rank;</span>
<span class="nc" id="L158">		part.rank_end = end_rank;</span>
<span class="nc" id="L159">		part.rank_interior = interior_rank;</span>
<span class="nc" id="L160">	}</span>

	// Returns the number of segments the input segment has been split to.
	public int getResultSegmentCount(int input_segment_index) {
<span class="fc bfc" id="L164" title="All 2 branches covered.">		if (input_segment_index == 0) {</span>
<span class="fc" id="L165">			return (int) m_result_segments_1.size();</span>
		} else {
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">			assert (input_segment_index == 1);</span>
<span class="fc" id="L168">			return (int) m_result_segments_2.size();</span>
		}
	}

	// Returns a part of the input segment that is the result of the
	// intersection with another segment.
	// input_segment_index is the index of the input segment.
	// segment_index is between 0 and
	// get_result_segment_count(input_segment_index) - 1
	public Segment getResultSegment(int input_segment_index, int segment_index) {
<span class="fc" id="L178">		return getResultPart_(input_segment_index, segment_index).seg;</span>
	}

	// double get_result_segment_start_point_weight(int input_segment_index, int
	// segment_index);
	// int get_result_segment_start_point_rank(int input_segment_index, int
	// segment_index);
	// double get_result_segment_end_point_weight(int input_segment_index, int
	// segment_index);
	// int get_result_segment_end_point_rank(int input_segment_index, int
	// segment_index);
	// int get_result_segment_interior_rank(int input_segment_index, int
	// segment_index);
	public Point getResultPoint() {
<span class="fc" id="L192">		return m_point;</span>
	}

	// Performs the intersection
	public boolean intersect(double tolerance, boolean b_intersecting) {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">		if (m_input_segments.size() != 2)</span>
<span class="nc" id="L198">			throw GeometryException.GeometryInternalError();</span>

<span class="fc" id="L200">		m_tolerance = tolerance;</span>
<span class="fc" id="L201">		double small_tolerance_sqr = MathUtils.sqr(tolerance * 0.01);</span>
<span class="fc" id="L202">		boolean bigmove = false;</span>
		
<span class="fc" id="L204">		IntersectionPart part1 = m_input_segments.get(0);</span>
<span class="fc" id="L205">		IntersectionPart part2 = m_input_segments.get(1);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">		if (b_intersecting</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">				|| (part1.seg._isIntersecting(part2.seg, tolerance, true) &amp; 5) != 0) {</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">			if (part1.seg.getType().value() == Geometry.GeometryType.Line) {</span>
<span class="fc" id="L209">				Line line_1 = (Line) part1.seg;</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">				if (part2.seg.getType().value() == Geometry.GeometryType.Line) {</span>
<span class="fc" id="L211">					Line line_2 = (Line) part2.seg;</span>
<span class="fc" id="L212">					int count = Line._intersectLineLine(line_1, line_2, null,</span>
							m_param_1, m_param_2, tolerance);
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">					if (count == 0) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">						assert (count &gt; 0);</span>
<span class="nc" id="L216">						throw GeometryException.GeometryInternalError();</span>
					}
<span class="fc" id="L218">					Point2D[] points = new Point2D[9];</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">					for (int i = 0; i &lt; count; i++) {</span>
						// For each point of intersection, we calculate a
						// weighted point
						// based on the ranks and weights of the endpoints and
						// the interior.
<span class="fc" id="L224">						double t1 = m_param_1[i];</span>
<span class="fc" id="L225">						double t2 = m_param_2[i];</span>
<span class="fc" id="L226">						int rank1 = part1.rank_interior;</span>
<span class="fc" id="L227">						double weight1 = 1.0;</span>

<span class="fc bfc" id="L229" title="All 2 branches covered.">						if (t1 == 0) {</span>
<span class="fc" id="L230">							rank1 = part1.rank_start;</span>
<span class="fc" id="L231">							weight1 = part1.weight_start;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">						} else if (t1 == 1.0) {</span>
<span class="fc" id="L233">							rank1 = part1.rank_end;</span>
<span class="fc" id="L234">							weight1 = part1.weight_end;</span>
						}

<span class="fc" id="L237">						int rank2 = part2.rank_interior;</span>
<span class="fc" id="L238">						double weight2 = 1.0;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">						if (t2 == 0) {</span>
<span class="fc" id="L240">							rank2 = part2.rank_start;</span>
<span class="fc" id="L241">							weight2 = part2.weight_start;</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">						} else if (t2 == 1.0) {</span>
<span class="fc" id="L243">							rank2 = part2.rank_end;</span>
<span class="fc" id="L244">							weight2 = part2.weight_end;</span>
						}

						double ptWeight;

<span class="fc" id="L249">						Point2D pt = new Point2D();</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">						if (rank1 == rank2) {// for equal ranks use weighted sum</span>
<span class="fc" id="L251">							Point2D pt_1 = new Point2D();</span>
<span class="fc" id="L252">							line_1.getCoord2D(t1, pt_1);</span>
<span class="fc" id="L253">							Point2D pt_2 = new Point2D();</span>
<span class="fc" id="L254">							line_2.getCoord2D(t2, pt_2);</span>
<span class="fc" id="L255">							ptWeight = weight1 + weight2;</span>
<span class="fc" id="L256">							double t = weight2 / ptWeight;</span>
<span class="fc" id="L257">							MathUtils.lerp(pt_1, pt_2, t, pt);</span>
<span class="fc" id="L258">							if (Point2D.sqrDistance(pt, pt_1)</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">									+ Point2D.sqrDistance(pt, pt_2) &gt; small_tolerance_sqr)</span>
<span class="fc" id="L260">								bigmove = true;</span>
							
<span class="fc" id="L262">						} else {// for non-equal ranks, the higher rank wins</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">							if (rank1 &gt; rank2) {</span>
<span class="nc" id="L264">								line_1.getCoord2D(t1, pt);</span>
<span class="nc" id="L265">								ptWeight = weight1;</span>
<span class="nc" id="L266">								Point2D pt_2 = new Point2D();</span>
<span class="nc" id="L267">								line_2.getCoord2D(t2, pt_2);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">								if (Point2D.sqrDistance(pt, pt_2) &gt; small_tolerance_sqr)</span>
<span class="nc" id="L269">									bigmove = true;</span>
<span class="nc" id="L270">							} else {</span>
<span class="nc" id="L271">								line_2.getCoord2D(t2, pt);</span>
<span class="nc" id="L272">								ptWeight = weight2;</span>
<span class="nc" id="L273">								Point2D pt_1 = new Point2D();</span>
<span class="nc" id="L274">								line_1.getCoord2D(t1, pt_1);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">								if (Point2D.sqrDistance(pt, pt_1) &gt; small_tolerance_sqr)</span>
<span class="nc" id="L276">									bigmove = true;</span>
							}
						}
<span class="fc" id="L279">						points[i] = pt;</span>
					}

					// Split the line_1, making sure the endpoints are adusted
					// to the weighted
<span class="fc" id="L284">					double t0 = 0;</span>
<span class="fc" id="L285">					int i0 = -1;</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">					for (int i = 0; i &lt;= count; i++) {</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">						double t = i &lt; count ? m_param_1[i] : 1.0;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">						if (t != t0) {</span>
<span class="fc" id="L289">							SegmentBuffer seg_buffer = newSegmentBuffer_();</span>
<span class="fc" id="L290">							line_1.cut(t0, t, seg_buffer);</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">							if (i0 != -1)</span>
<span class="fc" id="L292">								seg_buffer.get().setStartXY(points[i0]);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">							if (i != count)</span>
<span class="fc" id="L294">								seg_buffer.get().setEndXY(points[i]);</span>

<span class="fc" id="L296">							t0 = t;</span>
<span class="fc" id="L297">							m_result_segments_1</span>
<span class="fc" id="L298">									.add(newIntersectionPart_(seg_buffer.get()));</span>
						}
<span class="fc" id="L300">						i0 = i;</span>
					}

<span class="fc" id="L303">					int[] indices = new int[9];</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">					for (int i = 0; i &lt; count; i++)</span>
<span class="fc" id="L305">						indices[i] = i;</span>

<span class="fc bfc" id="L307" title="All 2 branches covered.">					if (count &gt; 1) {</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">						if (m_param_2[0] &gt; m_param_2[1]) {</span>
<span class="fc" id="L309">							double t = m_param_2[0];</span>
<span class="fc" id="L310">							m_param_2[0] = m_param_2[1];</span>
<span class="fc" id="L311">							m_param_2[1] = t;</span>
<span class="fc" id="L312">							int i = indices[0];</span>
<span class="fc" id="L313">							indices[0] = indices[1];</span>
<span class="fc" id="L314">							indices[1] = i;</span>
						}
					}

					// Split the line_2
<span class="fc" id="L319">					t0 = 0;</span>
<span class="fc" id="L320">					i0 = -1;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">					for (int i = 0; i &lt;= count; i++) {</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">						double t = i &lt; count ? m_param_2[i] : 1.0;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">						if (t != t0) {</span>
<span class="fc" id="L324">							SegmentBuffer seg_buffer = newSegmentBuffer_();</span>
<span class="fc" id="L325">							line_2.cut(t0, t, seg_buffer);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">							if (i0 != -1) {</span>
<span class="fc" id="L327">								int ind = indices[i0];</span>
<span class="fc" id="L328">								seg_buffer.get().setStartXY(points[ind]);</span>
							}
<span class="fc bfc" id="L330" title="All 2 branches covered.">							if (i != count) {</span>
<span class="fc" id="L331">								int ind = indices[i];</span>
<span class="fc" id="L332">								seg_buffer.get().setEndXY(points[ind]);</span>
							}

<span class="fc" id="L335">							t0 = t;</span>
<span class="fc" id="L336">							m_result_segments_2</span>
<span class="fc" id="L337">									.add(newIntersectionPart_(seg_buffer.get()));</span>
						}
<span class="fc" id="L339">						i0 = i;</span>
					}

<span class="fc" id="L342">					return bigmove;</span>
				}

<span class="nc" id="L345">				throw GeometryException.GeometryInternalError();</span>
			}

<span class="nc" id="L348">			throw GeometryException.GeometryInternalError();</span>
		}
		
<span class="fc" id="L351">		return false;</span>
	}

	public void intersect(double tolerance, Point pt_intersector_point,
			int point_rank, double point_weight, boolean b_intersecting) {
<span class="fc" id="L356">		pt_intersector_point.copyTo(m_point);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">		if (m_input_segments.size() != 1)</span>
<span class="nc" id="L358">			throw GeometryException.GeometryInternalError();</span>

<span class="fc" id="L360">		m_tolerance = tolerance;</span>

<span class="fc" id="L362">		IntersectionPart part1 = m_input_segments.get(0);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">		if (b_intersecting</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">				|| part1.seg._isIntersectingPoint(pt_intersector_point.getXY(),</span>
						tolerance, true)) {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">			if (part1.seg.getType().value() == Geometry.GeometryType.Line) {</span>
<span class="fc" id="L367">				Line line_1 = (Line) (part1.seg);</span>
<span class="fc" id="L368">				double t1 = line_1.getClosestCoordinate(</span>
<span class="fc" id="L369">						pt_intersector_point.getXY(), false);</span>
<span class="fc" id="L370">				m_param_1[0] = t1;</span>
				// For each point of intersection, we calculate a weighted point
				// based on the ranks and weights of the endpoints and the
				// interior.
<span class="fc" id="L374">				int rank1 = part1.rank_interior;</span>
<span class="fc" id="L375">				double weight1 = 1.0;</span>

<span class="pc bpc" id="L377" title="1 of 2 branches missed.">				if (t1 == 0) {</span>
<span class="nc" id="L378">					rank1 = part1.rank_start;</span>
<span class="nc" id="L379">					weight1 = part1.weight_start;</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">				} else if (t1 == 1.0) {</span>
<span class="nc" id="L381">					rank1 = part1.rank_end;</span>
<span class="nc" id="L382">					weight1 = part1.weight_end;</span>
				}

<span class="fc" id="L385">				int rank2 = point_rank;</span>
<span class="fc" id="L386">				double weight2 = point_weight;</span>

				double ptWeight;

<span class="fc" id="L390">				Point2D pt = new Point2D();</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">				if (rank1 == rank2) {// for equal ranks use weighted sum</span>
<span class="fc" id="L392">					Point2D pt_1 = new Point2D();</span>
<span class="fc" id="L393">					line_1.getCoord2D(t1, pt_1);</span>
<span class="fc" id="L394">					Point2D pt_2 = pt_intersector_point.getXY();</span>
<span class="fc" id="L395">					ptWeight = weight1 + weight2;</span>
<span class="fc" id="L396">					double t = weight2 / ptWeight;</span>
<span class="fc" id="L397">					MathUtils.lerp(pt_1,  pt_2, t, pt);</span>
<span class="fc" id="L398">				} else {// for non-equal ranks, the higher rank wins</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">					if (rank1 &gt; rank2) {</span>
<span class="nc" id="L400">						pt = new Point2D();</span>
<span class="nc" id="L401">						line_1.getCoord2D(t1, pt);</span>
<span class="nc" id="L402">						ptWeight = weight1;</span>
					} else {
<span class="nc" id="L404">						pt = pt_intersector_point.getXY();</span>
<span class="nc" id="L405">						ptWeight = weight2;</span>
					}
				}

				// Split the line_1, making sure the endpoints are adusted to
				// the weighted
<span class="fc" id="L411">				double t0 = 0;</span>
<span class="fc" id="L412">				int i0 = -1;</span>
<span class="fc" id="L413">				int count = 1;</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">				for (int i = 0; i &lt;= count; i++) {</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">					double t = i &lt; count ? m_param_1[i] : 1.0;</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">					if (t != t0) {</span>
<span class="fc" id="L417">						SegmentBuffer seg_buffer = newSegmentBuffer_();</span>
<span class="fc" id="L418">						line_1.cut(t0, t, seg_buffer);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">						if (i0 != -1)</span>
<span class="fc" id="L420">							seg_buffer.get().setStartXY(pt);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">						if (i != count)</span>
<span class="fc" id="L422">							seg_buffer.get().setEndXY(pt);</span>

<span class="fc" id="L424">						t0 = t;</span>
<span class="fc" id="L425">						m_result_segments_1.add(newIntersectionPart_(seg_buffer</span>
<span class="fc" id="L426">								.get()));</span>
					}
<span class="fc" id="L428">					i0 = i;</span>
				}

<span class="fc" id="L431">				m_point.setXY(pt);</span>

<span class="fc" id="L433">				return;</span>
			}

<span class="nc" id="L436">			throw GeometryException.GeometryInternalError();</span>
		}
<span class="fc" id="L438">	}</span>

	public double get_tolerance_() {
<span class="nc" id="L441">		return m_tolerance;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>